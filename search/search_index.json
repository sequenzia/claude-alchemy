{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Home","text":""},{"location":"#claude-alchemy","title":"Claude Alchemy","text":"<p>A toolkit for AI-assisted software development using Claude Code. Claude Alchemy combines two Claude Code plugins with a real-time Task Manager application in a single pnpm monorepo. The three subsystems communicate through a filesystem-as-message-bus pattern \u2014 no shared runtime code, no database, no IPC.</p>"},{"location":"#the-three-subsystems","title":"The Three Subsystems","text":"<pre><code>graph LR\n    subgraph Monorepo\n        TM[\"Task Manager&lt;br/&gt;&lt;small&gt;apps/task-manager/&lt;/small&gt;\"]\n        TP[\"Tools Plugin&lt;br/&gt;&lt;small&gt;plugins/tools/&lt;/small&gt;\"]\n        SP[\"SDD Plugin&lt;br/&gt;&lt;small&gt;plugins/sdd/&lt;/small&gt;\"]\n    end\n    FS[(\"~/.claude/tasks/&lt;br/&gt;Filesystem\")]\n    SP -- \"writes tasks &amp; progress\" --&gt; FS\n    FS -- \"watches for changes\" --&gt; TM\n    TP -- \"commits, docs, analysis\" --&gt; Monorepo</code></pre>"},{"location":"#task-manager","title":"Task Manager","text":"<p>A real-time Kanban board for monitoring Claude AI task execution. Server Components fetch task data from <code>~/.claude/tasks/</code>, Chokidar watches for changes, and SSE pushes updates to the browser \u2014 all without polling.</p> <ul> <li>Location: <code>apps/task-manager/</code></li> <li>Stack: Next.js 16.1.4, React 19.2.3, TanStack Query v5, Tailwind CSS v4, shadcn/ui</li> <li>Runs on: <code>http://localhost:3030</code></li> </ul> <p>Task Manager docs </p>"},{"location":"#tools-plugin","title":"Tools Plugin","text":"<p>Developer tools for feature development, codebase analysis, documentation generation, code review, and git workflows. Invoked from Claude Code with <code>/tools:{skill-name}</code>.</p> <ul> <li>Location: <code>plugins/tools/</code> (v0.2.2)</li> <li>10 agents, 13 skills \u2014 including <code>feature-dev</code>, <code>codebase-analysis</code>, <code>docs-manager</code>, <code>code-quality</code>, <code>deep-analysis</code>, and more</li> </ul> <p>Tools Plugin docs </p>"},{"location":"#sdd-plugin","title":"SDD Plugin","text":"<p>Spec-Driven Development: create specifications through guided interviews, analyze them for completeness, decompose them into tasks, and execute those tasks autonomously. Invoked with <code>/sdd:{skill-name}</code>.</p> <ul> <li>Location: <code>plugins/sdd/</code> (v0.2.6)</li> <li>2 agents, 4 skills \u2014 <code>create-spec</code>, <code>analyze-spec</code>, <code>create-tasks</code>, <code>execute-tasks</code></li> </ul> <p>SDD Plugin docs </p>"},{"location":"#quick-start","title":"Quick Start","text":"Full SetupPlugins Only <pre><code>git clone git@github.com:sequenzia/claude-alchemy.git\ncd claude-alchemy\npnpm install\npnpm dev:task-manager    # http://localhost:3030\n</code></pre> <p>Plugins are markdown-only with no build step. Install them directly in Claude Code:</p> <pre><code># From the Claude Code REPL\n/install-plugin /path/to/claude-alchemy/plugins/tools\n/install-plugin /path/to/claude-alchemy/plugins/sdd\n</code></pre> <p>Prerequisites</p> <ul> <li>Node.js &gt;= 18 and pnpm &gt;= 8</li> <li>Claude Code installed and configured</li> <li>Plugins require no additional dependencies \u2014 they are pure Markdown</li> </ul>"},{"location":"#documentation-map","title":"Documentation Map","text":"Section Description Getting Started Installation, configuration, and first steps Architecture Overview System design, component relationships, and design decisions Filesystem Message Bus How subsystems communicate through the filesystem Data Flow Request lifecycle and real-time update pipeline Task Manager Overview App architecture and key patterns API Reference REST and SSE endpoint documentation Real-Time System Chokidar, SSE, and TanStack Query integration Components React component tree and responsibilities Security Path traversal guards and input validation Plugins Plugin Overview Plugin architecture, skill format, and agent model tiering Tools Plugin All 13 skills and 10 agents in the developer tools plugin SDD Plugin Spec-Driven Development workflow and skills Development Setup Dev environment, running locally, and project structure"},{"location":"#tech-stack","title":"Tech Stack","text":"Technology Version Role Next.js 16.1.4 App framework (App Router, Server Components) React 19.2.3 UI library TypeScript 5 Type safety across the monorepo TanStack Query v5.90.20 Server state management and cache invalidation Tailwind CSS v4 Utility-first styling shadcn/ui latest Accessible UI components (Radix primitives) Chokidar 5 Filesystem watching for real-time updates pnpm &gt;= 8 Workspace-aware package manager <p>Plugin Runtime</p> <p>The two plugins (<code>tools</code> and <code>sdd</code>) have no runtime dependencies. They are collections of Markdown files \u2014 skills with YAML frontmatter and agent system prompts \u2014 that Claude Code loads and executes directly. No build step required.</p>"},{"location":"#license","title":"License","text":"<p>Claude Alchemy is released under the MIT License.</p>"},{"location":"getting-started/","title":"Getting Started","text":""},{"location":"getting-started/#getting-started","title":"Getting Started","text":"<p>Claude Alchemy is a monorepo that pairs two Claude Code plugins with a real-time Task Manager application. The plugins add structured development workflows to Claude Code via slash commands, and the Task Manager gives you a visual Kanban board to monitor task execution in real time. This guide walks you through installation, first run, and your first end-to-end workflow.</p>"},{"location":"getting-started/#prerequisites","title":"Prerequisites","text":"<p>Before you begin, make sure you have the following installed:</p> Requirement Minimum Version Check Command Node.js 18.0.0 <code>node --version</code> pnpm 8.0.0 <code>pnpm --version</code> Claude Code CLI Latest <code>claude --version</code> <p>Claude Code CLI</p> <p>Claude Code must be installed and authenticated before you can use the plugins. Visit the Claude Code documentation for setup instructions if you haven't configured it yet.</p>"},{"location":"getting-started/#installation","title":"Installation","text":"<p>Clone the repository and install dependencies:</p> <pre><code>git clone git@github.com:sequenzia/claude-alchemy.git\ncd claude-alchemy\npnpm install\n</code></pre> <p>Workspace Scope</p> <p>Only <code>apps/*</code> is included in the pnpm workspace (see <code>pnpm-workspace.yaml</code>). The plugins under <code>plugins/</code> are pure markdown files with no build step -- <code>pnpm install</code> only pulls dependencies for the Task Manager.</p>"},{"location":"getting-started/#running-the-task-manager","title":"Running the Task Manager","text":"<p>Start the development server:</p> <pre><code>pnpm dev:task-manager\n</code></pre> <p>The Task Manager launches at http://localhost:3030. It reads task JSON files from <code>~/.claude/tasks/</code> and renders them on a three-column Kanban board (Pending, In Progress, Completed).</p> <p>If no tasks exist yet, you will see an empty board. That is expected -- tasks are created through the SDD plugin workflow described below.</p> <p>Real-Time Updates</p> <p>The Task Manager watches <code>~/.claude/tasks/</code> with Chokidar and streams changes over SSE. As the SDD plugin creates or updates task files, the board updates automatically without a page refresh.</p>"},{"location":"getting-started/#using-the-plugins","title":"Using the Plugins","text":"<p>The two plugins are loaded automatically by Claude Code when you start a session inside the <code>claude-alchemy</code> repository. They provide slash commands that trigger structured, multi-phase workflows.</p>"},{"location":"getting-started/#tools-plugin-tools","title":"Tools Plugin (<code>/tools:</code>)","text":"<p>The Tools plugin (<code>claude-alchemy-tools</code> v0.2.2) provides general-purpose development skills:</p> Command Description <code>/tools:feature-dev</code> 7-phase feature development workflow (discovery through summary) <code>/tools:codebase-analysis</code> Structured codebase analysis with exploration and synthesis <code>/tools:docs-manager</code> Documentation generation and management <code>/tools:git-commit</code> Generate conventional commit messages <code>/tools:deep-analysis</code> Reusable exploration and synthesis pattern <code>/tools:teams-deep-analysis</code> Team-based collaborative analysis with multiple agents <code>/tools:bump-plugin-version</code> Increment plugin versions across manifest files <code>/tools:release</code> Python release workflow"},{"location":"getting-started/#sdd-plugin-sdd","title":"SDD Plugin (<code>/sdd:</code>)","text":"<p>The SDD plugin (<code>claude-alchemy-sdd</code> v0.2.6) implements the Spec-Driven Development workflow -- a four-step process that takes you from idea to autonomous implementation:</p> Command Description <code>/sdd:create-spec</code> Create a specification through an adaptive interview process <code>/sdd:analyze-spec</code> Quality review and analysis of an existing spec <code>/sdd:create-tasks</code> Decompose a specification into executable task files <code>/sdd:execute-tasks</code> Autonomous task execution with real-time progress tracking"},{"location":"getting-started/#your-first-sdd-workflow","title":"Your First SDD Workflow","text":"<p>The Spec-Driven Development workflow is the best way to experience Claude Alchemy end-to-end. It takes you from a high-level idea through specification, task decomposition, and autonomous execution -- all with real-time visibility in the Task Manager.</p>"},{"location":"getting-started/#step-1-create-a-specification","title":"Step 1: Create a Specification","text":"<pre><code>/sdd:create-spec\n</code></pre> <p>Claude will start an adaptive interview, asking questions to understand your feature requirements. At the end, it produces a structured specification file saved to <code>specs/SPEC-&lt;name&gt;.md</code>.</p>"},{"location":"getting-started/#step-2-analyze-the-specification-optional","title":"Step 2: Analyze the Specification (Optional)","text":"<pre><code>/sdd:analyze-spec specs/SPEC-myproject.md\n</code></pre> <p>This runs a quality review on the spec, checking for completeness, ambiguities, and potential issues. It is optional but recommended for complex features.</p>"},{"location":"getting-started/#step-3-generate-tasks","title":"Step 3: Generate Tasks","text":"<pre><code>/sdd:create-tasks specs/SPEC-myproject.md\n</code></pre> <p>Claude decomposes the specification into individual task JSON files written to <code>~/.claude/tasks/</code>. Each task captures its subject, description, status, dependencies, and metadata.</p>"},{"location":"getting-started/#step-4-start-the-task-manager","title":"Step 4: Start the Task Manager","text":"<pre><code>pnpm dev:task-manager\n</code></pre> <p>Open http://localhost:3030 to see your tasks on the Kanban board. All tasks start in the Pending column.</p>"},{"location":"getting-started/#step-5-execute-tasks","title":"Step 5: Execute Tasks","text":"<pre><code>/sdd:execute-tasks\n</code></pre> <p>Claude begins autonomous execution, working through tasks in dependency order. As each task progresses, the Task Manager board updates in real time -- tasks move from Pending to In Progress to Completed.</p>"},{"location":"getting-started/#step-6-monitor-progress","title":"Step 6: Monitor Progress","text":"<p>Watch the Kanban board at http://localhost:3030 as tasks flow through the columns. The Task Manager provides:</p> <ul> <li>Live status updates as tasks transition between states</li> <li>Execution context showing the current phase and active work</li> <li>Task details accessible by clicking any task card</li> <li>Progress tracking with summary statistics at the top of the board</li> </ul> <pre><code>graph LR\n    A[\"1. /sdd:create-spec\"] --&gt; B[\"2. /sdd:analyze-spec\\n(optional)\"]\n    B --&gt; C[\"3. /sdd:create-tasks\"]\n    C --&gt; D[\"4. Start Task Manager\"]\n    D --&gt; E[\"5. /sdd:execute-tasks\"]\n    E --&gt; F[\"6. Monitor at\\nlocalhost:3030\"]</code></pre>"},{"location":"getting-started/#project-structure","title":"Project Structure","text":"<pre><code>claude-alchemy/\n\u251c\u2500\u2500 apps/\n\u2502   \u2514\u2500\u2500 task-manager/          # Next.js 16 real-time Kanban board\n\u251c\u2500\u2500 plugins/\n\u2502   \u251c\u2500\u2500 tools/                 # Developer tools plugin (13 skills, 10 agents)\n\u2502   \u2514\u2500\u2500 sdd/                   # Spec-driven development plugin (4 skills, 2 agents)\n\u251c\u2500\u2500 extensions/\n\u2502   \u2514\u2500\u2500 vscode/                # VS Code extension for plugin file validation\n\u251c\u2500\u2500 internal/\n\u2502   \u2514\u2500\u2500 docs/                  # Internal documentation and cheatsheets\n\u251c\u2500\u2500 docs/                      # MkDocs documentation site (you are here)\n\u251c\u2500\u2500 .claude-plugin/\n\u2502   \u2514\u2500\u2500 marketplace.json       # Plugin registry with versions\n\u251c\u2500\u2500 mkdocs.yml                 # Documentation configuration\n\u251c\u2500\u2500 pnpm-workspace.yaml        # Workspace definition (apps/* only)\n\u2514\u2500\u2500 package.json               # Monorepo root scripts\n</code></pre> <p>Plugin Isolation</p> <p>The plugins are not part of the pnpm workspace. They are pure markdown -- no <code>node_modules</code>, no build artifacts, no transpilation. Claude Code reads them directly as context.</p>"},{"location":"getting-started/#next-steps","title":"Next Steps","text":"<p>Now that you have the project running, explore these pages to go deeper:</p> <ul> <li>Architecture Overview -- Understand the system design and how the three subsystems communicate through the filesystem</li> <li>Task Manager -- Learn about the real-time Kanban board, its components, and the SSE-based update system</li> <li>Plugin System -- Explore skills, agents, hooks, and how the plugin architecture works</li> <li>SDD Workflow -- Deep dive into the spec-driven development lifecycle</li> <li>Development Setup -- Full development environment details for contributing to the project</li> </ul>"},{"location":"architecture/data-flow/","title":"Data Flow","text":""},{"location":"architecture/data-flow/#data-flow","title":"Data Flow","text":"<p>Claude Alchemy operates through three distinct data flow paths that converge on a shared filesystem-as-message-bus integration pattern. Each subsystem -- the SDD plugin pipeline, the Tools plugin agent orchestration, and the Task Manager real-time UI -- reads and writes to <code>~/.claude/tasks/</code> as its primary communication channel. No shared runtime code, no database, and no IPC connects these systems; the filesystem is the sole integration boundary.</p> <p>This page documents every major data flow path, the components involved, and the precise mechanism by which data moves from producer to consumer.</p> <p>For the underlying integration pattern details, see Filesystem Message Bus.</p>"},{"location":"architecture/data-flow/#overview","title":"Overview","text":"<pre><code>graph TB\n    subgraph \"SDD Plugin\"\n        CS[create-spec] --&gt; AS[analyze-spec]\n        CS --&gt; CT[create-tasks]\n        CT --&gt; ET[execute-tasks]\n    end\n\n    subgraph \"Tools Plugin\"\n        FD[feature-dev] --&gt; DA[deep-analysis]\n        DA --&gt; CA[code-architect]\n        CA --&gt; CR[code-reviewer]\n    end\n\n    subgraph \"Filesystem\"\n        SPECS[\"specs/SPEC-*.md\"]\n        TASKS[\"~/.claude/tasks/*.json\"]\n        SESSION[\".claude/sessions/__live_session__/\"]\n        POINTER[\"execution_pointer.md\"]\n    end\n\n    subgraph \"Task Manager\"\n        FW[FileWatcher] --&gt; SSE[SSE Route]\n        SSE --&gt; HOOK[useSSE Hook]\n        HOOK --&gt; TQ[TanStack Query]\n        TQ --&gt; UI[Kanban Board]\n    end\n\n    CS --&gt; SPECS\n    CT --&gt; TASKS\n    ET --&gt; SESSION\n    ET --&gt; POINTER\n    TASKS --&gt; FW\n    SESSION --&gt; FW\n    POINTER --&gt; FW</code></pre>"},{"location":"architecture/data-flow/#real-time-data-flow-task-manager","title":"Real-Time Data Flow (Task Manager)","text":"<p>The Task Manager is a Next.js application that renders a Kanban board reflecting the live state of <code>~/.claude/tasks/</code>. It uses a Server Component + Client Component hydration pattern where the server reads files for the initial render, then the client subscribes to a Server-Sent Events stream for real-time updates.</p>"},{"location":"architecture/data-flow/#full-pipeline","title":"Full Pipeline","text":"<pre><code>~/.claude/tasks/*.json\n    \u2192 Chokidar FileWatcher (polling 300ms)\n    \u2192 EventEmitter (taskEvent / executionEvent)\n    \u2192 SSE Route Handler (/api/events)\n    \u2192 EventSource in browser (useSSE hook)\n    \u2192 Dual invalidation: TanStack Query cache + router.refresh()\n    \u2192 UI re-render\n</code></pre>"},{"location":"architecture/data-flow/#sequence-diagram","title":"Sequence Diagram","text":"<pre><code>sequenceDiagram\n    participant FS as Filesystem&lt;br/&gt;~/.claude/tasks/\n    participant CK as Chokidar&lt;br/&gt;FileWatcher\n    participant EE as EventEmitter\n    participant SSE as SSE Route&lt;br/&gt;/api/events\n    participant ES as EventSource&lt;br/&gt;(Browser)\n    participant TQ as TanStack Query\n    participant SC as Server Components\n    participant UI as Kanban Board\n\n    Note over FS,UI: Initial Page Load\n    SC-&gt;&gt;FS: readdir + readFile (taskService.ts)\n    SC-&gt;&gt;UI: Pass initialTasks + initialExecutionContext as props\n\n    Note over FS,UI: Real-Time Update Path\n    FS-&gt;&gt;CK: File change detected (add/change/unlink)\n    CK-&gt;&gt;EE: emit('taskEvent', {type, taskListId, taskId, task})\n    EE-&gt;&gt;SSE: Handler receives event\n    SSE-&gt;&gt;ES: Stream: event: task:updated\\ndata: {...}\n    ES-&gt;&gt;TQ: invalidateQueries({queryKey: taskKeys.list(listId)})\n    ES-&gt;&gt;SC: router.refresh() \u2014 refetch Server Component data\n    TQ-&gt;&gt;UI: Re-render with fresh data</code></pre>"},{"location":"architecture/data-flow/#component-breakdown","title":"Component Breakdown","text":"FileWatcher (Server)SSE Route Handler (Server)useSSE Hook (Client)Task Service (Server) <p>The <code>FileWatcher</code> class in <code>src/lib/fileWatcher.ts</code> is a Chokidar-based singleton that watches the <code>~/.claude/tasks/</code> directory tree. It survives Next.js Hot Module Replacement by attaching to <code>globalThis</code>.</p> apps/task-manager/src/lib/fileWatcher.ts<pre><code>// Singleton pattern for HMR survival\nconst globalForWatcher = globalThis as unknown as {\n  fileWatcher: FileWatcher | undefined\n}\n\nexport const fileWatcher = globalForWatcher.fileWatcher ?? new FileWatcher()\n\nif (process.env.NODE_ENV !== 'production') {\n  globalForWatcher.fileWatcher = fileWatcher\n}\n</code></pre> <p>Configuration:</p> Setting Value Purpose <code>usePolling</code> <code>true</code> Required for cross-platform reliability <code>interval</code> <code>300</code> ms Balance between responsiveness and CPU usage <code>depth</code> <code>2</code> Watch <code>tasks/{listId}/*.json</code> without excessive recursion <code>ignoreInitial</code> <code>true</code> Skip events for files that exist at startup <p>Event Types Emitted:</p> Event Trigger Payload <code>taskEvent</code> <code>.json</code> file added, changed, or deleted <code>{ type: SSEEventType, taskListId, taskId, task? }</code> <code>executionEvent</code> <code>.md</code> or <code>.txt</code> file changed in a watched execution directory <code>{ type: 'execution:updated', taskListId }</code> <p>The <code>watchExecutionDir()</code> method dynamically adds execution session directories to the watcher when an SSE client connects with a <code>taskListId</code> that has an <code>execution_pointer.md</code>.</p> <p>The <code>/api/events</code> route in <code>src/app/api/events/route.ts</code> creates a <code>ReadableStream</code> and subscribes to <code>FileWatcher</code> events. It filters events by the <code>taskListId</code> query parameter.</p> apps/task-manager/src/app/api/events/route.ts<pre><code>export async function GET(request: Request) {\n  const { searchParams } = new URL(request.url)\n  const taskListId = searchParams.get('taskListId')\n\n  // Ensure file watcher is started\n  if (!fileWatcher.isStarted()) {\n    await fileWatcher.start()\n  }\n\n  // Watch execution directory for this task list\n  if (taskListId) {\n    const execDir = await getExecutionDir(taskListId)\n    if (execDir) {\n      fileWatcher.watchExecutionDir(taskListId, execDir)\n    }\n  }\n\n  // ... ReadableStream with event handlers\n}\n</code></pre> <p>SSE Event Format:</p> <pre><code>event: task:updated\ndata: {\"type\":\"task:updated\",\"taskListId\":\"claude-alchemy\",\"taskId\":\"5\",\"task\":{...}}\n\nevent: execution:updated\ndata: {\"type\":\"execution:updated\",\"taskListId\":\"claude-alchemy\"}\n</code></pre> <p>A heartbeat comment (<code>:heartbeat</code>) is sent every 30 seconds to keep the connection alive. Cleanup removes event listeners on client abort.</p> <p>The <code>useSSE</code> hook in <code>src/hooks/useSSE.ts</code> opens an <code>EventSource</code> connection to <code>/api/events</code> and triggers dual invalidation on every event.</p> apps/task-manager/src/hooks/useSSE.ts<pre><code>const handleTaskEvent = () =&gt; {\n  // Invalidate client-side cache\n  queryClient.invalidateQueries({ queryKey: taskKeys.list(taskListId) })\n  queryClient.invalidateQueries({ queryKey: taskListKeys.all })\n  // Refresh Server Component data\n  router.refresh()\n}\n\nconst handleExecutionEvent = () =&gt; {\n  queryClient.invalidateQueries({\n    queryKey: executionContextKeys.list(taskListId),\n  })\n  router.refresh()\n}\n</code></pre> <p>Listened Events: <code>task:created</code>, <code>task:updated</code>, <code>task:deleted</code>, <code>execution:updated</code></p> <p>Reconnection: On error, the EventSource closes and a new connection is attempted after a 3-second delay via a <code>reconnectKey</code> state increment.</p> <p>The <code>taskService.ts</code> module provides the read layer for Server Components. It reads JSON files from <code>~/.claude/tasks/</code> and parses them with defensive normalization.</p> apps/task-manager/src/lib/taskService.ts<pre><code>// Defensive parsing: normalize IDs, default status, coerce arrays\nfunction parseTask(content: string, filename: string): Task | null {\n  const data = JSON.parse(content)\n  data.id = String(data.id ?? basename(filename, '.json'))\n  if (!isValidTaskStatus(data.status)) data.status = 'pending'\n  data.blocks = Array.isArray(data.blocks) ? data.blocks.map(String) : []\n  data.blockedBy = Array.isArray(data.blockedBy) ? data.blockedBy.map(String) : []\n  return data as Task\n}\n</code></pre> <p>Security: <code>resolveExecutionDir()</code> guards against path traversal by ensuring the resolved execution pointer path stays under <code>$HOME</code> using <code>path.relative()</code>.</p>"},{"location":"architecture/data-flow/#dual-invalidation-strategy","title":"Dual Invalidation Strategy","text":"<p>The Task Manager uses two complementary invalidation mechanisms to ensure both Server Component and Client Component data stay synchronized:</p> Mechanism Target Purpose <code>queryClient.invalidateQueries()</code> TanStack Query cache Forces client-side data refetch on next access <code>router.refresh()</code> Next.js Server Components Re-runs server-side data fetching functions <p>This dual approach is necessary because:</p> <ol> <li>Server Components fetch initial data from the filesystem in <code>page.tsx</code> and pass it as props</li> <li>Client Components use TanStack Query with <code>initialData</code> for hydration, then manage their own cache</li> <li>Without <code>router.refresh()</code>, Server Component data would go stale after the initial render</li> <li>Without query invalidation, the TanStack Query cache would serve stale data between refetches</li> </ol>"},{"location":"architecture/data-flow/#sdd-pipeline-flow","title":"SDD Pipeline Flow","text":"<p>The Spec-Driven Development plugin implements a linear pipeline that transforms a user's idea into executed, verified code changes. Each stage produces filesystem artifacts consumed by the next stage.</p>"},{"location":"architecture/data-flow/#full-pipeline_1","title":"Full Pipeline","text":"<pre><code>User request\n    \u2192 create-spec (interview \u2192 SPEC file)\n    \u2192 analyze-spec (optional QA \u2192 analysis report)\n    \u2192 create-tasks (decompose \u2192 ~/.claude/tasks/*.json)\n    \u2192 execute-tasks (10-step orchestrator)\n        \u2192 spawns task-executor agents (4-phase workflow)\n        \u2192 shared execution_context.md\n        \u2192 execution_pointer.md\n    \u2192 Task Manager (real-time visibility)\n</code></pre>"},{"location":"architecture/data-flow/#pipeline-sequence","title":"Pipeline Sequence","text":"<pre><code>sequenceDiagram\n    participant U as User\n    participant CS as create-spec\n    participant AS as analyze-spec\n    participant CT as create-tasks\n    participant ET as execute-tasks\n    participant TE as task-executor&lt;br/&gt;(per task)\n    participant FS as Filesystem\n    participant TM as Task Manager\n\n    Note over U,TM: Stage 1: Specification\n    U-&gt;&gt;CS: /sdd:create-spec\n    CS-&gt;&gt;U: Adaptive interview (2-5 rounds)\n    CS-&gt;&gt;FS: Write specs/SPEC-{name}.md\n\n    Note over U,TM: Stage 2: Quality Analysis (Optional)\n    U-&gt;&gt;AS: /sdd:analyze-spec specs/SPEC-{name}.md\n    AS-&gt;&gt;FS: Read spec, generate analysis report\n    AS-&gt;&gt;FS: Write specs/SPEC-{name}.analysis.md\n    AS-&gt;&gt;U: Interactive issue resolution\n\n    Note over U,TM: Stage 3: Task Generation\n    U-&gt;&gt;CT: /sdd:create-tasks specs/SPEC-{name}.md\n    CT-&gt;&gt;FS: Read spec, decompose features\n    CT-&gt;&gt;FS: TaskCreate \u2192 ~/.claude/tasks/{listId}/*.json\n    FS--&gt;&gt;TM: FileWatcher detects new .json files\n\n    Note over U,TM: Stage 4: Execution\n    U-&gt;&gt;ET: /sdd:execute-tasks\n    ET-&gt;&gt;FS: Build execution plan, init session\n    ET-&gt;&gt;FS: Write .claude/sessions/__live_session__/*\n    ET-&gt;&gt;FS: Write execution_pointer.md\n    FS--&gt;&gt;TM: FileWatcher detects pointer + session files\n\n    loop For each wave\n        ET-&gt;&gt;TE: Launch parallel task-executor agents\n        TE-&gt;&gt;FS: Read execution_context.md (snapshot)\n        TE-&gt;&gt;FS: Implement, verify, update task status\n        TE-&gt;&gt;FS: Write context-task-{id}.md (learnings)\n        FS--&gt;&gt;TM: FileWatcher \u2192 SSE \u2192 UI updates\n        TE-&gt;&gt;ET: Return verification report\n        ET-&gt;&gt;FS: Merge per-task contexts \u2192 execution_context.md\n        ET-&gt;&gt;FS: Update progress.md, task_log.md\n    end\n\n    ET-&gt;&gt;FS: Archive session, write summary\n    ET-&gt;&gt;U: Display execution summary</code></pre>"},{"location":"architecture/data-flow/#stage-details","title":"Stage Details","text":"create-specanalyze-speccreate-tasksexecute-tasks <p>Input: User's feature idea (via interactive interview) Output: <code>specs/SPEC-{name}.md</code></p> <p>The skill conducts a 2-5 round adaptive interview, adjusting depth based on the user's chosen level (high-level, detailed, or full-tech). It detects recommendation triggers in user responses and offers proactive suggestions. An optional research agent can be dispatched for external information.</p> <p>Key artifacts produced:</p> Artifact Path Purpose Specification <code>specs/SPEC-{name}.md</code> Requirements with acceptance criteria, phases, dependencies <p>Input: Path to a spec file Output: Analysis report + optional spec updates</p> <p>The skill launches a <code>spec-analyzer</code> agent that evaluates the spec across four categories: inconsistencies, missing information, ambiguities, and structure issues. Severity levels (Critical, Warning, Suggestion) help prioritize fixes.</p> <p>Key artifacts produced:</p> Artifact Path Purpose Analysis report <code>specs/SPEC-{name}.analysis.md</code> Findings with severity and recommendations HTML review <code>specs/SPEC-{name}.analysis.html</code> Interactive browser-based review <p>Input: Path to a spec file Output: Claude Code native Tasks (JSON files)</p> <p>The skill reads the spec, decomposes features into atomic tasks using a layered pattern (Data Model, API/Service, Business Logic, UI, Tests), infers dependency chains via topological analysis, and creates tasks with structured acceptance criteria.</p> <p>Key data transformations:</p> <pre><code>Spec Section 5.x (Functional Requirements)\n    \u2192 Features with priorities (P0-P3)\n    \u2192 Atomic tasks with categorized acceptance criteria\n        - Functional, Edge Cases, Error Handling, Performance\n    \u2192 Dependency graph (blockedBy/blocks relationships)\n    \u2192 TaskCreate API \u2192 ~/.claude/tasks/{listId}/{taskId}.json\n</code></pre> <p>Task JSON structure written to disk:</p> <pre><code>{\n  \"id\": \"1\",\n  \"subject\": \"Create User data model\",\n  \"description\": \"...\\n\\n**Acceptance Criteria:**\\n\\n_Functional:_\\n- [ ] ...\",\n  \"status\": \"pending\",\n  \"blocks\": [\"2\", \"3\"],\n  \"blockedBy\": [],\n  \"activeForm\": \"Creating User data model\",\n  \"metadata\": {\n    \"priority\": \"critical\",\n    \"complexity\": \"S\",\n    \"source_section\": \"7.3 Data Models\",\n    \"spec_path\": \"specs/SPEC-Auth.md\",\n    \"feature_name\": \"User Authentication\",\n    \"task_uid\": \"specs/SPEC-Auth.md:user-auth:model:001\",\n    \"task_group\": \"user-authentication\"\n  }\n}\n</code></pre> <p>Input: Task list (all pending/unblocked tasks) Output: Completed tasks, session artifacts, CLAUDE.md updates</p> <p>The 10-step orchestrator builds a dependency-aware execution plan, sorts tasks into waves, and launches up to <code>max_parallel</code> (default: 5) task-executor agents simultaneously per wave.</p> <p>Session directory layout (<code>.claude/sessions/__live_session__/</code>):</p> File Purpose Updated by <code>execution_plan.md</code> Dependency-sorted plan with wave assignments Orchestrator (once) <code>execution_context.md</code> Shared learnings across tasks Orchestrator (merged after each wave) <code>task_log.md</code> Table of results: Task ID, Subject, Status, Attempts, Duration, Token Usage Orchestrator (after each agent returns) <code>progress.md</code> Real-time status: current wave, active tasks, completed tasks Orchestrator (between agent launches) <code>context-task-{id}.md</code> Per-task learnings during concurrent execution Individual task-executor agents <code>.lock</code> Concurrency guard (prevents parallel sessions) Orchestrator (create on start, archive on end) <code>tasks/</code> Archive of completed task JSONs Orchestrator (after each wave) <code>session_summary.md</code> Final execution results Orchestrator (at session end) <p>Execution pointer bridge:</p> <pre><code>~/.claude/tasks/{listId}/execution_pointer.md\n    \u2192 Contains: absolute path to .claude/sessions/__live_session__/\n    \u2192 Read by: Task Manager's taskService.ts \u2192 getExecutionDir()\n    \u2192 Enables: Task Manager to display execution artifacts\n</code></pre>"},{"location":"architecture/data-flow/#task-executor-4-phase-workflow","title":"Task-Executor 4-Phase Workflow","text":"<p>Each task-executor agent follows a strict 4-phase workflow:</p> <pre><code>flowchart LR\n    P1[\"Phase 1&lt;br/&gt;Understand\"] --&gt; P2[\"Phase 2&lt;br/&gt;Implement\"]\n    P2 --&gt; P3[\"Phase 3&lt;br/&gt;Verify\"]\n    P3 --&gt; P4[\"Phase 4&lt;br/&gt;Complete\"]\n\n    P1 --- U1[\"Read execution_context.md&lt;br/&gt;Load task via TaskGet&lt;br/&gt;Classify task type&lt;br/&gt;Parse requirements&lt;br/&gt;Explore codebase\"]\n    P2 --- U2[\"Read target files&lt;br/&gt;Follow layer order&lt;br/&gt;Match conventions&lt;br/&gt;Run mid-implementation checks\"]\n    P3 --- U3[\"Walk acceptance criteria&lt;br/&gt;Run tests + linter&lt;br/&gt;Determine PASS/PARTIAL/FAIL\"]\n    P4 --- U4[\"Update task status&lt;br/&gt;Write learnings to&lt;br/&gt;context-task-{id}.md&lt;br/&gt;Return structured report\"]</code></pre> <p>Verification results determine task status:</p> Result Condition Task Status PASS All Functional criteria pass, tests pass <code>completed</code> PARTIAL Functional passes but Edge/Error/Performance issues <code>in_progress</code> (orchestrator retries) FAIL Any Functional criterion fails or tests fail <code>in_progress</code> (orchestrator retries)"},{"location":"architecture/data-flow/#wave-based-concurrency-model","title":"Wave-Based Concurrency Model","text":"<p>The orchestrator executes tasks in dependency-ordered waves with configurable parallelism:</p> <pre><code>flowchart TB\n    subgraph \"Wave 1 (no dependencies)\"\n        T1[\"Task 1&lt;br/&gt;Data Model\"] &amp; T2[\"Task 2&lt;br/&gt;Config Setup\"] &amp; T3[\"Task 3&lt;br/&gt;Auth Types\"]\n    end\n\n    subgraph \"Wave 2 (depends on Wave 1)\"\n        T4[\"Task 4&lt;br/&gt;API Endpoints\"] &amp; T5[\"Task 5&lt;br/&gt;Service Layer\"]\n    end\n\n    subgraph \"Wave 3 (depends on Wave 2)\"\n        T6[\"Task 6&lt;br/&gt;UI Components\"] &amp; T7[\"Task 7&lt;br/&gt;Integration Tests\"]\n    end\n\n    T1 &amp; T2 --&gt; T4\n    T1 &amp; T3 --&gt; T5\n    T4 &amp; T5 --&gt; T6\n    T4 &amp; T5 --&gt; T7</code></pre> <p>Concurrency rules:</p> <ul> <li>Tasks within a wave run in parallel (up to <code>max_parallel</code> concurrent agents)</li> <li>All wave tasks must complete before the next wave starts</li> <li>Failed tasks with retries remaining are re-launched immediately within the wave</li> <li>After each wave, per-task context files are merged into <code>execution_context.md</code></li> <li>Dynamic unblocking: newly unblocked tasks are added to the next wave</li> </ul>"},{"location":"architecture/data-flow/#context-sharing-pattern","title":"Context Sharing Pattern","text":"<p>During concurrent execution, write contention on <code>execution_context.md</code> is avoided through a snapshot-and-merge pattern:</p> <pre><code>sequenceDiagram\n    participant O as Orchestrator\n    participant EC as execution_context.md\n    participant A1 as Agent 1\n    participant A2 as Agent 2\n    participant CT1 as context-task-1.md\n    participant CT2 as context-task-2.md\n\n    O-&gt;&gt;EC: Snapshot before wave\n    O-&gt;&gt;A1: Launch with snapshot reference\n    O-&gt;&gt;A2: Launch with snapshot reference\n    A1-&gt;&gt;EC: Read (shared snapshot)\n    A2-&gt;&gt;EC: Read (shared snapshot)\n    A1-&gt;&gt;CT1: Write learnings\n    A2-&gt;&gt;CT2: Write learnings\n    A1-&gt;&gt;O: Return verification report\n    A2-&gt;&gt;O: Return verification report\n    O-&gt;&gt;CT1: Read per-task context\n    O-&gt;&gt;CT2: Read per-task context\n    O-&gt;&gt;EC: Merge all per-task contexts\n    O-&gt;&gt;CT1: Delete\n    O-&gt;&gt;CT2: Delete</code></pre> <p>Sequential Mode</p> <p>When <code>max_parallel</code> is set to 1, agents write directly to <code>execution_context.md</code> instead of per-task files. The snapshot-and-merge pattern is skipped.</p>"},{"location":"architecture/data-flow/#tools-plugin-agent-orchestration","title":"Tools Plugin Agent Orchestration","text":"<p>The Tools plugin provides two variants of its deep analysis workflow: a standard Task-based approach and a team-based collaborative approach using Agent Teams.</p>"},{"location":"architecture/data-flow/#standard-deep-analysis-flow","title":"Standard Deep Analysis Flow","text":"<p>The <code>feature-dev</code> skill orchestrates a 7-phase workflow. Phase 2 (Codebase Exploration) delegates to the <code>deep-analysis</code> skill, which uses the standard Task tool for agent coordination.</p> <pre><code>sequenceDiagram\n    participant U as User\n    participant FD as feature-dev\n    participant DA as deep-analysis\n    participant E1 as code-explorer 1&lt;br/&gt;(Sonnet)\n    participant E2 as code-explorer 2&lt;br/&gt;(Sonnet)\n    participant E3 as code-explorer 3&lt;br/&gt;(Sonnet)\n    participant SY as codebase-synthesizer&lt;br/&gt;(Opus)\n    participant CA as code-architect&lt;br/&gt;(Opus)\n    participant CR as code-reviewer&lt;br/&gt;(Opus)\n\n    Note over U,CR: Phase 1: Discovery\n    U-&gt;&gt;FD: /tools:feature-dev \"add OAuth login\"\n    FD-&gt;&gt;U: Confirm understanding\n\n    Note over U,CR: Phase 2: Codebase Exploration (deep-analysis)\n    FD-&gt;&gt;DA: Load deep-analysis skill\n    par Parallel Exploration\n        DA-&gt;&gt;E1: Focus: entry points + user-facing code\n        DA-&gt;&gt;E2: Focus: data models + storage\n        DA-&gt;&gt;E3: Focus: utilities + shared infrastructure\n    end\n    E1--&gt;&gt;DA: Findings report\n    E2--&gt;&gt;DA: Findings report\n    E3--&gt;&gt;DA: Findings report\n    DA-&gt;&gt;SY: Synthesize all findings\n    SY--&gt;&gt;DA: Unified analysis\n    DA--&gt;&gt;FD: Synthesis complete\n\n    Note over U,CR: Phase 3: Clarifying Questions\n    FD-&gt;&gt;U: Resolve ambiguities\n\n    Note over U,CR: Phase 4: Architecture Design\n    par Parallel Architecture Design\n        FD-&gt;&gt;CA: Approach 1 \u2014 minimal/simple\n        FD-&gt;&gt;CA: Approach 2 \u2014 flexible/extensible\n        FD-&gt;&gt;CA: Approach 3 \u2014 match existing patterns\n    end\n    CA--&gt;&gt;FD: Implementation blueprints\n    FD-&gt;&gt;U: Compare approaches, select one\n\n    Note over U,CR: Phase 5: Implementation\n    FD-&gt;&gt;FD: Build the feature\n\n    Note over U,CR: Phase 6: Quality Review\n    par Parallel Code Review\n        FD-&gt;&gt;CR: Focus: correctness + edge cases\n        FD-&gt;&gt;CR: Focus: security + error handling\n        FD-&gt;&gt;CR: Focus: maintainability + code quality\n    end\n    CR--&gt;&gt;FD: Aggregated findings\n    FD-&gt;&gt;U: Present issues, user decides on fixes\n\n    Note over U,CR: Phase 7: Summary\n    FD-&gt;&gt;U: Document accomplishments, update CHANGELOG</code></pre> <p>Agent model tiers:</p> Agent Model Role <code>code-explorer</code> Sonnet (default) Fast, parallel codebase exploration <code>codebase-synthesizer</code> Opus Deep analysis and pattern recognition <code>code-architect</code> Opus Architecture design with trade-off analysis <code>code-reviewer</code> Opus Thorough code review with confidence scores"},{"location":"architecture/data-flow/#team-based-deep-analysis-flow","title":"Team-Based Deep Analysis Flow","text":"<p>When invoked with the <code>--teams</code> flag, <code>feature-dev</code> uses <code>teams-deep-analysis</code> instead of <code>deep-analysis</code>. This variant uses Claude's Agent Teams API (<code>TeamCreate</code>, <code>SendMessage</code>) for real-time inter-agent collaboration.</p> <pre><code>sequenceDiagram\n    participant L as Lead&lt;br/&gt;(Orchestrator)\n    participant E1 as explorer-1&lt;br/&gt;(Sonnet)\n    participant E2 as explorer-2&lt;br/&gt;(Sonnet)\n    participant E3 as explorer-3&lt;br/&gt;(Sonnet)\n    participant SY as synthesizer&lt;br/&gt;(Opus)\n    participant AN as analyst&lt;br/&gt;(Opus)\n\n    Note over L,AN: Phase 1: Team Setup\n    L-&gt;&gt;L: TeamCreate(\"deep-analysis-{timestamp}\")\n    par Spawn 5 teammates\n        L-&gt;&gt;E1: Task(team-code-explorer)\n        L-&gt;&gt;E2: Task(team-code-explorer)\n        L-&gt;&gt;E3: Task(team-code-explorer)\n        L-&gt;&gt;SY: Task(team-codebase-synthesizer)\n        L-&gt;&gt;AN: Task(team-deep-analyst)\n    end\n    L-&gt;&gt;L: TaskCreate exploration + synthesis tasks\n    L-&gt;&gt;L: TaskUpdate assign owners\n\n    Note over L,AN: Phase 2: Collaborative Exploration\n    par Explorers work + share discoveries\n        E1-&gt;&gt;E2: SendMessage(\"Found auth middleware pattern\")\n        E2-&gt;&gt;E3: SendMessage(\"DB schema uses soft deletes\")\n        E3-&gt;&gt;E1: SendMessage(\"Shared utils in /lib/common\")\n    end\n    E1--&gt;&gt;L: Task complete\n    E2--&gt;&gt;L: Task complete\n    E3--&gt;&gt;L: Task complete\n\n    Note over L,AN: Phase 3: Synthesis\n    L-&gt;&gt;SY: Assign synthesis task\n    SY-&gt;&gt;E1: SendMessage(\"Clarify: how does auth chain work?\")\n    E1-&gt;&gt;SY: SendMessage(\"Auth uses middleware \u2192 JWT \u2192 role check\")\n    SY-&gt;&gt;AN: SendMessage(\"Investigate git history for auth changes\")\n    AN-&gt;&gt;SY: SendMessage(\"Auth refactored in commit abc123, migration guide...\")\n    SY--&gt;&gt;L: Unified analysis complete\n\n    Note over L,AN: Phase 4: Cleanup\n    L-&gt;&gt;L: Collect synthesis output\n    par Shutdown all teammates\n        L-&gt;&gt;E1: SendMessage(type: shutdown_request)\n        L-&gt;&gt;E2: SendMessage(type: shutdown_request)\n        L-&gt;&gt;E3: SendMessage(type: shutdown_request)\n        L-&gt;&gt;SY: SendMessage(type: shutdown_request)\n        L-&gt;&gt;AN: SendMessage(type: shutdown_request)\n    end\n    L-&gt;&gt;L: TeamDelete</code></pre> <p>Key difference from standard analysis: The team-based variant adds two capabilities:</p> Capability Standard Team-Based Explorer collaboration None (isolated Task calls) Real-time via <code>SendMessage</code> Synthesizer follow-ups Cannot ask explorers questions Can message explorers directly On-demand deep investigation Not available Deep analyst (Opus) dispatched by synthesizer Team composition 3 explorers + 1 synthesizer 3 explorers + 1 synthesizer + 1 analyst"},{"location":"architecture/data-flow/#cross-system-integration-points","title":"Cross-System Integration Points","text":"<p>The three subsystems connect through well-defined filesystem interfaces. These are the critical integration points where data crosses system boundaries.</p>"},{"location":"architecture/data-flow/#execution-pointer-bridge","title":"Execution Pointer Bridge","text":"<p>The <code>execution_pointer.md</code> file is the primary bridge between the SDD execution pipeline and the Task Manager:</p> <pre><code>flowchart LR\n    ET[\"execute-tasks&lt;br/&gt;(SDD Plugin)\"] --&gt;|\"Writes absolute path\"| EP[\"~/.claude/tasks/{listId}/&lt;br/&gt;execution_pointer.md\"]\n    EP --&gt;|\"Read by\"| TS[\"taskService.ts&lt;br/&gt;(Task Manager)\"]\n    TS --&gt;|\"resolveExecutionDir()\"| SD[\".claude/sessions/&lt;br/&gt;__live_session__/\"]\n    SD --&gt;|\"Artifacts served to\"| UI[\"Execution Dialog&lt;br/&gt;(Browser UI)\"]</code></pre> <p>Security: The <code>resolveExecutionDir()</code> function validates that the pointer's target path stays under <code>$HOME</code>:</p> apps/task-manager/src/lib/taskService.ts<pre><code>function resolveExecutionDir(pointerContent: string): string | null {\n  const resolved = raw.startsWith('/') ? resolve(raw) : resolve(home, raw)\n  const rel = relative(home, resolved)\n  if (rel.startsWith('..') || resolve(home, rel) !== resolved) {\n    console.warn(`Execution pointer path escapes home directory: ${raw}`)\n    return null\n  }\n  return resolved\n}\n</code></pre>"},{"location":"architecture/data-flow/#task-json-as-contract","title":"Task JSON as Contract","text":"<p>The JSON files in <code>~/.claude/tasks/{listId}/</code> serve as the shared data contract between producers (SDD plugin skills) and consumers (Task Manager). Both sides agree on this schema:</p> Field Type Producer Consumer <code>id</code> <code>string</code> <code>create-tasks</code> via <code>TaskCreate</code> <code>taskService.ts</code> \u2192 <code>parseTask()</code> <code>subject</code> <code>string</code> <code>create-tasks</code> Kanban card title <code>description</code> <code>string</code> <code>create-tasks</code> (with acceptance criteria) Task detail dialog <code>status</code> <code>'pending' \\| 'in_progress' \\| 'completed'</code> <code>execute-tasks</code> via <code>TaskUpdate</code> Kanban column assignment <code>blocks</code> <code>string[]</code> <code>create-tasks</code> via <code>TaskUpdate</code> Dependency visualization <code>blockedBy</code> <code>string[]</code> <code>create-tasks</code> via <code>TaskUpdate</code> Dependency visualization <code>activeForm</code> <code>string?</code> <code>create-tasks</code> In-progress display text <code>metadata</code> <code>object?</code> <code>create-tasks</code> Priority badge, complexity tag"},{"location":"architecture/data-flow/#progressmd-real-time-bridge","title":"Progress.md Real-Time Bridge","text":"<p>The <code>progress.md</code> file provides real-time execution visibility to the Task Manager:</p> <pre><code>execute-tasks orchestrator\n    \u2192 Updates progress.md (wave status, active tasks, completed tasks)\n    \u2192 Chokidar detects .md change in watched execution directory\n    \u2192 executionEvent emitted\n    \u2192 SSE streams execution:updated event\n    \u2192 useSSE invalidates executionContextKeys\n    \u2192 useExecutionContext refetches\n    \u2192 parseProgressMd() extracts structured progress\n    \u2192 ExecutionProgressBar + ExecutionDialog re-render\n</code></pre> <p>Parsed progress structure:</p> apps/task-manager/src/types/execution.ts<pre><code>interface ExecutionProgress {\n  status: string           // \"Executing\", \"Complete\", etc.\n  wave: number             // Current wave number\n  totalWaves: number       // Total planned waves\n  maxParallel?: number     // Concurrent agent limit\n  updated: string          // ISO 8601 timestamp\n  activeTasks: ActiveTask[]      // Currently executing\n  completedTasks: CompletedTask[] // Finished this session\n}\n</code></pre>"},{"location":"architecture/data-flow/#data-flow-summary-table","title":"Data Flow Summary Table","text":"Flow Producer Artifact Consumer Mechanism Spec creation <code>create-spec</code> <code>specs/SPEC-*.md</code> <code>analyze-spec</code>, <code>create-tasks</code> File read Spec analysis <code>analyze-spec</code> <code>.analysis.md</code>, <code>.analysis.html</code> User (browser) File read Task generation <code>create-tasks</code> <code>~/.claude/tasks/{listId}/*.json</code> <code>execute-tasks</code>, Task Manager TaskCreate API, Chokidar Task status updates <code>execute-tasks</code> Task JSON <code>status</code> field Task Manager TaskUpdate API, Chokidar Execution session <code>execute-tasks</code> <code>.claude/sessions/__live_session__/*</code> Task Manager, task-executor agents File write, Chokidar Execution pointer <code>execute-tasks</code> <code>execution_pointer.md</code> Task Manager (<code>getExecutionDir</code>) File write, file read Shared context task-executor agents <code>context-task-{id}.md</code> Orchestrator (merge) File write, file read Real-time progress <code>execute-tasks</code> <code>progress.md</code> Task Manager (<code>parseProgressMd</code>) File write, Chokidar, SSE Exploration findings code-explorer agents Task tool response codebase-synthesizer In-memory (Task tool) Team collaboration team-code-explorer <code>SendMessage</code> Other team members Agent Teams API"},{"location":"architecture/filesystem-message-bus/","title":"Filesystem Message Bus","text":""},{"location":"architecture/filesystem-message-bus/#filesystem-message-bus","title":"Filesystem Message Bus","text":"<p>Claude Alchemy's three subsystems -- the SDD plugin, the Tools plugin, and the Task Manager app -- communicate through a filesystem-as-message-bus pattern. There is no shared runtime code, no database, and no IPC. Every interaction between subsystems happens through reading and writing files on disk.</p> <p>This architectural decision keeps each subsystem fully decoupled. The SDD plugin writes task JSON files and session artifacts; the Task Manager app watches those files for changes and renders them in a real-time Kanban UI. Neither subsystem imports code from the other, and neither needs to be running for the other to function.</p>"},{"location":"architecture/filesystem-message-bus/#design-rationale","title":"Design Rationale","text":"<p>Why the filesystem?</p> <p>Claude Code plugins are markdown-only with no build step and no ability to expose HTTP endpoints or import shared libraries. The filesystem is the only communication channel available that works across all three subsystems without introducing runtime coupling.</p> <p>The pattern offers several advantages:</p> <ul> <li>Zero coupling -- Producers and consumers share no code, no types, and no protocol definitions beyond file format conventions</li> <li>Crash resilience -- All state is persisted to disk the moment it is created; no in-memory state to lose</li> <li>Debuggability -- Every message is a human-readable file you can inspect with <code>cat</code> or any text editor</li> <li>Replay -- Archived sessions can be re-read at any time for post-mortem analysis</li> <li>Simplicity -- No message broker, no serialization library, no connection management</li> </ul>"},{"location":"architecture/filesystem-message-bus/#producers-and-consumers","title":"Producers and Consumers","text":"<p>Every piece of data in the system has a clear producer (writer) and one or more consumers (readers). The filesystem path and file format serve as the implicit contract between them.</p> Data Producer Consumer Format Task files (<code>{id}.json</code>) Claude Code <code>TaskCreate</code>/<code>TaskUpdate</code>, <code>create-tasks</code> skill <code>taskService.ts</code> via <code>getTasks()</code>, Task Manager UI JSON conforming to <code>Task</code> interface <code>execution_pointer.md</code> <code>execute-tasks</code> skill (Step 5.5) <code>taskService.ts</code> via <code>getExecutionDir()</code> Plain text: single absolute path <code>execution_context.md</code> <code>execute-tasks</code> + <code>task-executor</code> agents <code>taskService.ts</code> (as artifact), next <code>task-executor</code> agent Markdown with 5 sections <code>task_log.md</code> <code>execute-tasks</code> orchestrator (Step 7d) <code>taskService.ts</code> (as artifact) Markdown table <code>progress.md</code> <code>execute-tasks</code> orchestrator <code>taskService.ts</code> via <code>parseProgressMd()</code> Markdown with Status/Wave/Active Tasks <code>execution_plan.md</code> <code>execute-tasks</code> (Step 5.5) <code>taskService.ts</code> (as artifact) Markdown <code>.lock</code> file <code>execute-tasks</code> (Step 5.5) <code>execute-tasks</code> (stale detection, &gt;4h expiry) Metadata: execution ID + timestamp <code>context-task-{id}.md</code> <code>task-executor</code> agents (concurrent mode) <code>execute-tasks</code> orchestrator (wave merge) Markdown with learnings <pre><code>graph TD\n    subgraph Producers\n        CT[\"create-tasks skill\"]\n        ET[\"execute-tasks skill\"]\n        TE[\"task-executor agents\"]\n    end\n\n    subgraph \"Filesystem (Message Bus)\"\n        TF[\"~/.claude/tasks/{listId}/{id}.json\"]\n        EP[\"~/.claude/tasks/{listId}/execution_pointer.md\"]\n        EC[\".claude/sessions/__live_session__/execution_context.md\"]\n        TL[\".claude/sessions/__live_session__/task_log.md\"]\n        PM[\".claude/sessions/__live_session__/progress.md\"]\n        XP[\".claude/sessions/__live_session__/execution_plan.md\"]\n        LK[\".claude/sessions/__live_session__/.lock\"]\n    end\n\n    subgraph Consumers\n        TS[\"taskService.ts\"]\n        FW[\"fileWatcher.ts (Chokidar)\"]\n        SSE[\"SSE route (/api/events)\"]\n        UI[\"Task Manager UI\"]\n        TE2[\"Next task-executor agent\"]\n    end\n\n    CT --&gt;|write JSON| TF\n    ET --&gt;|write JSON via TaskUpdate| TF\n    ET --&gt;|write pointer| EP\n    ET --&gt;|initialize / merge| EC\n    ET --&gt;|append rows| TL\n    ET --&gt;|update status| PM\n    ET --&gt;|save plan| XP\n    ET --&gt;|create / remove| LK\n    TE --&gt;|append learnings| EC\n\n    TF --&gt;|read| TS\n    EP --&gt;|resolve path| TS\n    EC --&gt;|read artifacts| TS\n    TL --&gt;|read artifacts| TS\n    PM --&gt;|parse progress| TS\n    XP --&gt;|read artifacts| TS\n    EC --&gt;|read prior learnings| TE2\n\n    TF --&gt;|detect change| FW\n    PM --&gt;|detect change| FW\n    EC --&gt;|detect change| FW\n    FW --&gt;|emit event| SSE\n    SSE --&gt;|stream| UI</code></pre>"},{"location":"architecture/filesystem-message-bus/#file-paths-and-locations","title":"File Paths and Locations","text":"<p>The bus uses two distinct directories on disk, each serving a different purpose.</p>"},{"location":"architecture/filesystem-message-bus/#task-directory-claudetaskslistid","title":"Task Directory (<code>~/.claude/tasks/{listId}/</code>)","text":"<p>This directory lives under the user's home directory and is managed by Claude Code's native task system. The <code>listId</code> is configured via <code>CLAUDE_CODE_TASK_LIST_ID</code> in <code>.claude/settings.json</code>.</p> <pre><code>~/.claude/tasks/{listId}/\n\u251c\u2500\u2500 1.json                    # Task file\n\u251c\u2500\u2500 2.json                    # Task file\n\u251c\u2500\u2500 3.json                    # Task file\n\u2514\u2500\u2500 execution_pointer.md      # Absolute path to live session dir\n</code></pre>"},{"location":"architecture/filesystem-message-bus/#session-directory-claudesessions","title":"Session Directory (<code>.claude/sessions/</code>)","text":"<p>This directory lives within the project repository (relative to the working directory) and holds execution artifacts for the current and past sessions.</p> <pre><code>.claude/sessions/\n\u251c\u2500\u2500 __live_session__/          # Current active session\n\u2502   \u251c\u2500\u2500 .lock                  # Concurrency guard\n\u2502   \u251c\u2500\u2500 execution_plan.md      # Saved execution plan\n\u2502   \u251c\u2500\u2500 execution_context.md   # Shared learnings across tasks\n\u2502   \u251c\u2500\u2500 task_log.md            # Row-per-task result log\n\u2502   \u251c\u2500\u2500 progress.md            # Real-time wave/task progress\n\u2502   \u251c\u2500\u2500 context-task-5.md      # Per-task context (concurrent mode, temporary)\n\u2502   \u251c\u2500\u2500 context-task-6.md      # Per-task context (concurrent mode, temporary)\n\u2502   \u2514\u2500\u2500 tasks/                 # Archived completed task JSONs\n\u2502       \u251c\u2500\u2500 1.json\n\u2502       \u2514\u2500\u2500 2.json\n\u251c\u2500\u2500 user-auth-20260205-143022/ # Archived session\n\u2502   \u251c\u2500\u2500 execution_plan.md\n\u2502   \u251c\u2500\u2500 execution_context.md\n\u2502   \u251c\u2500\u2500 task_log.md\n\u2502   \u251c\u2500\u2500 progress.md\n\u2502   \u251c\u2500\u2500 session_summary.md\n\u2502   \u251c\u2500\u2500 .lock\n\u2502   \u2514\u2500\u2500 tasks/\n\u2514\u2500\u2500 interrupted-20260206-091500/  # Recovered interrupted session\n    \u2514\u2500\u2500 ...\n</code></pre> <p>The execution pointer bridges two directories</p> <p>The <code>execution_pointer.md</code> file in the task directory contains the absolute path to <code>.claude/sessions/__live_session__/</code>. This is the only cross-reference between the two directory trees. The Task Manager reads the pointer to locate session artifacts.</p>"},{"location":"architecture/filesystem-message-bus/#file-format-contracts","title":"File Format Contracts","text":"<p>Each file type has a specific format that producers must write and consumers must parse. These formats are the implicit API contracts of the message bus.</p>"},{"location":"architecture/filesystem-message-bus/#task-json-idjson","title":"Task JSON (<code>{id}.json</code>)","text":"~/.claude/tasks/claude-alchemy/1.json<pre><code>{\n  \"id\": \"1\",\n  \"subject\": \"Implement user authentication middleware\",\n  \"description\": \"Add JWT-based auth middleware to the API layer...\",\n  \"status\": \"pending\",\n  \"blocks\": [\"3\", \"4\"],\n  \"blockedBy\": [],\n  \"activeForm\": \"\",\n  \"metadata\": {\n    \"priority\": \"high\",\n    \"complexity\": \"M\",\n    \"task_group\": \"user-auth\",\n    \"spec_path\": \"SPEC-user-auth.md\",\n    \"source_section\": \"Section 2\"\n  }\n}\n</code></pre> <p>The consumer (<code>parseTask()</code> in <code>taskService.ts</code>) applies defensive normalization:</p> <ul> <li>Coerces <code>id</code> to string (accepts number or string)</li> <li>Defaults <code>status</code> to <code>\"pending\"</code> if invalid</li> <li>Ensures <code>blocks</code> and <code>blockedBy</code> are string arrays</li> <li>Defaults <code>description</code> to empty string</li> <li>Rejects tasks with no <code>subject</code> field</li> </ul> <p>Valid <code>status</code> values: <code>pending</code>, <code>in_progress</code>, <code>completed</code></p>"},{"location":"architecture/filesystem-message-bus/#execution-pointer-execution_pointermd","title":"Execution Pointer (<code>execution_pointer.md</code>)","text":"~/.claude/tasks/claude-alchemy/execution_pointer.md<pre><code>/Users/sequenzia/dev/repos/my-project/.claude/sessions/__live_session__/\n</code></pre> <p>A single line containing the absolute path to the live session directory. The consumer (<code>resolveExecutionDir()</code> in <code>taskService.ts</code>) validates the path:</p> <ol> <li>Resolves the path to an absolute form</li> <li>Checks that the resolved path is under <code>$HOME</code> using <code>path.relative()</code></li> <li>Returns <code>null</code> if the path escapes the home directory (path traversal guard)</li> </ol>"},{"location":"architecture/filesystem-message-bus/#execution-context-execution_contextmd","title":"Execution Context (<code>execution_context.md</code>)","text":".claude/sessions/__live_session__/execution_context.md<pre><code># Execution Context\n\n## Project Patterns\n- TypeScript strict mode throughout\n- Barrel exports in each module directory\n- Error handling at service boundaries only\n\n## Key Decisions\n- Chose Zod over io-ts for runtime validation\n- API routes use middleware chain pattern\n\n## Known Issues\n- Test runner requires Node 18+ for fetch support\n\n## File Map\n- src/lib/auth.ts \u2014 JWT verification and token refresh\n- src/middleware.ts \u2014 Express middleware chain\n\n## Task History\n### Task [1]: Implement auth middleware - PASS\n- Files modified: src/middleware.ts, src/lib/auth.ts\n- Key learnings: Project uses barrel exports, middleware chain pattern\n- Issues encountered: None\n</code></pre> <p>The five sections are populated incrementally. Task executors read the context at the start of their run and append to it after completion. In concurrent mode, agents write to separate <code>context-task-{id}.md</code> files, and the orchestrator merges them into the shared context after each wave.</p>"},{"location":"architecture/filesystem-message-bus/#task-log-task_logmd","title":"Task Log (<code>task_log.md</code>)","text":".claude/sessions/__live_session__/task_log.md<pre><code># Task Execution Log\n\n| Task ID | Subject | Status | Attempts | Duration | Token Usage |\n|---------|---------|--------|----------|----------|-------------|\n| 1 | Implement auth middleware | PASS | 1/3 | 2m 34s | N/A |\n| 2 | Add rate limiting | PARTIAL | 2/3 | 5m 12s | N/A |\n| 3 | Create user endpoints | FAIL | 3/3 | 8m 45s | N/A |\n</code></pre> <p>Each row is appended as a task completes or exhausts retries. The orchestrator writes this file; task executors do not.</p>"},{"location":"architecture/filesystem-message-bus/#progress-progressmd","title":"Progress (<code>progress.md</code>)","text":".claude/sessions/__live_session__/progress.md<pre><code># Execution Progress\nStatus: Executing\nWave: 2 of 4\nMax Parallel: 5\nUpdated: 2026-02-05T14:35:22Z\n\n## Active Tasks\n- [5] Add input validation \u2014 Phase 2 \u2014 Implementing\n- [6] Create error handler \u2014 Phase 3 \u2014 Verifying\n\n## Completed This Session\n- [1] Implement auth middleware \u2014 PASS (2m 34s)\n- [2] Add rate limiting \u2014 PASS (3m 12s)\n- [3] Create user endpoints \u2014 PASS (4m 5s)\n- [4] Set up database schema \u2014 PASS (1m 48s)\n</code></pre> <p>The Task Manager parses this file via <code>parseProgressMd()</code> in <code>taskService.ts</code>, which extracts:</p> <ul> <li><code>status</code> -- Current execution state (Initializing, Executing, Complete)</li> <li><code>wave</code> / <code>totalWaves</code> -- Current and total wave numbers</li> <li><code>maxParallel</code> -- Configured concurrency limit</li> <li><code>activeTasks</code> -- Array of <code>{ id, subject, phase }</code> from the Active Tasks section</li> <li><code>completedTasks</code> -- Array of <code>{ id, subject, result }</code> from the Completed section</li> </ul>"},{"location":"architecture/filesystem-message-bus/#lock-file-lock","title":"Lock File (<code>.lock</code>)","text":".claude/sessions/__live_session__/.lock<pre><code>task_execution_id: user-auth-20260205-143022\ntimestamp: 2026-02-05T14:30:22Z\npid: orchestrator\n</code></pre> <p>The lock prevents concurrent execution sessions. The <code>execute-tasks</code> skill checks for this file before starting:</p> <ul> <li>Lock exists, age &lt; 4 hours -- Prompts the user to force-start or cancel</li> <li>Lock exists, age &gt;= 4 hours -- Treats as stale, deletes it, and proceeds</li> <li>No lock -- Proceeds normally</li> </ul> <p>The lock is archived along with all other session files when the session completes.</p>"},{"location":"architecture/filesystem-message-bus/#session-lifecycle","title":"Session Lifecycle","text":"<p>A session progresses through four distinct phases. Each transition is driven by filesystem operations.</p> <pre><code>stateDiagram-v2\n    [*] --&gt; Creation: execute-tasks Step 5.5\n    Creation --&gt; Active: User confirms plan\n    Active --&gt; Active: task-executor reads/writes artifacts\n    Active --&gt; Archival: All tasks processed (Step 8)\n    Archival --&gt; [*]: Session complete\n\n    Active --&gt; Interrupted: Process killed / crash\n    Interrupted --&gt; Recovery: Next execute-tasks invocation\n    Recovery --&gt; Creation: Stale files archived, tasks reset</code></pre>"},{"location":"architecture/filesystem-message-bus/#1-creation","title":"1. Creation","text":"<p>Triggered by <code>execute-tasks</code> Step 5.5 after the user confirms the execution plan.</p> <ol> <li>Stale session check -- If <code>__live_session__/</code> contains leftover files, archive them to <code>interrupted-{YYYYMMDD-HHMMSS}/</code></li> <li>Task recovery -- Any tasks left as <code>in_progress</code> from the interrupted session are reset to <code>pending</code></li> <li>Concurrency guard -- Check for <code>.lock</code> file; enforce the single-session invariant</li> <li>Session ID generation (three-tier):<ul> <li><code>--task-group</code> flag provided: <code>{task_group}-{YYYYMMDD}-{HHMMSS}</code></li> <li>All open tasks share a <code>task_group</code>: <code>{task_group}-{YYYYMMDD}-{HHMMSS}</code></li> <li>Fallback: <code>exec-session-{YYYYMMDD}-{HHMMSS}</code></li> </ul> </li> <li>File creation -- <code>.lock</code>, <code>execution_plan.md</code>, <code>execution_context.md</code> (template), <code>task_log.md</code> (headers), <code>progress.md</code> (initial status), <code>tasks/</code> directory</li> <li>Pointer creation -- <code>execution_pointer.md</code> written to <code>~/.claude/tasks/{listId}/</code> with the absolute path to <code>__live_session__/</code></li> </ol>"},{"location":"architecture/filesystem-message-bus/#2-active-execution","title":"2. Active Execution","text":"<p>The session is active while the orchestrator runs the execution loop (Step 7).</p> <ul> <li>Orchestrator writes: <code>task_log.md</code> (append per task), <code>progress.md</code> (update per wave/task), task JSON archives to <code>tasks/</code></li> <li>Task executors read: <code>execution_context.md</code> (prior learnings), skill references</li> <li>Task executors write: <code>context-task-{id}.md</code> (concurrent mode) or <code>execution_context.md</code> (sequential mode)</li> <li>Orchestrator merges: After each wave, <code>context-task-{id}.md</code> files are merged into <code>execution_context.md</code> and deleted</li> <li>Task Manager watches: Chokidar detects changes to JSON files and session artifacts, triggers SSE events</li> </ul>"},{"location":"architecture/filesystem-message-bus/#3-archival","title":"3. Archival","text":"<p>When all tasks have been processed (Step 8):</p> <ol> <li><code>progress.md</code> is updated with final status (<code>Status: Complete</code>)</li> <li><code>session_summary.md</code> is written to <code>__live_session__/</code></li> <li>All contents of <code>__live_session__/</code> (including <code>.lock</code>) are moved to <code>.claude/sessions/{task_execution_id}/</code></li> <li><code>__live_session__/</code> is left as an empty directory</li> <li><code>execution_pointer.md</code> continues to point to <code>__live_session__/</code> (now empty)</li> </ol>"},{"location":"architecture/filesystem-message-bus/#4-interrupted-recovery","title":"4. Interrupted Recovery","text":"<p>If a session is interrupted (process killed, crash, timeout), the next invocation of <code>execute-tasks</code> detects the stale state:</p> <ol> <li>Finds files remaining in <code>__live_session__/</code></li> <li>Archives them to <code>.claude/sessions/interrupted-{YYYYMMDD-HHMMSS}/</code></li> <li>Cross-references <code>task_log.md</code> (if present) to identify tasks from the interrupted session</li> <li>Resets those <code>in_progress</code> tasks back to <code>pending</code> via <code>TaskUpdate</code></li> <li>Proceeds with a fresh session</li> </ol> <p>No automatic re-execution</p> <p>Interrupted recovery resets task statuses but does not automatically re-execute tasks. The user must invoke <code>execute-tasks</code> again to resume work. Tasks that were completed before the interruption remain completed.</p>"},{"location":"architecture/filesystem-message-bus/#real-time-data-flow","title":"Real-Time Data Flow","text":"<p>The Task Manager app observes filesystem changes in real time through a Chokidar-to-SSE pipeline. This is how the Kanban board updates automatically as the <code>execute-tasks</code> skill runs.</p> <pre><code>sequenceDiagram\n    participant ET as execute-tasks skill\n    participant FS as Filesystem\n    participant CK as Chokidar (300ms poll)\n    participant SSE as SSE Route (/api/events)\n    participant Hook as useSSE Hook\n    participant TQ as TanStack Query\n    participant SC as Server Components\n    participant UI as Browser UI\n\n    ET-&gt;&gt;FS: Write {id}.json (TaskUpdate)\n    ET-&gt;&gt;FS: Update progress.md\n    CK-&gt;&gt;FS: Detect change (polling)\n    CK-&gt;&gt;SSE: Emit task:updated / execution:updated\n    SSE-&gt;&gt;Hook: Stream SSE event\n    Hook-&gt;&gt;TQ: Invalidate query cache\n    Hook-&gt;&gt;SC: router.refresh()\n    TQ-&gt;&gt;UI: Re-render with fresh data\n    SC-&gt;&gt;UI: Re-render server component</code></pre>"},{"location":"architecture/filesystem-message-bus/#chokidar-configuration","title":"Chokidar Configuration","text":"<p>The <code>FileWatcher</code> singleton in <code>fileWatcher.ts</code> is configured with:</p> <ul> <li>Polling interval: 300ms (<code>usePolling: true, interval: 300</code>)</li> <li>Watch depth: 2 levels from <code>~/.claude/tasks/</code></li> <li>Ignore initial: Does not fire events for files that exist when the watcher starts</li> <li>HMR safety: Uses <code>globalThis</code> singleton pattern to survive Next.js hot module replacement</li> </ul> apps/task-manager/src/lib/fileWatcher.ts<pre><code>this.watcher = watch(this.basePath, {\n  persistent: true,\n  ignoreInitial: true,\n  usePolling: true,\n  interval: 300,\n  depth: 2,\n})\n</code></pre> <p>The watcher emits two event types:</p> Event Trigger Payload <code>taskEvent</code> <code>.json</code> file added, changed, or deleted <code>{ type, taskListId, taskId, task? }</code> <code>executionEvent</code> <code>.md</code> or <code>.txt</code> file changed in a watched execution dir <code>{ type: 'execution:updated', taskListId }</code> <p>Execution directory watching is dynamic</p> <p>The watcher does not automatically monitor session directories. When the SSE route receives a connection for a <code>taskListId</code>, it calls <code>fileWatcher.watchExecutionDir(taskListId, execDir)</code> to start watching the resolved execution directory. This avoids watching directories that do not exist yet.</p>"},{"location":"architecture/filesystem-message-bus/#sse-event-types","title":"SSE Event Types","text":"<p>The SSE route at <code>/api/events</code> streams four event types to the browser:</p> SSE Event Source Consumer Action <code>task:created</code> New <code>.json</code> file detected Invalidate task list + task queries, refresh server components <code>task:updated</code> <code>.json</code> file content changed Invalidate task list + task queries, refresh server components <code>task:deleted</code> <code>.json</code> file removed Invalidate task list + task queries, refresh server components <code>execution:updated</code> <code>.md</code> file changed in session dir Invalidate execution context query, refresh server components"},{"location":"architecture/filesystem-message-bus/#dual-invalidation-strategy","title":"Dual Invalidation Strategy","text":"<p>When the <code>useSSE</code> hook receives an event, it performs two invalidation actions:</p> <ol> <li>TanStack Query cache invalidation -- Forces client-side queries to refetch fresh data from the API routes, which in turn read the filesystem</li> <li><code>router.refresh()</code> -- Forces Next.js to re-run Server Components, which fetch data directly from <code>taskService.ts</code></li> </ol> <p>This dual approach ensures both the client-side cache and the server-rendered HTML stay in sync with the filesystem.</p>"},{"location":"architecture/filesystem-message-bus/#security-boundaries","title":"Security Boundaries","text":"<p>The filesystem bus requires security checks at the consumer side to prevent path traversal and data corruption.</p> Check Location Mechanism Execution pointer path traversal <code>resolveExecutionDir()</code> in <code>taskService.ts</code> Uses <code>path.relative(home, resolved)</code> to ensure the pointer target stays under <code>$HOME</code>. Returns <code>null</code> if the relative path starts with <code>..</code> List ID validation API routes Rejects <code>listId</code> values containing <code>..</code> or <code>/</code> Task JSON normalization <code>parseTask()</code> in <code>taskService.ts</code> Defaults invalid status to <code>pending</code>, coerces arrays, requires <code>subject</code> field, converts <code>id</code> to string Concurrency guard <code>.lock</code> file in <code>__live_session__/</code> Prevents multiple <code>execute-tasks</code> sessions from writing to the same session directory simultaneously <p>Trust boundary</p> <p>The filesystem bus trusts that producers write well-formed data. There is no schema validation layer between the plugin (producer) and the Task Manager (consumer) beyond the defensive parsing in <code>parseTask()</code>. If a plugin writes malformed JSON, the task is silently skipped.</p>"},{"location":"architecture/filesystem-message-bus/#cross-task-knowledge-sharing","title":"Cross-Task Knowledge Sharing","text":"<p>The <code>execution_context.md</code> file is the mechanism that allows later tasks to learn from earlier ones. It acts as a persistent, append-only knowledge base within a session.</p> <pre><code>graph LR\n    subgraph \"Wave 1\"\n        T1[\"Task 1&lt;br/&gt;executor\"]\n        T2[\"Task 2&lt;br/&gt;executor\"]\n    end\n\n    subgraph \"Wave 2\"\n        T3[\"Task 3&lt;br/&gt;executor\"]\n        T4[\"Task 4&lt;br/&gt;executor\"]\n    end\n\n    CTX[\"execution_context.md\"]\n    C1[\"context-task-1.md\"]\n    C2[\"context-task-2.md\"]\n    C3[\"context-task-3.md\"]\n    C4[\"context-task-4.md\"]\n\n    CTX --&gt;|snapshot before wave 1| T1\n    CTX --&gt;|snapshot before wave 1| T2\n    T1 --&gt;|write learnings| C1\n    T2 --&gt;|write learnings| C2\n    C1 --&gt;|merge after wave 1| CTX\n    C2 --&gt;|merge after wave 1| CTX\n    CTX --&gt;|snapshot before wave 2| T3\n    CTX --&gt;|snapshot before wave 2| T4\n    T3 --&gt;|write learnings| C3\n    T4 --&gt;|write learnings| C4\n    C3 --&gt;|merge after wave 2| CTX\n    C4 --&gt;|merge after wave 2| CTX</code></pre> <p>Concurrency safety: Within a wave, agents write to isolated <code>context-task-{id}.md</code> files rather than the shared <code>execution_context.md</code>. The orchestrator merges these files between waves. This prevents write contention when multiple agents run in parallel.</p> <p>Cross-session inheritance: When a new execution session starts, the orchestrator looks for the most recent archived session in <code>.claude/sessions/</code> and merges its learnings (Project Patterns, Key Decisions, Known Issues, File Map) into the fresh context. Task History entries are compacted after 10 entries to prevent unbounded growth.</p>"},{"location":"architecture/filesystem-message-bus/#tradeoffs-and-limitations","title":"Tradeoffs and Limitations","text":"<p>When does this pattern break down?</p> <p>Latency: The 300ms Chokidar polling interval introduces up to 300ms of latency between a file write and the UI update. This is acceptable for a development tool but would not suit sub-second real-time requirements.</p> <p>No guaranteed delivery: If the Task Manager is not running when a file changes, the change is not queued. The next page load will read the current state from disk, so data is never lost, but transient events (such as a task briefly entering <code>in_progress</code> before completing) may not be observed.</p> <p>No schema enforcement: The file formats are conventions, not enforced schemas. A producer writing an unexpected field or missing a required one will cause silent failures or fallback behavior in the consumer.</p> <p>Single-machine only: The filesystem bus assumes all subsystems run on the same machine and can access the same paths. There is no support for distributed or networked operation.</p> <p>Concurrency limitations: Only one <code>execute-tasks</code> session can run at a time per project, enforced by the <code>.lock</code> file. Multiple Task Manager instances can read simultaneously (read-only consumers), but multiple concurrent writers would require additional coordination.</p>"},{"location":"architecture/filesystem-message-bus/#related-pages","title":"Related Pages","text":"<ul> <li>Task Manager Architecture -- How the Next.js app consumes filesystem events</li> <li>SDD Plugin -- The plugin that produces most of the bus traffic</li> </ul>"},{"location":"architecture/overview/","title":"Overview","text":""},{"location":"architecture/overview/#architecture-overview","title":"Architecture Overview","text":"<p>Claude Alchemy is a pnpm monorepo consisting of three subsystems that communicate exclusively through the filesystem. There is no shared runtime code, no database, and no IPC mechanism -- the filesystem itself serves as the message bus between components.</p> <p>This page provides a high-level tour of the monorepo structure, the relationships between subsystems, and the key design decisions that shape the project.</p>"},{"location":"architecture/overview/#system-architecture","title":"System Architecture","text":"<pre><code>graph TB\n    subgraph Monorepo[\"Claude Alchemy Monorepo\"]\n        subgraph Plugins[\"Claude Code Plugins (markdown-only, no build step)\"]\n            Tools[\"claude-alchemy-tools v0.2.2\\n10 agents \u00b7 13 skills\"]\n            SDD[\"claude-alchemy-sdd v0.2.6\\n2 agents \u00b7 4 skills\"]\n        end\n\n        subgraph Apps[\"pnpm Workspace (apps/*)\"]\n            TM[\"Task Manager\\nNext.js 16.1.4 \u00b7 port 3030\"]\n        end\n\n        subgraph Extensions[\"Editor Extensions (npm, separate)\"]\n            VSCode[\"VS Code Extension\\nPlugin file schema validation\"]\n        end\n    end\n\n    subgraph FS[\"Filesystem (message bus)\"]\n        Tasks[\"~/.claude/tasks/\\nTask JSON files\"]\n        Sessions[\".claude/sessions/\\nExecution artifacts\"]\n        Pointer[\"execution_pointer.md\\nSession path reference\"]\n    end\n\n    SDD -- \"writes tasks\" --&gt; Tasks\n    SDD -- \"writes execution artifacts\" --&gt; Sessions\n    SDD -- \"writes pointer\" --&gt; Pointer\n    TM -- \"reads tasks\" --&gt; Tasks\n    TM -- \"reads artifacts via pointer\" --&gt; Pointer\n    TM -- \"watches for changes\" --&gt; Tasks\n    Tools -- \"analyzes &amp; documents\" --&gt; Monorepo\n    VSCode -- \"validates\" --&gt; Plugins</code></pre>"},{"location":"architecture/overview/#monorepo-structure","title":"Monorepo Structure","text":"<pre><code>claude-alchemy/\n\u251c\u2500\u2500 apps/\n\u2502   \u2514\u2500\u2500 task-manager/          # Next.js 16.1.4 app (pnpm workspace member)\n\u251c\u2500\u2500 plugins/\n\u2502   \u251c\u2500\u2500 tools/                 # Developer tools plugin (markdown-only)\n\u2502   \u2514\u2500\u2500 sdd/                   # Spec-driven development plugin (markdown-only)\n\u251c\u2500\u2500 extensions/\n\u2502   \u2514\u2500\u2500 vscode/                # VS Code extension (npm, separate)\n\u251c\u2500\u2500 internal/\n\u2502   \u2514\u2500\u2500 docs/                  # Internal documentation and cheatsheets\n\u251c\u2500\u2500 pnpm-workspace.yaml        # Only includes apps/*\n\u251c\u2500\u2500 .claude-plugin/\n\u2502   \u2514\u2500\u2500 marketplace.json       # Plugin registry with versions\n\u2514\u2500\u2500 CLAUDE.md                  # Project conventions for Claude Code\n</code></pre> <p>Workspace Boundaries</p> <p>The <code>pnpm-workspace.yaml</code> file only includes <code>apps/*</code>. Plugins are pure markdown with no <code>package.json</code> and no build step -- they are excluded from the pnpm workspace entirely. The VS Code extension manages its own dependencies with npm.</p>"},{"location":"architecture/overview/#the-three-subsystems","title":"The Three Subsystems","text":""},{"location":"architecture/overview/#1-task-manager-appstask-manager","title":"1. Task Manager (<code>apps/task-manager/</code>)","text":"<p>A Next.js 16.1.4 web application that provides a real-time Kanban board for visualizing and monitoring Claude Code task execution. It runs on port 3030 and is the only subsystem with a runtime build step.</p> Layer Technology Framework Next.js 16.1.4 (App Router) UI React 19.2.3, Tailwind CSS v4, shadcn/ui (Radix primitives) State TanStack Query v5.90.20 Real-time Chokidar 5 (filesystem watching), Server-Sent Events Language TypeScript 5 <p>Key responsibilities:</p> <ul> <li>Read task JSON files from <code>~/.claude/tasks/</code> and display them in a three-column Kanban board (Pending, In Progress, Completed)</li> <li>Watch the filesystem for changes and push real-time updates to the browser via SSE</li> <li>Display execution progress, artifacts, and session context from the SDD plugin's execution sessions</li> <li>Provide search, filtering, task list selection, and dark/light theme switching</li> </ul> <p>The Task Manager never writes to the filesystem. It is a read-only consumer of data produced by the plugins.</p>"},{"location":"architecture/overview/#2-developer-tools-plugin-pluginstools","title":"2. Developer Tools Plugin (<code>plugins/tools/</code>)","text":"<p>The <code>claude-alchemy-tools</code> plugin (v0.2.2) provides general-purpose development skills and agents for Claude Code. It covers feature development workflows, codebase analysis, documentation management, Git operations, and release automation.</p> Component Count Examples Agents 10 <code>code-explorer</code>, <code>code-architect</code>, <code>code-reviewer</code>, <code>codebase-synthesizer</code>, <code>docs-writer</code>, <code>researcher</code> User-invocable skills 7 <code>feature-dev</code>, <code>codebase-analysis</code>, <code>docs-manager</code>, <code>git-commit</code>, <code>release</code>, <code>bump-plugin-version</code>, <code>teams-deep-analysis</code> Supporting skills 6 <code>architecture-patterns</code>, <code>language-patterns</code>, <code>project-conventions</code>, <code>code-quality</code>, <code>changelog-format</code>, <code>deep-analysis</code> <p>Skills are invoked with the <code>/tools:</code> prefix (e.g., <code>/tools:feature-dev</code>, <code>/tools:git-commit</code>). Each skill is defined as a <code>SKILL.md</code> file with YAML frontmatter specifying metadata, allowed tools, and arguments.</p>"},{"location":"architecture/overview/#3-sdd-plugin-pluginssdd","title":"3. SDD Plugin (<code>plugins/sdd/</code>)","text":"<p>The <code>claude-alchemy-sdd</code> plugin (v0.2.6) implements a Spec-Driven Development workflow. It handles the full lifecycle from specification creation through task decomposition to autonomous, wave-based parallel execution.</p> Component Count Examples Agents 2 <code>task-executor</code>, <code>spec-analyzer</code> Skills 4 <code>create-spec</code>, <code>analyze-spec</code>, <code>create-tasks</code>, <code>execute-tasks</code> <p>Skills are invoked with the <code>/sdd:</code> prefix (e.g., <code>/sdd:create-spec</code>, <code>/sdd:execute-tasks</code>). The <code>execute-tasks</code> skill is the most complex component in the system -- it orchestrates wave-based parallel task execution with dependency resolution, retry logic, shared execution context, and session management.</p> <p>SDD Workflow</p> <p>The typical SDD workflow is: <code>/sdd:create-spec</code> to define requirements, <code>/sdd:analyze-spec</code> to review the spec, <code>/sdd:create-tasks</code> to decompose it into tasks, then <code>/sdd:execute-tasks</code> to run them autonomously.</p>"},{"location":"architecture/overview/#4-vs-code-extension-extensionsvscode","title":"4. VS Code Extension (<code>extensions/vscode/</code>)","text":"<p>A development-time editor extension that validates Claude Code plugin files (SKILL.md and agent markdown files) against their expected schemas. It provides:</p> <ul> <li>Diagnostics: Real-time validation of YAML frontmatter in skill and agent files</li> <li>Completions: Autocomplete for frontmatter keys and enum values</li> <li>Hover info: Documentation tooltips for frontmatter fields</li> </ul> <p>The extension is not part of the pnpm workspace and manages its own dependencies via npm.</p>"},{"location":"architecture/overview/#filesystem-as-message-bus","title":"Filesystem as Message Bus","text":"<p>The defining architectural pattern of Claude Alchemy is the use of the filesystem as the sole communication channel between subsystems. No subsystem imports code from another, calls an API on another, or shares a database.</p> <pre><code>sequenceDiagram\n    participant User\n    participant SDD as SDD Plugin\n    participant FS as Filesystem\n    participant Chokidar as Chokidar Watcher\n    participant SSE as SSE Endpoint\n    participant Browser as Task Manager UI\n\n    User-&gt;&gt;SDD: /sdd:execute-tasks\n    SDD-&gt;&gt;FS: Write task JSON files to ~/.claude/tasks/\n    SDD-&gt;&gt;FS: Write execution_pointer.md\n    SDD-&gt;&gt;FS: Write session artifacts to .claude/sessions/\n\n    Chokidar--&gt;&gt;FS: Detects file changes (300ms polling)\n    Chokidar-&gt;&gt;SSE: Emits taskEvent / executionEvent\n    SSE-&gt;&gt;Browser: Streams SSE events\n    Browser-&gt;&gt;Browser: Invalidates TanStack Query cache\n    Browser-&gt;&gt;Browser: Calls router.refresh()</code></pre> <p>For a deep dive into this pattern, see Filesystem Message Bus.</p>"},{"location":"architecture/overview/#what-gets-written-where","title":"What Gets Written Where","text":"Path Writer Reader Contents <code>~/.claude/tasks/{listId}/*.json</code> SDD plugin (<code>create-tasks</code>, <code>execute-tasks</code>) Task Manager (<code>taskService.ts</code>) Individual task definitions (id, subject, status, dependencies) <code>~/.claude/tasks/{listId}/execution_pointer.md</code> SDD plugin (<code>execute-tasks</code>) Task Manager (<code>taskService.ts</code>) Absolute path to the active <code>__live_session__/</code> directory <code>.claude/sessions/__live_session__/</code> SDD plugin (<code>execute-tasks</code>) Task Manager (via pointer) <code>execution_context.md</code>, <code>task_log.md</code>, <code>progress.md</code>, <code>execution_plan.md</code>, <code>.lock</code> <code>.claude/sessions/{session-id}/</code> SDD plugin (session archive) Task Manager (via pointer) Archived session artifacts after execution completes <p>Path Security</p> <p>The Task Manager's <code>resolveExecutionDir()</code> function guards against path traversal attacks. It uses <code>path.relative()</code> to verify that any execution pointer target stays within the user's home directory. Pointers that resolve outside <code>$HOME</code> are rejected.</p>"},{"location":"architecture/overview/#real-time-data-flow","title":"Real-Time Data Flow","text":"<p>The Task Manager achieves real-time updates through a three-layer pipeline:</p> <pre><code>~/.claude/tasks/*.json \u2192 Chokidar \u2192 SSE route \u2192 useSSE hook \u2192 TanStack Query invalidation \u2192 UI\n</code></pre> <ol> <li> <p>Chokidar singleton watches <code>~/.claude/tasks/</code> with 300ms polling interval. A <code>globalThis</code> singleton pattern prevents duplicate watchers during Next.js HMR in development.</p> </li> <li> <p>SSE route (<code>/api/events</code>) creates a <code>ReadableStream</code> per client connection. It subscribes to the file watcher's <code>taskEvent</code> and <code>executionEvent</code> emitters, filtering events by <code>taskListId</code>. A heartbeat keeps connections alive.</p> </li> <li> <p><code>useSSE</code> hook on the client opens an <code>EventSource</code> connection and listens for <code>task:created</code>, <code>task:updated</code>, <code>task:deleted</code>, and <code>execution:updated</code> events. Each event triggers dual invalidation: TanStack Query cache invalidation plus <code>router.refresh()</code> to update Server Component data.</p> </li> </ol> <p>For the complete data flow details, see Data Flow.</p>"},{"location":"architecture/overview/#plugin-architecture","title":"Plugin Architecture","text":"<p>Both plugins follow the same structural conventions:</p> <pre><code>plugins/{name}/\n\u251c\u2500\u2500 agents/\n\u2502   \u2514\u2500\u2500 {agent-name}.md        # Agent definitions (kebab-case)\n\u251c\u2500\u2500 skills/\n\u2502   \u2514\u2500\u2500 {skill-name}/\n\u2502       \u251c\u2500\u2500 SKILL.md            # Skill definition with YAML frontmatter\n\u2502       \u2514\u2500\u2500 references/         # Reference materials loaded at runtime\n\u251c\u2500\u2500 hooks/                      # Optional: PreToolUse/PostToolUse hooks\n\u2514\u2500\u2500 README.md\n</code></pre>"},{"location":"architecture/overview/#skills-and-agents","title":"Skills and Agents","text":"<p>Skills are the user-facing entry points. Each <code>SKILL.md</code> file contains:</p> <ul> <li>YAML frontmatter with metadata (<code>name</code>, <code>description</code>, <code>user-invocable</code>, <code>allowed-tools</code>, <code>arguments</code>)</li> <li>Markdown body with instructions, workflow phases, and behavioral guidelines</li> </ul> <p>Agents are sub-processes launched by skills via Claude Code's <code>Task</code> tool. They run with a specified model tier:</p> Model Tier Used For <code>opus</code> Complex reasoning: architecture design, code review, codebase synthesis, documentation writing <code>sonnet</code> Exploration and analysis: code exploration, pattern detection <code>haiku</code> Mechanical tasks: git commits, version bumping, changelog formatting <code>inherit</code> Uses the parent's model: research, feature development orchestration"},{"location":"architecture/overview/#hooks","title":"Hooks","text":"<p>The SDD plugin includes a <code>PreToolUse</code> hook (<code>auto-approve-session.sh</code>) that auto-approves file operations targeting execution session directories. This enables the <code>execute-tasks</code> skill to run autonomously without prompting the user for permission on every session file write.</p> <p>Hook Scope</p> <p>The auto-approve hook only applies to paths matching <code>~/.claude/tasks/*/execution_pointer.md</code> and <code>*/.claude/sessions/*</code>. All other file operations follow the normal Claude Code permission flow.</p>"},{"location":"architecture/overview/#tech-stack-summary","title":"Tech Stack Summary","text":"Category Technology Version Runtime Node.js &gt;= 18 Package Manager pnpm &gt;= 8 Framework Next.js 16.1.4 UI Library React 19.2.3 Type System TypeScript 5 Server State TanStack Query 5.90.20 Styling Tailwind CSS 4 Component Library shadcn/ui Radix primitives File Watching Chokidar 5 Theme next-themes SSR-safe dark/light mode"},{"location":"architecture/overview/#design-decisions","title":"Design Decisions","text":""},{"location":"architecture/overview/#why-filesystem-as-message-bus","title":"Why Filesystem as Message Bus?","text":"<p>Claude Code plugins run as markdown instructions -- they have no build step, no runtime, and no way to call APIs or import shared code. The filesystem is the only communication channel available to them. Rather than fighting this constraint, Claude Alchemy embraces it: tasks are JSON files, execution state is markdown, and the web app watches for changes with Chokidar.</p> <p>This constraint produces several benefits:</p> <ul> <li>Inspectability: Every piece of state is a human-readable file you can <code>cat</code> or open in an editor</li> <li>Resilience: Interrupted sessions leave files on disk that can be recovered</li> <li>Simplicity: No message broker, no database migrations, no connection pooling</li> <li>Debuggability: <code>ls</code> and <code>cat</code> are your debugging tools</li> </ul>"},{"location":"architecture/overview/#why-markdown-only-plugins","title":"Why Markdown-Only Plugins?","text":"<p>Claude Code plugins are loaded as context at the start of a conversation. They need no compilation, no bundling, and no runtime dependencies. Making them pure markdown means:</p> <ul> <li>Zero build step for plugin development</li> <li>Skills and agents can be edited and tested immediately</li> <li>Reference materials are loaded alongside instructions at runtime</li> <li>The VS Code extension provides schema validation as a development aid</li> </ul>"},{"location":"architecture/overview/#why-server-sent-events-over-websockets","title":"Why Server-Sent Events Over WebSockets?","text":"<p>SSE is a simpler protocol that fits the unidirectional data flow: file changes flow from the filesystem to the browser, never the other way. The Task Manager is read-only, so there is no need for bidirectional communication. SSE also works natively with Next.js route handlers without additional infrastructure.</p>"},{"location":"architecture/overview/#related-pages","title":"Related Pages","text":"<ul> <li>Filesystem Message Bus -- Deep dive into the filesystem communication pattern</li> <li>Data Flow -- Complete data flow from file changes to UI updates</li> </ul>"},{"location":"development/contributing/","title":"Contributing","text":""},{"location":"development/contributing/#contributing-guide","title":"Contributing Guide","text":"<p>This guide covers everything you need to contribute to Claude Alchemy, whether you are working on the Task Manager app, adding skills and agents to the plugins, or extending the VS Code extension. For initial environment setup, see the Development Setup page.</p>"},{"location":"development/contributing/#quick-start","title":"Quick Start","text":"<pre><code># 1. Clone the repository\ngit clone git@github.com:sequenzia/claude-alchemy.git\ncd claude-alchemy\n\n# 2. Install dependencies (workspace packages only)\npnpm install\n\n# 3. Start the Task Manager dev server\npnpm dev:task-manager\n</code></pre> <p>The Task Manager will be available at http://localhost:3030.</p> <p>Plugins require no installation</p> <p>The two Claude Code plugins (<code>plugins/tools/</code> and <code>plugins/sdd/</code>) are markdown-only and have no build step. Changes to plugin files take effect on the next Claude Code session \u2014 no restart of the dev server is needed.</p>"},{"location":"development/contributing/#project-areas","title":"Project Areas","text":"<p>Claude Alchemy has four distinct areas of contribution. Each has different tooling, conventions, and workflows.</p>"},{"location":"development/contributing/#task-manager","title":"Task Manager","text":"Detail Value Location <code>apps/task-manager/</code> Stack Next.js 16, React 19, TypeScript, TanStack Query v5, Tailwind CSS v4, shadcn/ui Build <code>pnpm build:task-manager</code> Dev server <code>pnpm dev:task-manager</code> (port 3030) Lint <code>pnpm lint</code> <p>The Task Manager is a Next.js App Router application. Its key directories are:</p> <pre><code>apps/task-manager/src/\n\u251c\u2500\u2500 app/            # Server Components, route handlers, layouts\n\u251c\u2500\u2500 components/     # Client Components (KanbanBoard, TaskDetail, etc.)\n\u2502   \u2514\u2500\u2500 ui/         # shadcn/ui primitives (do not edit manually)\n\u251c\u2500\u2500 hooks/          # TanStack Query hooks, SSE connection (useSSE)\n\u251c\u2500\u2500 lib/            # Core services: taskService.ts, fileWatcher.ts, api.ts\n\u2514\u2500\u2500 types/          # TypeScript type definitions: task.ts, execution.ts\n</code></pre> <p>Server vs. Client Components</p> <p>Server Components in <code>app/</code> fetch data from the filesystem and pass it as <code>initialData</code> to Client Components in <code>components/</code>. Client Components manage interactivity and real-time updates via TanStack Query and SSE. If you are adding a new feature, decide early which layer it belongs in.</p>"},{"location":"development/contributing/#tools-plugin","title":"Tools Plugin","text":"Detail Value Location <code>plugins/tools/</code> Invoke <code>/tools:{skill-name}</code> Format Markdown-only, no build step Current 13 skills, 10 agents (v0.2.2) <p>Skills include <code>codebase-analysis</code>, <code>deep-analysis</code>, <code>feature-dev</code>, <code>git-commit</code>, <code>docs-manager</code>, <code>release</code>, and more. Agents include <code>code-explorer</code>, <code>code-architect</code>, <code>code-reviewer</code>, <code>codebase-synthesizer</code>, and <code>researcher</code>.</p>"},{"location":"development/contributing/#sdd-plugin","title":"SDD Plugin","text":"Detail Value Location <code>plugins/sdd/</code> Invoke <code>/sdd:{skill-name}</code> Format Markdown-only, no build step Current 4 skills, 2 agents (v0.2.6) <p>The SDD (Spec-Driven Development) plugin provides the <code>create-spec</code>, <code>analyze-spec</code>, <code>create-tasks</code>, and <code>execute-tasks</code> workflow. It also includes a PreToolUse hook for autonomous session file operations.</p>"},{"location":"development/contributing/#vs-code-extension","title":"VS Code Extension","text":"Detail Value Location <code>extensions/vscode/</code> Stack TypeScript, esbuild Install <code>cd extensions/vscode &amp;&amp; npm install</code> Build <code>npm run build</code> Package <code>npm run package</code> (produces <code>.vsix</code>) <p>Separate Package Manager</p> <p>The VS Code extension uses npm, not pnpm. It is a standalone project and is not part of the pnpm workspace.</p>"},{"location":"development/contributing/#git-workflow","title":"Git Workflow","text":""},{"location":"development/contributing/#conventional-commits","title":"Conventional Commits","text":"<p>All commits follow the Conventional Commits specification:</p> <pre><code>type(scope): description\n</code></pre> <p>Types:</p> Type When to use <code>feat</code> New feature or capability <code>fix</code> Bug fix <code>docs</code> Documentation-only change <code>style</code> Formatting, whitespace (no logic change) <code>refactor</code> Code restructure with no behavior change <code>test</code> Adding or updating tests <code>chore</code> Maintenance, dependency bumps, releases <p>Scopes correspond to the subsystem being changed:</p> <ul> <li><code>tools</code> \u2014 the claude-alchemy-tools plugin</li> <li><code>sdd</code> \u2014 the claude-alchemy-sdd plugin</li> <li><code>task-manager</code> \u2014 the Next.js application</li> <li><code>vscode</code> \u2014 the VS Code extension</li> <li><code>release</code> \u2014 version bumps and release automation</li> </ul> <p>Examples:</p> <pre><code>feat(task-manager): add search filtering to Kanban board\nfix(sdd): handle stale lock expiry after 4-hour timeout\ndocs(tools): update skill reference table\nrefactor(task-manager): extract SSE reconnection logic into useSSE\nchore(release): bump claude-alchemy-tools to v0.2.2\n</code></pre>"},{"location":"development/contributing/#commit-best-practices","title":"Commit Best Practices","text":"<ol> <li>Keep commits atomic \u2014 each commit represents a single logical change</li> <li>Explain why, not what \u2014 the diff shows what changed; the message should explain intent</li> <li>Split cross-subsystem changes \u2014 if a feature touches the plugin and the Task Manager, consider separate commits when each is independently meaningful</li> </ol> <p>Good vs. Bad Commit Messages</p> <pre><code># Good \u2014 explains the motivation\nfeat(sdd): add wave-based concurrent task execution\n\n# Bad \u2014 restates the diff\nfeat(sdd): add new function runWave and update execute-tasks SKILL.md\n</code></pre>"},{"location":"development/contributing/#adding-a-new-skill","title":"Adding a New Skill","text":"<p>Skills are the primary way to extend Claude Code plugin functionality. Each skill is a <code>SKILL.md</code> file with YAML frontmatter that defines metadata and runtime constraints.</p>"},{"location":"development/contributing/#step-1-create-the-skill-file","title":"Step 1: Create the Skill File","text":"<p>Create a new directory and skill file:</p> <pre><code>plugins/{plugin}/skills/{skill-name}/SKILL.md\n</code></pre> <p>For example, to add a <code>lint-fix</code> skill to the tools plugin:</p> <pre><code>plugins/tools/skills/lint-fix/SKILL.md\n</code></pre>"},{"location":"development/contributing/#step-2-write-yaml-frontmatter","title":"Step 2: Write YAML Frontmatter","text":"<p>Every skill requires a YAML frontmatter block at the top of the file:</p> plugins/tools/skills/lint-fix/SKILL.md<pre><code>---\nname: lint-fix\ndescription: Automatically fix linting errors in the current project. Use when the user asks to fix lint issues or code style problems.\nmodel: sonnet\nuser-invocable: true\ndisable-model-invocation: false\nallowed-tools: Bash, Read, Edit, Glob, Grep\nargument-hint: \"[file or directory to lint]\"\n---\n\n# Lint Fix\n\nYour skill instructions go here...\n</code></pre> <p>Frontmatter fields:</p> Field Required Description <code>name</code> Yes Skill identifier, used in <code>/tools:{name}</code> invocation <code>description</code> Yes Tells Claude when to auto-invoke this skill <code>model</code> Yes Model tier: <code>sonnet</code>, <code>opus</code>, <code>haiku</code>, or <code>inherit</code> <code>user-invocable</code> Yes Whether users can call it directly via slash command <code>disable-model-invocation</code> No Set <code>true</code> to prevent Claude from auto-selecting this skill <code>allowed-tools</code> No Comma-separated list of tools the skill can use <code>argument-hint</code> No Placeholder text shown in the slash command menu"},{"location":"development/contributing/#step-3-add-reference-materials-optional","title":"Step 3: Add Reference Materials (Optional)","text":"<p>If your skill needs supporting documentation, add markdown files under a <code>references/</code> subdirectory:</p> <pre><code>plugins/tools/skills/lint-fix/\n\u251c\u2500\u2500 SKILL.md\n\u2514\u2500\u2500 references/\n    \u2514\u2500\u2500 eslint-rules.md\n</code></pre> <p>Reference materials are loaded at runtime and made available to the skill as context.</p>"},{"location":"development/contributing/#step-4-test-the-skill","title":"Step 4: Test the Skill","text":"<p>Invoke the skill from a Claude Code session:</p> <pre><code>/tools:lint-fix\n</code></pre> <p>Iterating on Skills</p> <p>Claude Code reads plugin files at the start of each session. If you modify a skill mid-session, start a new Claude Code session to pick up the changes.</p>"},{"location":"development/contributing/#adding-a-new-agent","title":"Adding a New Agent","text":"<p>Agents are subagent definitions that skills orchestrate via the Task tool. Each agent is a single markdown file with YAML frontmatter.</p>"},{"location":"development/contributing/#step-1-create-the-agent-file","title":"Step 1: Create the Agent File","text":"<p>Create a new file in the plugin's <code>agents/</code> directory using kebab-case naming:</p> <pre><code>plugins/{plugin}/agents/{agent-name}.md\n</code></pre> <p>For example:</p> <pre><code>plugins/tools/agents/test-writer.md\n</code></pre>"},{"location":"development/contributing/#step-2-write-the-agent-definition","title":"Step 2: Write the Agent Definition","text":"plugins/tools/agents/test-writer.md<pre><code>---\ndescription: Writes unit and integration tests based on implementation code and testing patterns\ntools:\n  - Read\n  - Glob\n  - Grep\n  - Bash\n  - Edit\n  - Write\nmodel: sonnet\nskills:\n  - project-conventions\n  - language-patterns\n---\n\n# Test Writer Agent\n\nYou are a testing specialist. Your job is to write comprehensive tests\nfor the provided implementation code.\n\n## Your Mission\n\nGiven source files and a testing strategy, you will:\n1. Analyze the implementation to identify testable behavior\n2. Write tests following the project's established patterns\n3. Verify tests pass before reporting completion\n\n...\n</code></pre> <p>Frontmatter fields:</p> Field Required Description <code>description</code> Yes What this agent does (used by skills when selecting agents) <code>tools</code> Yes List of tools the agent can use <code>model</code> Yes Model tier for this agent <code>skills</code> No Skills this agent has access to"},{"location":"development/contributing/#step-3-choose-the-right-model-tier","title":"Step 3: Choose the Right Model Tier","text":"<p>Select a model tier based on the agent's task complexity:</p> Tier Use Case Examples Haiku Simple, well-defined tasks <code>git-commit</code>, <code>bump-plugin-version</code> Sonnet Exploration, code reading, pattern matching <code>code-explorer</code>, <code>researcher</code> Opus Synthesis, architecture, complex decision-making <code>codebase-synthesizer</code>, <code>code-architect</code> <p>The <code>inherit</code> Model</p> <p>Setting <code>model: inherit</code> causes the agent or skill to use the calling skill's model. This is useful for reference skills like <code>changelog-format</code> that should run at whatever tier invoked them.</p>"},{"location":"development/contributing/#step-4-wire-it-up","title":"Step 4: Wire It Up","text":"<p>Agents become available to skills via the Task tool. In the orchestrating skill, reference the agent by its <code>subagent_type</code>:</p> <pre><code>Use the Task tool with subagent_type: \"test-writer\" to delegate test creation.\n</code></pre>"},{"location":"development/contributing/#modifying-the-task-manager","title":"Modifying the Task Manager","text":""},{"location":"development/contributing/#architecture-at-a-glance","title":"Architecture at a Glance","text":"<pre><code>graph TD\n    FS[\"~/.claude/tasks/*.json\"] --&gt;|Chokidar watches| FW[\"FileWatcher (singleton)\"]\n    FW --&gt;|emits events| SSE[\"SSE Route (/api/events)\"]\n    SSE --&gt;|streams to browser| Hook[\"useSSE hook\"]\n    Hook --&gt;|invalidates| TQ[\"TanStack Query cache\"]\n    Hook --&gt;|refreshes| SC[\"Server Components\"]\n    SC --&gt;|initialData| CC[\"Client Components\"]\n    TQ --&gt;|provides data| CC</code></pre>"},{"location":"development/contributing/#key-files","title":"Key Files","text":"File Role <code>src/lib/taskService.ts</code> Server-side: reads task JSON from filesystem, parses defensively <code>src/lib/fileWatcher.ts</code> Chokidar singleton (survives HMR via <code>globalThis</code>) <code>src/app/api/events/route.ts</code> SSE endpoint, streams filtered filesystem events <code>src/hooks/useSSE.ts</code> Client-side SSE connection, dual invalidation (TanStack Query + router.refresh) <code>src/hooks/useTasks.ts</code> TanStack Query hook with query key factory <code>src/types/task.ts</code> Task, TaskStatus, TaskMetadata type definitions <code>src/types/execution.ts</code> ExecutionContext type definitions"},{"location":"development/contributing/#adding-a-new-feature","title":"Adding a New Feature","text":"<ol> <li>Define types in <code>src/types/</code> if new data shapes are needed</li> <li>Add server-side logic in <code>src/lib/</code> (data fetching, parsing)</li> <li>Create or update route handlers in <code>src/app/api/</code> if a new endpoint is needed</li> <li>Build the Server Component in <code>src/app/</code> to fetch and pass data</li> <li>Build the Client Component in <code>src/components/</code> for interactivity</li> <li>Add a TanStack Query hook in <code>src/hooks/</code> with a query key factory</li> <li>Wire up SSE invalidation in <code>useSSE.ts</code> if real-time updates are needed</li> </ol>"},{"location":"development/contributing/#conventions-to-follow","title":"Conventions to Follow","text":"<ul> <li>Use the <code>@/*</code> path alias for all imports (maps to <code>./src/*</code>)</li> <li>Server Components are the default; add <code>'use client'</code> only when state or interactivity is needed</li> <li>shadcn/ui components in <code>src/components/ui/</code> are generated and should not be manually edited</li> <li>Follow the existing defensive parsing pattern when reading external data (see Conventions)</li> <li>Guard against path traversal when resolving file paths from external input (see Conventions)</li> </ul>"},{"location":"development/contributing/#code-style","title":"Code Style","text":""},{"location":"development/contributing/#general-rules","title":"General Rules","text":"<ul> <li>TypeScript strict mode is enforced across the project</li> <li>Self-documenting code \u2014 use clear naming; add comments only when the \"why\" is not obvious</li> <li>Small, focused functions \u2014 prefer single-responsibility over do-everything helpers</li> <li>Delete dead code rather than commenting it out</li> </ul>"},{"location":"development/contributing/#naming-conventions","title":"Naming Conventions","text":"Context Style Example Functions, variables, hooks <code>camelCase</code> <code>parseTask</code>, <code>useTasks</code>, <code>listId</code> React components, classes <code>PascalCase</code> <code>KanbanBoard</code>, <code>FileWatcher</code> TypeScript types and interfaces <code>PascalCase</code> <code>TaskStatus</code>, <code>ExecutionContext</code> Plugin files (skills, agents) <code>kebab-case</code> <code>code-explorer.md</code>, <code>SKILL.md</code> App file names (components) <code>PascalCase</code> <code>TaskDetail.tsx</code>, <code>Providers.tsx</code> Directories <code>kebab-case</code> <code>task-manager</code>, <code>create-spec</code> Constants <code>UPPER_SNAKE_CASE</code> <code>TASKS_DIR</code>, <code>SSE_RETRY_DELAY</code>"},{"location":"development/contributing/#typescript","title":"TypeScript","text":"<ul> <li>Use <code>type</code> for unions and aliases, <code>interface</code> for object shapes</li> <li>Export types that cross module boundaries; keep internal types unexported</li> <li>Define domain types in dedicated files under <code>src/types/</code></li> </ul> <p>For the full set of patterns and conventions, see the Conventions page.</p>"},{"location":"development/contributing/#versioning-and-releases","title":"Versioning and Releases","text":""},{"location":"development/contributing/#plugin-versions","title":"Plugin Versions","text":"<p>Plugin versions are tracked in two locations that must stay in sync:</p> <ol> <li><code>plugins/{name}/.claude-plugin/plugin.json</code> \u2014 the plugin's own manifest</li> <li><code>.claude-plugin/marketplace.json</code> \u2014 the root-level plugin registry</li> </ol> <p>Always Update Both Files</p> <p>Forgetting to update one of these files will cause version mismatches. Use the built-in <code>/tools:bump-plugin-version</code> skill to automate this.</p> <p>To bump a plugin version from a Claude Code session:</p> <pre><code>/tools:bump-plugin-version\n</code></pre> <p>The skill will discover available plugins, prompt for the bump level (patch, minor, major), and update both manifest files.</p>"},{"location":"development/contributing/#changelog","title":"Changelog","text":"<p>Each plugin maintains a <code>CHANGELOG.md</code> following the Keep a Changelog format:</p> <ul> <li>Reverse chronological order (newest first)</li> <li>Each version gets its own section with an ISO date</li> <li>Changes grouped by category: Added, Changed, Deprecated, Removed, Fixed, Security</li> <li>An <code>[Unreleased]</code> section at the top collects in-progress changes</li> </ul> CHANGELOG.md<pre><code># Changelog\n\n## [Unreleased]\n\n### Added\n- New lint-fix skill for automated code style corrections\n\n## [0.2.2] - 2025-02-08\n\n### Changed\n- Restructured docs-manager skill to support dual-mode documentation\n\n### Fixed\n- Corrected model tier assignment for team agents\n</code></pre>"},{"location":"development/contributing/#contribution-checklist","title":"Contribution Checklist","text":"<p>Before submitting your changes, verify:</p> <ul> <li>[ ] Code follows the project's naming conventions</li> <li>[ ] TypeScript compiles without errors (<code>pnpm build:task-manager</code> for app changes)</li> <li>[ ] Linting passes (<code>pnpm lint</code>)</li> <li>[ ] Commit messages follow Conventional Commits format</li> <li>[ ] New skills have complete YAML frontmatter with all required fields</li> <li>[ ] New agents specify the correct model tier for their complexity level</li> <li>[ ] Plugin version bumps are reflected in both <code>plugin.json</code> and <code>marketplace.json</code></li> <li>[ ] CHANGELOG.md is updated for user-facing changes</li> </ul>"},{"location":"development/contributing/#further-reading","title":"Further Reading","text":"<ul> <li>Development Setup \u2014 installation, build commands, troubleshooting</li> <li>Conventions \u2014 code patterns, naming rules, versioning details</li> <li>Architecture Overview \u2014 system design and component relationships</li> <li>Tools Plugin \u2014 full skill and agent reference</li> <li>SDD Plugin \u2014 spec-driven development workflow</li> </ul>"},{"location":"development/conventions/","title":"Conventions","text":""},{"location":"development/conventions/#development-conventions","title":"Development Conventions","text":"<p>This page documents the coding conventions, naming rules, and established patterns used throughout Claude Alchemy. Following these conventions keeps the codebase consistent across its three subsystems \u2014 two Claude Code plugins and a Next.js Task Manager app.</p>"},{"location":"development/conventions/#git-conventions","title":"Git Conventions","text":""},{"location":"development/conventions/#conventional-commits","title":"Conventional Commits","text":"<p>All commit messages follow the Conventional Commits specification:</p> <pre><code>type(scope): description\n</code></pre> <p>Commit types:</p> Type Purpose Example <code>feat</code> New feature <code>feat(sdd): add interactive HTML review</code> <code>fix</code> Bug fix <code>fix(sdd): prevent card collapse on textarea click</code> <code>docs</code> Documentation only <code>docs(tools): update skill reference table</code> <code>style</code> Formatting, whitespace (no logic change) <code>style(task-manager): fix lint warnings</code> <code>refactor</code> Code restructure with no behavior change <code>refactor(tools): extract deep-analysis skill</code> <code>test</code> Adding or updating tests <code>test(task-manager): add parseTask edge cases</code> <code>chore</code> Maintenance, dependency bumps, releases <code>chore(release): bump claude-alchemy-tools to v0.2.2</code> <p>Scopes correspond to the subsystem being changed:</p> <ul> <li><code>tools</code> \u2014 the claude-alchemy-tools plugin</li> <li><code>sdd</code> \u2014 the claude-alchemy-sdd plugin</li> <li><code>task-manager</code> \u2014 the Next.js application</li> <li><code>release</code> \u2014 version bumps and release automation</li> <li><code>schemas</code> \u2014 plugin schema validation</li> <li><code>vscode</code> \u2014 VS Code extension</li> </ul> <p>Writing Good Commit Messages</p> <p>Focus on why the change was made, not a mechanical description of what changed. The diff already shows what; the message should explain intent.</p> <pre><code># Good \u2014 explains why\nfeat(sdd): add wave-based concurrent task execution\n\n# Bad \u2014 restates the diff\nfeat(sdd): add new function runWave and update execute-tasks SKILL.md\n</code></pre>"},{"location":"development/conventions/#atomic-commits","title":"Atomic Commits","text":"<p>Each commit should represent a single logical change. If a feature touches the plugin and the Task Manager, consider whether the changes can be split into separate, independently meaningful commits.</p>"},{"location":"development/conventions/#plugin-conventions","title":"Plugin Conventions","text":""},{"location":"development/conventions/#naming","title":"Naming","text":"<p>Plugin packages follow the pattern <code>claude-alchemy-{category}</code>:</p> Plugin Directory Description <code>claude-alchemy-tools</code> <code>plugins/tools/</code> Developer tools, Git workflows, analysis <code>claude-alchemy-sdd</code> <code>plugins/sdd/</code> Spec-driven development workflow"},{"location":"development/conventions/#file-structure","title":"File Structure","text":"<p>Plugins are markdown-only with no build step and are not part of the pnpm workspace. Each plugin follows this layout:</p> <pre><code>plugins/{name}/\n\u251c\u2500\u2500 .claude-plugin/\n\u2502   \u2514\u2500\u2500 plugin.json          # Package metadata and version\n\u251c\u2500\u2500 agents/\n\u2502   \u2514\u2500\u2500 {kebab-case-name}.md # Agent definitions\n\u251c\u2500\u2500 skills/\n\u2502   \u2514\u2500\u2500 {skill-name}/\n\u2502       \u251c\u2500\u2500 SKILL.md          # Skill definition with YAML frontmatter\n\u2502       \u2514\u2500\u2500 references/       # Supporting materials loaded at runtime\n\u2502           \u2514\u2500\u2500 *.md\n\u2514\u2500\u2500 hooks/                    # Optional PreToolUse/PostToolUse hooks\n    \u2514\u2500\u2500 *.sh\n</code></pre>"},{"location":"development/conventions/#skill-files","title":"Skill Files","text":"<p>Skills are <code>SKILL.md</code> files with YAML frontmatter that defines metadata and constraints:</p> plugins/tools/skills/git-commit/SKILL.md<pre><code>---\nname: git-commit\ndescription: Commit staged changes with conventional commit message.\nmodel: haiku\nuser-invocable: true\ndisable-model-invocation: false\nallowed-tools: Bash, AskUserQuestion\n---\n\n# Git Commit\n\nCreate a commit with a conventional commit message...\n</code></pre> <p>Key frontmatter fields:</p> Field Purpose <code>name</code> Skill identifier, used in <code>/tools:{name}</code> invocation <code>description</code> When Claude should auto-invoke this skill <code>model</code> Model tier: <code>sonnet</code>, <code>opus</code>, <code>haiku</code>, or <code>inherit</code> <code>user-invocable</code> Whether users can call it directly via slash command <code>disable-model-invocation</code> Prevents Claude from auto-selecting this skill <code>allowed-tools</code> Restricts which tools the skill can use"},{"location":"development/conventions/#agent-files","title":"Agent Files","text":"<p>Agents are <code>{kebab-case-name}.md</code> files with YAML frontmatter:</p> plugins/tools/agents/code-explorer.md<pre><code>---\ndescription: Explores codebases to find relevant files and map architecture\ntools:\n  - Read\n  - Glob\n  - Grep\n  - Bash\nmodel: sonnet\nskills:\n  - project-conventions\n  - language-patterns\n---\n\n# Code Explorer Agent\n\nYou are a code exploration specialist...\n</code></pre>"},{"location":"development/conventions/#model-tiering","title":"Model Tiering","text":"<p>Skills and agents are assigned to model tiers based on task complexity:</p> Tier Use Case Examples Haiku Simple, well-defined tasks <code>git-commit</code>, <code>bump-plugin-version</code> Sonnet Exploration, code reading, pattern matching <code>code-explorer</code>, <code>researcher</code> Opus Synthesis, architecture, complex decision-making <code>codebase-synthesizer</code>, <code>code-architect</code> <code>inherit</code> Uses the calling skill's model <code>changelog-format</code> (reference skill)"},{"location":"development/conventions/#skill-invocation","title":"Skill Invocation","text":"<p>Users invoke skills with a slash-command prefix matching the plugin name:</p> <pre><code>/tools:git-commit\n/tools:codebase-analysis\n/sdd:create-spec\n/sdd:execute-tasks\n</code></pre>"},{"location":"development/conventions/#code-patterns","title":"Code Patterns","text":""},{"location":"development/conventions/#filesystem-as-message-bus","title":"Filesystem-as-Message-Bus","text":"<p>All cross-system communication happens through file reads and writes. There is no shared runtime code, no database, and no IPC mechanism between the three subsystems.</p> <pre><code>graph LR\n    SDD[\"SDD Plugin\"] -- \"writes JSON\" --&gt; FS[\"~/.claude/tasks/\"]\n    SDD -- \"writes artifacts\" --&gt; Sessions[\".claude/sessions/\"]\n    FS -- \"Chokidar watches\" --&gt; TM[\"Task Manager\"]\n    Sessions -- \"pointer resolves\" --&gt; TM</code></pre> <p>Why Filesystem?</p> <p>Claude Code plugins run as markdown instructions inside the Claude agent \u2014 they have no persistent runtime. The filesystem is the only shared state available across plugin executions and the Task Manager app.</p> <p>For a deeper explanation, see the Filesystem Message Bus architecture page.</p>"},{"location":"development/conventions/#defensive-parsing","title":"Defensive Parsing","text":"<p>Server-side code that reads external data (task JSON files written by plugins) must handle missing or malformed fields gracefully. The canonical example is <code>parseTask()</code> in <code>taskService.ts</code>:</p> apps/task-manager/src/lib/taskService.ts<pre><code>function parseTask(content: string, filename: string): Task | null {\n  try {\n    const data = JSON.parse(content)\n\n    // Coerce id to string, fall back to filename\n    if (typeof data.id !== 'string' &amp;&amp; typeof data.id !== 'number') {\n      data.id = basename(filename, '.json')\n    } else {\n      data.id = String(data.id)\n    }\n\n    // Normalize invalid status to 'pending'\n    if (!isValidTaskStatus(data.status)) {\n      data.status = 'pending'\n    }\n\n    // Ensure arrays exist even if missing from JSON\n    data.blocks = Array.isArray(data.blocks) ? data.blocks.map(String) : []\n    data.blockedBy = Array.isArray(data.blockedBy) ? data.blockedBy.map(String) : []\n\n    return data as Task\n  } catch (error) {\n    console.error(`Error parsing task file ${filename}:`, error)\n    return null\n  }\n}\n</code></pre> <p>Key principles:</p> <ul> <li>Return <code>null</code> on failure rather than throwing</li> <li>Default missing fields to safe values (<code>'pending'</code>, <code>[]</code>, <code>''</code>)</li> <li>Coerce types when possible (<code>id</code> can be number or string in JSON)</li> <li>Log warnings for debugging but do not crash</li> </ul>"},{"location":"development/conventions/#path-traversal-protection","title":"Path Traversal Protection","text":"<p>Any function that resolves file paths from user-controlled or externally-written input must verify the target stays under <code>$HOME</code>:</p> apps/task-manager/src/lib/taskService.ts<pre><code>function resolveExecutionDir(pointerContent: string): string | null {\n  const raw = pointerContent.trim()\n  if (!raw) return null\n\n  const home = homedir()\n  const resolved = raw.startsWith('/') ? resolve(raw) : resolve(home, raw)\n\n  // Guard against path traversal\n  const rel = relative(home, resolved)\n  if (rel.startsWith('..') || resolve(home, rel) !== resolved) {\n    console.warn(`Execution pointer path escapes home directory: ${raw}`)\n    return null\n  }\n\n  return resolved\n}\n</code></pre> <p>API routes also validate <code>listId</code> parameters against <code>..</code> and <code>/</code> patterns before constructing file paths.</p>"},{"location":"development/conventions/#global-singleton-via-globalthis","title":"Global Singleton via globalThis","text":"<p>The <code>FileWatcher</code> class uses <code>globalThis</code> to survive Next.js hot module replacement (HMR) in development. Without this, each HMR cycle would spin up a new Chokidar instance:</p> apps/task-manager/src/lib/fileWatcher.ts<pre><code>// Survives HMR \u2014 only one watcher instance per process\nconst globalForWatcher = globalThis as unknown as {\n  fileWatcher: FileWatcher | undefined\n}\n\nexport const fileWatcher = globalForWatcher.fileWatcher ?? new FileWatcher()\nglobalForWatcher.fileWatcher = fileWatcher\n</code></pre>"},{"location":"development/conventions/#server-to-client-data-handoff","title":"Server-to-Client Data Handoff","text":"<p>Server Components fetch filesystem data and pass it to Client Components as <code>initialData</code> for TanStack Query. This avoids double-fetching while still enabling client-side cache invalidation:</p> apps/task-manager/src/app/lists/[listId]/page.tsx<pre><code>// Server Component \u2014 runs at request time\nexport default async function TaskListPage({ params }) {\n  const tasks = await getTasks(params.listId)\n  return &lt;TaskBoardClient listId={params.listId} initialTasks={tasks} /&gt;\n}\n</code></pre> apps/task-manager/src/hooks/useTasks.ts<pre><code>// Client hook \u2014 uses server data as initial cache seed\nexport function useTasks(taskListId: string | null, initialData?: Task[]) {\n  return useQuery({\n    queryKey: taskKeys.list(taskListId ?? ''),\n    queryFn: () =&gt; fetchTasks(taskListId!),\n    enabled: !!taskListId,\n    initialData,\n  })\n}\n</code></pre>"},{"location":"development/conventions/#query-key-factories","title":"Query Key Factories","text":"<p>Each TanStack Query hook exports a <code>Keys</code> object for consistent, type-safe cache invalidation:</p> apps/task-manager/src/hooks/useTasks.ts<pre><code>export const taskKeys = {\n  all: ['tasks'] as const,\n  list: (listId: string) =&gt; [...taskKeys.all, listId] as const,\n}\n</code></pre> <p>Other hooks follow the same pattern (<code>taskListKeys</code>, <code>executionContextKeys</code>). This ensures SSE event handlers invalidate exactly the right cache entries.</p>"},{"location":"development/conventions/#dual-invalidation","title":"Dual Invalidation","text":"<p>When an SSE event arrives, the <code>useSSE</code> hook performs two invalidation steps to keep both data layers in sync:</p> <ol> <li>TanStack Query \u2014 <code>queryClient.invalidateQueries()</code> refetches client-side cached data</li> <li>Server Components \u2014 <code>router.refresh()</code> re-runs Server Component data fetching</li> </ol> apps/task-manager/src/hooks/useSSE.ts<pre><code>const handleTaskEvent = () =&gt; {\n  queryClient.invalidateQueries({ queryKey: taskKeys.list(taskListId) })\n  queryClient.invalidateQueries({ queryKey: taskListKeys.all })\n  router.refresh()\n}\n</code></pre>"},{"location":"development/conventions/#typescript-conventions","title":"TypeScript Conventions","text":""},{"location":"development/conventions/#compiler-configuration","title":"Compiler Configuration","text":"<p>TypeScript strict mode is enabled across the project:</p> apps/task-manager/tsconfig.json<pre><code>{\n  \"compilerOptions\": {\n    \"strict\": true,\n    \"target\": \"ES2017\",\n    \"module\": \"esnext\",\n    \"moduleResolution\": \"bundler\",\n    \"jsx\": \"react-jsx\",\n    \"paths\": {\n      \"@/*\": [\"./src/*\"]\n    }\n  }\n}\n</code></pre> <p>Path alias: All imports within the Task Manager use <code>@/</code> to reference <code>src/</code>:</p> <pre><code>import type { Task } from '@/types/task'\nimport { fetchTasks } from '@/lib/api'\n</code></pre>"},{"location":"development/conventions/#type-definitions","title":"Type Definitions","text":"<ul> <li>Define domain types in dedicated files under <code>src/types/</code></li> <li>Use <code>type</code> for unions and aliases, <code>interface</code> for object shapes</li> <li>Export types that cross module boundaries; keep internal types unexported</li> </ul> apps/task-manager/src/types/task.ts<pre><code>export type TaskStatus = 'pending' | 'in_progress' | 'completed'\n\nexport interface Task {\n  id: string\n  subject: string\n  description: string\n  status: TaskStatus\n  blocks: string[]\n  blockedBy: string[]\n  metadata?: TaskMetadata\n}\n</code></pre>"},{"location":"development/conventions/#react-conventions","title":"React Conventions","text":"<ul> <li>React 19 with the App Router (Server Components by default)</li> <li>Client Components are marked with <code>'use client'</code> at the top of the file</li> <li>shadcn/ui components live in <code>src/components/ui/</code> and are used as-is from the generator</li> </ul>"},{"location":"development/conventions/#naming-conventions","title":"Naming Conventions","text":"Context Style Example Functions, variables, hooks <code>camelCase</code> <code>parseTask</code>, <code>useTasks</code>, <code>listId</code> React components, classes <code>PascalCase</code> <code>KanbanBoard</code>, <code>FileWatcher</code> TypeScript types and interfaces <code>PascalCase</code> <code>TaskStatus</code>, <code>ExecutionContext</code> Plugin files (skills, agents) <code>kebab-case</code> <code>code-explorer.md</code>, <code>SKILL.md</code> App file names (components) <code>PascalCase</code> <code>TaskDetail.tsx</code>, <code>Providers.tsx</code> Directories <code>kebab-case</code> <code>task-manager</code>, <code>create-spec</code> Constants <code>UPPER_SNAKE_CASE</code> <code>TASKS_DIR</code>, <code>SSE_RETRY_DELAY</code>"},{"location":"development/conventions/#versioning","title":"Versioning","text":""},{"location":"development/conventions/#plugin-versions","title":"Plugin Versions","text":"<p>Plugin versions are tracked in two locations that must stay in sync:</p> plugin.jsonmarketplace.json plugins/tools/.claude-plugin/plugin.json<pre><code>{\n  \"name\": \"claude-alchemy-tools\",\n  \"version\": \"0.2.2\"\n}\n</code></pre> .claude-plugin/marketplace.json<pre><code>{\n  \"plugins\": [\n    {\n      \"name\": \"claude-alchemy-tools\",\n      \"version\": \"0.2.2\",\n      \"source\": \"./plugins/tools/\"\n    }\n  ]\n}\n</code></pre> <p>Keep Versions in Sync</p> <p>When bumping a plugin version, update both <code>plugins/{name}/.claude-plugin/plugin.json</code> and <code>.claude-plugin/marketplace.json</code>. The <code>/tools:bump-plugin-version</code> skill automates this.</p>"},{"location":"development/conventions/#current-versions","title":"Current Versions","text":"Package Version Location <code>claude-alchemy-tools</code> v0.2.2 <code>plugins/tools/</code> <code>claude-alchemy-sdd</code> v0.2.6 <code>plugins/sdd/</code> Task Manager v0.1.0 <code>apps/task-manager/</code>"},{"location":"development/conventions/#changelog-format","title":"Changelog Format","text":"<p>Changelogs follow the Keep a Changelog specification:</p> <ul> <li>Reverse chronological order (newest first)</li> <li>Each version gets its own section with an ISO date</li> <li>Changes grouped by category: Added, Changed, Deprecated, Removed, Fixed, Security</li> <li>An <code>[Unreleased]</code> section at the top collects in-progress changes</li> </ul> CHANGELOG.md<pre><code># Changelog\n\n## [Unreleased]\n\n### Added\n- New deep-analysis skill for focused codebase investigation\n\n## [0.2.2] - 2025-02-08\n\n### Changed\n- Restructured docs-manager skill to support dual-mode documentation\n\n### Fixed\n- Corrected model tier assignment for team agents\n</code></pre>"},{"location":"development/conventions/#markdown-as-code","title":"Markdown-as-Code","text":"<p>All plugin logic lives in markdown files \u2014 there is no compiled code in the plugins. This means:</p> <ul> <li>Skills are authored as structured markdown with YAML frontmatter</li> <li>Agents are system prompts written in markdown</li> <li>Reference materials are markdown documents loaded at runtime by skills</li> <li>Hooks are the only exception \u2014 they are shell scripts (<code>*.sh</code>) for PreToolUse/PostToolUse automation</li> </ul> <p>No Build Step</p> <p>Plugins have no <code>package.json</code>, no <code>node_modules</code>, and no build pipeline. They are consumed directly as markdown by the Claude Code runtime. This is why they are excluded from the pnpm workspace.</p>"},{"location":"development/setup/","title":"Setup","text":""},{"location":"development/setup/#development-setup","title":"Development Setup","text":"<p>This guide walks through setting up a local development environment for the Claude Alchemy monorepo, including the Task Manager app, Claude Code plugins, and the VS Code extension.</p>"},{"location":"development/setup/#prerequisites","title":"Prerequisites","text":"<p>Before you begin, make sure you have the following installed:</p> Requirement Minimum Version Check Command Node.js 18.0.0 <code>node -v</code> pnpm 8.0.0 <code>pnpm -v</code> Git Any recent <code>git --version</code> <p>Installing pnpm</p> <p>If you have Node.js but not pnpm, install it with <code>corepack enable</code> (Node 16.13+) or <code>npm install -g pnpm</code>.</p>"},{"location":"development/setup/#installation","title":"Installation","text":"<p>Clone the repository and install dependencies:</p> <pre><code>git clone git@github.com:sequenzia/claude-alchemy.git\ncd claude-alchemy\npnpm install\n</code></pre> <p><code>pnpm install</code> resolves dependencies for all workspace packages defined in <code>pnpm-workspace.yaml</code>. Only packages under <code>apps/*</code> are part of the pnpm workspace \u2014 plugins are markdown-only and have no dependencies to install.</p>"},{"location":"development/setup/#monorepo-layout","title":"Monorepo Layout","text":"<pre><code>claude-alchemy/\n\u251c\u2500\u2500 apps/\n\u2502   \u2514\u2500\u2500 task-manager/        # Next.js 16 app (workspace package)\n\u251c\u2500\u2500 plugins/\n\u2502   \u251c\u2500\u2500 tools/               # Developer tools plugin (markdown-only)\n\u2502   \u2514\u2500\u2500 sdd/                 # Spec-driven development plugin (markdown-only)\n\u251c\u2500\u2500 extensions/\n\u2502   \u2514\u2500\u2500 vscode/              # VS Code extension (separate npm project)\n\u251c\u2500\u2500 internal/\n\u2502   \u2514\u2500\u2500 docs/                # Internal documentation and cheatsheets\n\u251c\u2500\u2500 .claude/\n\u2502   \u2514\u2500\u2500 settings.json        # Claude Code environment settings\n\u251c\u2500\u2500 .claude-plugin/\n\u2502   \u2514\u2500\u2500 marketplace.json     # Plugin registry\n\u251c\u2500\u2500 package.json             # Root monorepo scripts &amp; engine constraints\n\u2514\u2500\u2500 pnpm-workspace.yaml      # Workspace config (apps/* only)\n</code></pre>"},{"location":"development/setup/#running-the-task-manager","title":"Running the Task Manager","text":"<p>The Task Manager is a Next.js 16 application that provides a real-time Kanban board for visualizing Claude AI task files.</p>"},{"location":"development/setup/#development-server","title":"Development Server","text":"<pre><code>pnpm dev:task-manager\n</code></pre> <p>This starts the Next.js dev server at http://localhost:3030 with hot module replacement enabled.</p> <p>Port Configuration</p> <p>The Task Manager runs on port 3030 by default, configured in <code>apps/task-manager/package.json</code> via <code>next dev -p 3030</code>.</p>"},{"location":"development/setup/#production-build","title":"Production Build","text":"<pre><code>pnpm build:task-manager\n</code></pre> <p>This runs <code>next build</code> for the Task Manager, producing an optimized production bundle.</p>"},{"location":"development/setup/#task-data-directory","title":"Task Data Directory","text":"<p>The Task Manager reads task files from <code>~/.claude/tasks/</code>. The specific task list directory is controlled by the <code>CLAUDE_CODE_TASK_LIST_ID</code> environment variable set in <code>.claude/settings.json</code>:</p> .claude/settings.json<pre><code>{\n  \"env\": {\n    \"CLAUDE_CODE_TASK_LIST_ID\": \"claude-alchemy\"\n  }\n}\n</code></pre> <p>This means tasks are read from <code>~/.claude/tasks/claude-alchemy/</code>. If you want to work with a different task list, update this value.</p>"},{"location":"development/setup/#linting","title":"Linting","text":"<p>Run linting across all workspace packages:</p> <pre><code>pnpm lint\n</code></pre> <p>This executes <code>pnpm -r lint</code>, which recursively runs the <code>lint</code> script in every workspace package. Currently this runs ESLint for the Task Manager.</p>"},{"location":"development/setup/#plugin-development","title":"Plugin Development","text":"<p>Claude Alchemy includes two Claude Code plugins:</p> Plugin Invoke Prefix Description <code>claude-alchemy-tools</code> (v0.2.2) <code>/tools:{skill}</code> Developer tools \u2014 10 skills, 5 agents <code>claude-alchemy-sdd</code> (v0.2.6) <code>/sdd:{skill}</code> Spec-driven development \u2014 4 skills, 2 agents"},{"location":"development/setup/#editing-plugins","title":"Editing Plugins","text":"<p>Plugins are markdown-only \u2014 there is no build step, no compilation, and no dependencies to install. To modify a plugin:</p> <ol> <li>Edit the skill or agent <code>.md</code> files directly under <code>plugins/tools/</code> or <code>plugins/sdd/</code></li> <li>Changes take effect immediately \u2014 Claude Code reads plugin files at runtime</li> </ol> <p>Plugin File Conventions</p> <ul> <li>Skills are named <code>SKILL.md</code> with YAML frontmatter, located under <code>skills/{skill-name}/</code></li> <li>Agents are named <code>{agent-name}.md</code> (kebab-case), located under <code>agents/</code></li> <li>Reference materials live in <code>skills/{skill-name}/references/</code> and are loaded at runtime</li> </ul>"},{"location":"development/setup/#versioning-plugins","title":"Versioning Plugins","text":"<p>Plugin versions are tracked in two places that must stay in sync:</p> <ul> <li><code>plugins/{name}/.claude-plugin/plugin.json</code> \u2014 the plugin's own manifest</li> <li><code>.claude-plugin/marketplace.json</code> \u2014 the root-level plugin registry</li> </ul> <p>Use the built-in skill to bump versions consistently:</p> <pre><code># From within a Claude Code session\n/tools:bump-plugin-version\n</code></pre>"},{"location":"development/setup/#plugin-directory-structure","title":"Plugin Directory Structure","text":"<pre><code>plugins/tools/\n\u251c\u2500\u2500 .claude-plugin/\n\u2502   \u2514\u2500\u2500 plugin.json          # Plugin manifest (name, version, metadata)\n\u251c\u2500\u2500 agents/\n\u2502   \u2514\u2500\u2500 {agent-name}.md      # Agent definitions (kebab-case)\n\u251c\u2500\u2500 skills/\n\u2502   \u2514\u2500\u2500 {skill-name}/\n\u2502       \u251c\u2500\u2500 SKILL.md          # Skill definition with YAML frontmatter\n\u2502       \u2514\u2500\u2500 references/       # Reference materials loaded at runtime\n\u251c\u2500\u2500 hooks/                    # PreToolUse / PostToolUse hooks (if any)\n\u2514\u2500\u2500 rules/                    # Project rules applied by Claude Code\n</code></pre>"},{"location":"development/setup/#vs-code-extension","title":"VS Code Extension","text":"<p>The repository includes a VS Code extension (<code>claude-code-schemas</code>) that provides schema validation, autocomplete, and hover documentation for Claude Code plugin files.</p>"},{"location":"development/setup/#setup","title":"Setup","text":"<pre><code>cd extensions/vscode\nnpm install\n</code></pre> <p>Separate Package Manager</p> <p>The VS Code extension uses npm, not pnpm. It is a standalone project and is not part of the pnpm workspace.</p>"},{"location":"development/setup/#build","title":"Build","text":"<pre><code>cd extensions/vscode\nnpm run build\n</code></pre> <p>This runs esbuild to bundle the extension into <code>dist/extension.js</code>.</p>"},{"location":"development/setup/#package","title":"Package","text":"<pre><code>cd extensions/vscode\nnpm run package\n</code></pre> <p>This creates a <code>.vsix</code> file that can be installed in VS Code via Extensions &gt; Install from VSIX.</p>"},{"location":"development/setup/#what-it-validates","title":"What It Validates","text":"<p>The extension provides JSON schema validation for:</p> File Pattern Schema <code>.claude-plugin/plugin.json</code> Plugin manifest <code>hooks/hooks.json</code> Hook configuration <code>.mcp.json</code> MCP server configuration <code>.lsp.json</code> LSP configuration <code>marketplace.json</code> Plugin marketplace registry"},{"location":"development/setup/#configuration-reference","title":"Configuration Reference","text":"File Purpose <code>package.json</code> (root) Monorepo scripts (<code>dev:task-manager</code>, <code>build:task-manager</code>, <code>lint</code>) and engine constraints (Node &gt;= 18, pnpm &gt;= 8) <code>pnpm-workspace.yaml</code> Declares workspace packages \u2014 only <code>apps/*</code>; plugins are excluded <code>.claude/settings.json</code> Claude Code environment: sets <code>CLAUDE_CODE_TASK_LIST_ID</code>, enables experimental agent teams, configures MCP servers <code>.claude-plugin/marketplace.json</code> Root plugin registry listing both <code>claude-alchemy-tools</code> and <code>claude-alchemy-sdd</code> <code>apps/task-manager/package.json</code> Task Manager dependencies (Next.js 16, React 19, TanStack Query, Chokidar, shadcn/ui) <code>apps/task-manager/tsconfig.json</code> TypeScript strict mode, bundler module resolution, <code>@/*</code> path alias mapping to <code>./src/*</code>"},{"location":"development/setup/#environment-variables","title":"Environment Variables","text":"<p>The following environment variables are configured in <code>.claude/settings.json</code> and are available to Claude Code sessions:</p> Variable Value Purpose <code>CLAUDE_CODE_TASK_LIST_ID</code> <code>claude-alchemy</code> Determines which task list directory to use under <code>~/.claude/tasks/</code> <code>CLAUDE_CODE_EXPERIMENTAL_AGENT_TEAMS</code> <code>1</code> Enables experimental agent teams feature in Claude Code"},{"location":"development/setup/#troubleshooting","title":"Troubleshooting","text":"<p>pnpm install fails with engine errors</p> <p>Verify your Node.js version is 18+ and pnpm version is 8+. The root <code>package.json</code> enforces these minimums via the <code>engines</code> field.</p> <p>Task Manager shows no tasks</p> <p>Ensure the directory <code>~/.claude/tasks/claude-alchemy/</code> exists and contains <code>.json</code> task files. The Task Manager reads from this path based on the <code>CLAUDE_CODE_TASK_LIST_ID</code> setting.</p> <p>Port 3030 is already in use</p> <p>Either stop the other process using port 3030, or modify the dev script in <code>apps/task-manager/package.json</code> to use a different port: <code>\"dev\": \"next dev -p &lt;new-port&gt;\"</code>.</p> <p>Plugin changes not taking effect</p> <p>Claude Code reads plugin files at the start of each session. If you modified a plugin mid-session, start a new Claude Code session to pick up the changes.</p>"},{"location":"plugins/overview/","title":"Overview","text":""},{"location":"plugins/overview/#plugin-system-overview","title":"Plugin System Overview","text":"<p>Claude Alchemy ships two Claude Code plugins that extend Claude's capabilities with structured workflows, specialized agents, and event-driven automation. Both plugins are markdown-only -- they have no <code>package.json</code>, no build step, and no runtime dependencies. Claude Code loads them as context at conversation start and interprets their instructions directly.</p> <p>This page covers the core concepts that both plugins share. For plugin-specific details, see Tools Plugin and SDD Plugin.</p>"},{"location":"plugins/overview/#the-two-plugins","title":"The Two Plugins","text":"Plugin Version Agents Skills Prefix Purpose <code>claude-alchemy-tools</code> 0.2.2 10 13 <code>/tools:</code> Feature development, codebase analysis, documentation, Git, releases <code>claude-alchemy-sdd</code> 0.2.6 2 4 <code>/sdd:</code> Spec-driven development: spec creation, analysis, task decomposition, autonomous execution <p>Both plugins live under <code>plugins/</code> in the monorepo but are excluded from the pnpm workspace. They are pure markdown -- no <code>node_modules</code>, no compilation, no transpilation.</p> <pre><code>plugins/\n\u251c\u2500\u2500 tools/                      # claude-alchemy-tools\n\u2502   \u251c\u2500\u2500 agents/                 # 10 agent definitions\n\u2502   \u251c\u2500\u2500 skills/                 # 13 skill definitions\n\u2502   \u251c\u2500\u2500 .claude-plugin/\n\u2502   \u2502   \u2514\u2500\u2500 plugin.json         # Plugin manifest\n\u2502   \u2514\u2500\u2500 README.md\n\u2514\u2500\u2500 sdd/                        # claude-alchemy-sdd\n    \u251c\u2500\u2500 agents/                 # 2 agent definitions\n    \u251c\u2500\u2500 skills/                 # 4 skill definitions\n    \u251c\u2500\u2500 hooks/                  # Event-driven automation\n    \u2502   \u251c\u2500\u2500 hooks.json          # Hook configuration\n    \u2502   \u2514\u2500\u2500 auto-approve-session.sh\n    \u251c\u2500\u2500 .claude-plugin/\n    \u2502   \u2514\u2500\u2500 plugin.json         # Plugin manifest\n    \u2514\u2500\u2500 README.md\n</code></pre>"},{"location":"plugins/overview/#core-concepts","title":"Core Concepts","text":"<p>The plugin system is built on four primitives: skills, agents, hooks, and plugin manifests. Skills are user-facing workflows. Agents are specialized sub-processes that skills launch to do focused work. Hooks automate permission decisions. Manifests track plugin metadata and versions.</p>"},{"location":"plugins/overview/#skills","title":"Skills","text":"<p>A skill is a <code>SKILL.md</code> file inside a <code>skills/{skill-name}/</code> directory. It contains YAML frontmatter with metadata followed by a markdown body with instructions, workflow phases, and behavioral guidelines. Skills are the primary user-facing interface to the plugin system.</p>"},{"location":"plugins/overview/#invocation","title":"Invocation","text":"<p>Users invoke skills with the plugin prefix and skill name:</p> <pre><code>/tools:feature-dev implement user authentication with OAuth2\n/tools:git-commit\n/sdd:create-spec\n/sdd:execute-tasks --max-parallel 3\n</code></pre> <p>The text after the skill name is passed as <code>$ARGUMENTS</code> and can include flags like <code>--teams</code> or <code>--max-parallel</code>.</p>"},{"location":"plugins/overview/#frontmatter-schema","title":"Frontmatter Schema","text":"<p>Every <code>SKILL.md</code> starts with YAML frontmatter that defines the skill's metadata:</p> plugins/tools/skills/feature-dev/SKILL.md<pre><code>---\nname: feature-dev\ndescription: Feature development workflow with exploration, architecture, implementation, and review phases.\nargument-hint: &lt;feature-description&gt; [--teams]\nmodel: inherit\nuser-invocable: true\ndisable-model-invocation: false\nallowed-tools: Read, Write, Edit, Glob, Grep, Bash, Task, AskUserQuestion\n---\n</code></pre> Field Type Description <code>name</code> string Skill identifier used in invocation (<code>/tools:{name}</code>) <code>description</code> string What the skill does and when to use it <code>argument-hint</code> string Shows users what arguments the skill accepts <code>model</code> string Model to run the skill with (<code>opus</code>, <code>sonnet</code>, <code>haiku</code>, or <code>inherit</code>) <code>user-invocable</code> boolean Whether users can invoke this skill directly <code>disable-model-invocation</code> boolean Whether Claude can invoke this skill autonomously <code>allowed-tools</code> list Tools the skill is permitted to use <code>arguments</code> list Structured argument definitions with <code>name</code>, <code>description</code>, <code>required</code>"},{"location":"plugins/overview/#skill-categories","title":"Skill Categories","text":"<p>Skills fall into two categories based on their <code>user-invocable</code> flag:</p> User-Invocable SkillsSupporting Skills <p>These are the primary entry points. Users invoke them directly to trigger workflows.</p> Plugin Skill Model Description tools <code>feature-dev</code> inherit 7-phase feature development workflow tools <code>codebase-analysis</code> inherit Structured codebase exploration and analysis tools <code>docs-manager</code> inherit Documentation management for MkDocs and standalone markdown tools <code>deep-analysis</code> inherit Reusable exploration + synthesis workflow tools <code>teams-deep-analysis</code> inherit Team-based collaborative analysis with Agent Teams tools <code>git-commit</code> haiku Conventional commit message generation tools <code>release</code> haiku Package release preparation and verification tools <code>bump-plugin-version</code> haiku Plugin version bumping in manifest files sdd <code>create-spec</code> inherit Interactive specification creation sdd <code>analyze-spec</code> inherit Spec quality analysis and issue detection sdd <code>create-tasks</code> inherit Spec decomposition into Claude Code Tasks sdd <code>execute-tasks</code> inherit Autonomous wave-based parallel task execution <p>These are building blocks loaded by other skills at runtime. They provide domain knowledge and pattern guidance rather than standalone workflows.</p> Plugin Skill Description tools <code>architecture-patterns</code> Architectural pattern knowledge (MVC, event-driven, CQRS) tools <code>language-patterns</code> Language-specific idioms and best practices tools <code>project-conventions</code> Project convention detection and enforcement tools <code>code-quality</code> Code quality review standards tools <code>changelog-format</code> Keep a Changelog formatting guidelines"},{"location":"plugins/overview/#reference-materials","title":"Reference Materials","text":"<p>Skills can include reference materials in a <code>references/</code> subdirectory alongside <code>SKILL.md</code>. These are markdown files loaded at runtime to provide templates, examples, and domain knowledge:</p> <pre><code>skills/create-spec/\n\u251c\u2500\u2500 SKILL.md\n\u2514\u2500\u2500 references/\n    \u251c\u2500\u2500 interview-questions.md\n    \u251c\u2500\u2500 recommendation-format.md\n    \u251c\u2500\u2500 recommendation-triggers.md\n    \u2514\u2500\u2500 templates/\n        \u251c\u2500\u2500 detailed.md\n        \u251c\u2500\u2500 full-tech.md\n        \u2514\u2500\u2500 high-level.md\n</code></pre> <p>Skills load references using the <code>${CLAUDE_PLUGIN_ROOT}</code> variable:</p> <pre><code>Read `${CLAUDE_PLUGIN_ROOT}/skills/create-spec/references/interview-questions.md`\n</code></pre>"},{"location":"plugins/overview/#skill-composition","title":"Skill Composition","text":"<p>Skills can load other skills as reusable building blocks. The calling skill reads the target <code>SKILL.md</code> and follows its workflow inline. For example, <code>feature-dev</code> loads <code>deep-analysis</code> for its codebase exploration phase:</p> <pre><code>graph LR\n    FD[\"feature-dev\"] --&gt;|\"loads\"| DA[\"deep-analysis\"]\n    FD --&gt;|\"loads\"| PJ[\"project-conventions\"]\n    CA[\"codebase-analysis\"] --&gt;|\"loads\"| DA\n    DA --&gt;|\"loads\"| PJ\n    DA --&gt;|\"loads\"| LP[\"language-patterns\"]</code></pre> <p>This composition pattern avoids duplicating workflow logic across skills. Changes to <code>deep-analysis</code> automatically propagate to every skill that loads it.</p>"},{"location":"plugins/overview/#agents","title":"Agents","text":"<p>An agent is a <code>{kebab-case-name}.md</code> file in the <code>agents/</code> directory. Agents are specialized sub-processes that skills spawn via Claude Code's <code>Task</code> tool to perform focused work. Each agent has a narrow scope, a specific model tier, and a constrained tool set.</p>"},{"location":"plugins/overview/#frontmatter-schema_1","title":"Frontmatter Schema","text":"plugins/tools/agents/code-explorer.md<pre><code>---\ndescription: Explores codebases to find relevant files, trace execution paths, and map architecture\ntools:\n  - Read\n  - Glob\n  - Grep\n  - Bash\nmodel: sonnet\nskills:\n  - project-conventions\n  - language-patterns\n---\n</code></pre> Field Type Description <code>description</code> string What the agent does <code>tools</code> list Tools the agent is permitted to use <code>model</code> string Model tier for this agent (<code>opus</code>, <code>sonnet</code>, <code>haiku</code>, or <code>inherit</code>) <code>skills</code> list Supporting skills the agent can access"},{"location":"plugins/overview/#agent-inventory","title":"Agent Inventory","text":"Tools Plugin AgentsSDD Plugin Agents Agent Model Tools Purpose <code>code-explorer</code> sonnet Read, Glob, Grep, Bash Explore codebases to find relevant files and map architecture <code>code-architect</code> inherit Read, Glob, Grep Design implementation blueprints from exploration findings <code>code-reviewer</code> inherit Read, Glob, Grep Review code for correctness, security, and maintainability <code>codebase-synthesizer</code> inherit Read, Glob, Grep Merge findings from multiple code-explorer agents <code>docs-writer</code> inherit Read, Glob, Grep, Bash Generate MkDocs or GitHub-flavored Markdown documentation <code>researcher</code> inherit (web tools) Research technical docs via web search and Context7 <code>changelog-agent</code> (default) Bash, Read, Edit, Glob, Grep Analyze git history and update CHANGELOG.md <code>team-code-explorer</code> sonnet Read, Glob, Grep, Bash, SendMessage, TaskUpdate, TaskGet, TaskList Code explorer with team communication capabilities <code>team-codebase-synthesizer</code> inherit Read, Glob, Grep, SendMessage, TaskUpdate, TaskGet, TaskList Synthesizer with interactive follow-up via Agent Teams <code>team-deep-analyst</code> opus Read, Glob, Grep, Bash, SendMessage, TaskUpdate, TaskGet, TaskList Specialist for cross-cutting concerns, security audits, git history Agent Model Tools Purpose <code>task-executor</code> inherit Read, Write, Edit, Glob, Grep, Bash, TaskGet, TaskUpdate, TaskList Execute a single task through understand-implement-verify-complete phases <code>spec-analyzer</code> inherit AskUserQuestion, Read, Write, Edit, Glob, Grep Analyze specs for quality issues and guide interactive resolution"},{"location":"plugins/overview/#model-tiering","title":"Model Tiering","text":"<p>Agents are assigned to model tiers based on the cognitive demands of their work:</p> Model Cost When to Use Examples <code>opus</code> Highest Complex reasoning, synthesis, architecture design <code>codebase-synthesizer</code>, <code>team-deep-analyst</code> <code>sonnet</code> Medium Exploration, pattern detection, broad search <code>code-explorer</code>, <code>team-code-explorer</code> <code>haiku</code> Lowest Mechanical, procedural tasks with clear rules <code>git-commit</code>, <code>bump-plugin-version</code> <code>inherit</code> Varies Use the parent session's model <code>code-architect</code>, <code>researcher</code>, <code>task-executor</code> <p>Cost Optimization</p> <p>Model tiering is a deliberate cost optimization strategy. Exploratory work that benefits from breadth (scanning many files) uses the faster, cheaper <code>sonnet</code>. Synthesis work that requires depth (merging findings, designing architecture) uses the more capable <code>opus</code>. Simple procedural tasks that follow rigid rules use the cheapest <code>haiku</code>.</p>"},{"location":"plugins/overview/#spawning-agents","title":"Spawning Agents","text":"<p>Skills spawn agents using the <code>Task</code> tool with the <code>subagent_type</code> parameter. The agent type follows the format <code>{plugin-name}:{agent-name}</code>:</p> <pre><code>Launch a code-explorer agent using the Task tool:\n- subagent_type: \"claude-alchemy-tools:code-explorer\"\n- model: \"sonnet\"\n- prompt: \"Explore entry points and user-facing code at /path/to/project...\"\n</code></pre> <p>For team-based agents, the <code>team_name</code> parameter is also required to join the agent to a team:</p> <pre><code>Launch a team-code-explorer agent:\n- subagent_type: \"claude-alchemy-tools:team-code-explorer\"\n- model: \"sonnet\"\n- team_name: \"deep-analysis-1707300000\"\n- prompt: \"You are part of a deep analysis team...\"\n</code></pre>"},{"location":"plugins/overview/#hooks","title":"Hooks","text":"<p>Hooks provide event-driven automation by running shell scripts in response to Claude Code tool invocations. They are defined in a <code>hooks/hooks.json</code> file within the plugin directory.</p>"},{"location":"plugins/overview/#hook-configuration","title":"Hook Configuration","text":"plugins/sdd/hooks/hooks.json<pre><code>{\n  \"description\": \"Auto-approve file operations for execute-tasks session management\",\n  \"hooks\": {\n    \"PreToolUse\": [\n      {\n        \"matcher\": \"Write|Edit|Bash\",\n        \"hooks\": [\n          {\n            \"type\": \"command\",\n            \"command\": \"bash ${CLAUDE_PLUGIN_ROOT}/hooks/auto-approve-session.sh\",\n            \"timeout\": 5\n          }\n        ]\n      }\n    ]\n  }\n}\n</code></pre> Field Description <code>PreToolUse</code> / <code>PostToolUse</code> Event type -- fires before or after a tool is invoked <code>matcher</code> Regex pattern matching tool names (e.g., <code>Write\\|Edit\\|Bash</code>) <code>type</code> Hook type -- currently only <code>command</code> is supported <code>command</code> Shell command to execute. <code>${CLAUDE_PLUGIN_ROOT}</code> resolves to the plugin directory <code>timeout</code> Maximum execution time in seconds"},{"location":"plugins/overview/#how-the-auto-approve-hook-works","title":"How the Auto-Approve Hook Works","text":"<p>The SDD plugin's <code>auto-approve-session.sh</code> hook enables the <code>execute-tasks</code> skill to write session files without prompting the user for permission on every file operation. The hook receives the tool invocation as JSON on stdin and returns a permission decision:</p> <pre><code>flowchart TD\n    A[\"Claude invokes Write/Edit/Bash\"] --&gt; B{\"Hook receives tool input\"}\n    B --&gt; C{\"Is target path a session file?\"}\n    C --&gt;|\"~/.claude/tasks/*/execution_pointer.md\"| D[\"Return: allow\"]\n    C --&gt;|\"*/.claude/sessions/*\"| D\n    C --&gt;|\"Bash with mkdir/mv targeting .claude/sessions/\"| D\n    C --&gt;|\"Other path\"| E[\"Exit silently (no opinion)\"]\n    E --&gt; F[\"Normal permission flow\"]</code></pre> <p>Scope Limitation</p> <p>The auto-approve hook only approves operations on session-related paths. All other file operations fall through to Claude Code's normal permission flow, where the user is prompted for approval.</p>"},{"location":"plugins/overview/#plugin-manifests","title":"Plugin Manifests","text":"<p>Each plugin has its own <code>plugin.json</code> manifest, and a root-level <code>marketplace.json</code> tracks all plugins. Both files must be kept in sync when versions change.</p> Plugin ManifestMarketplace Registry plugins/tools/.claude-plugin/plugin.json<pre><code>{\n  \"name\": \"claude-alchemy-tools\",\n  \"version\": \"0.2.2\",\n  \"description\": \"Developer tools for feature development, Git workflows, and release automation\",\n  \"author\": {\n    \"name\": \"Stephen Sequenzia\",\n    \"email\": \"sequenzia@gmail.com\",\n    \"url\": \"https://sequenzia.com\"\n  },\n  \"homepage\": \"https://github.com/sequenzia/claude-alchemy/tree/main/plugins/tools\",\n  \"repository\": \"https://github.com/sequenzia/claude-alchemy/tree/main/plugins/tools\",\n  \"license\": \"MIT\",\n  \"keywords\": [\"claude-code\", \"agents\", \"skills\", \"hooks\", \"workflow\", \"automation\"]\n}\n</code></pre> .claude-plugin/marketplace.json<pre><code>{\n  \"name\": \"claude-alchemy\",\n  \"description\": \"Custom plugins for Claude Alchemy\",\n  \"plugins\": [\n    {\n      \"name\": \"claude-alchemy-tools\",\n      \"version\": \"0.2.2\",\n      \"source\": \"./plugins/tools/\",\n      \"category\": \"development\"\n    },\n    {\n      \"name\": \"claude-alchemy-sdd\",\n      \"version\": \"0.2.6\",\n      \"source\": \"./plugins/sdd/\",\n      \"category\": \"development\"\n    }\n  ]\n}\n</code></pre> <p>Version Synchronization</p> <p>The <code>version</code> field must match between <code>plugin.json</code> and the corresponding entry in <code>marketplace.json</code>. The <code>/tools:bump-plugin-version</code> skill handles this automatically -- it updates both files in a single operation.</p>"},{"location":"plugins/overview/#agent-orchestration-patterns","title":"Agent Orchestration Patterns","text":"<p>Skills use several orchestration patterns to coordinate agents. The choice of pattern depends on the nature of the work: independent exploration benefits from parallelism, while synthesis requires sequential dependencies.</p>"},{"location":"plugins/overview/#parallel-exploration","title":"Parallel Exploration","text":"<p>Multiple agents are launched simultaneously, each with a distinct focus area to minimize overlap. The skill waits for all agents to complete before proceeding.</p> <pre><code>graph LR\n    S[\"Skill (orchestrator)\"] --&gt;|\"launch\"| E1[\"Explorer 1\\n(entry points)\"]\n    S --&gt;|\"launch\"| E2[\"Explorer 2\\n(data models)\"]\n    S --&gt;|\"launch\"| E3[\"Explorer 3\\n(infrastructure)\"]\n    E1 --&gt;|\"findings\"| S\n    E2 --&gt;|\"findings\"| S\n    E3 --&gt;|\"findings\"| S</code></pre> <p>Used by: <code>deep-analysis</code>, <code>teams-deep-analysis</code>, <code>feature-dev</code>, <code>codebase-analysis</code></p> <p>The <code>deep-analysis</code> skill launches 2-3 <code>code-explorer</code> agents in parallel, each assigned a focus area like \"entry points and user-facing code\", \"data models and storage\", or \"utilities and shared infrastructure\". The skill waits for all agents to report back, then passes their combined findings to a synthesizer.</p>"},{"location":"plugins/overview/#sequential-pipeline","title":"Sequential Pipeline","text":"<p>The output of one phase becomes the input of the next. A synthesizer agent only starts after all explorers have completed.</p> <pre><code>graph LR\n    E1[\"Explorer 1\"] --&gt; W[\"Wait for all\"]\n    E2[\"Explorer 2\"] --&gt; W\n    E3[\"Explorer 3\"] --&gt; W\n    W --&gt; SY[\"Synthesizer\\n(opus)\"]\n    SY --&gt; R[\"Results\"]</code></pre> <p>Used by: <code>deep-analysis</code>, <code>codebase-analysis</code></p> <p>This pattern combines parallel exploration with sequential synthesis. The synthesizer reads all exploration reports, merges duplicates, resolves conflicts, and produces a unified analysis. The synthesizer uses <code>opus</code> for its deeper reasoning capabilities.</p>"},{"location":"plugins/overview/#team-collaboration","title":"Team Collaboration","text":"<p>Agent Teams enable real-time inter-agent communication via <code>SendMessage</code>. Explorers share discoveries with each other as they work, and the synthesizer can ask follow-up questions to resolve conflicts.</p> <pre><code>graph TB\n    Lead[\"Lead (skill orchestrator)\"]\n    Lead --&gt;|\"spawn + assign\"| E1[\"Explorer 1\"]\n    Lead --&gt;|\"spawn + assign\"| E2[\"Explorer 2\"]\n    Lead --&gt;|\"spawn + assign\"| E3[\"Explorer 3\"]\n    Lead --&gt;|\"spawn\"| SY[\"Synthesizer\"]\n    Lead --&gt;|\"spawn\"| AN[\"Deep Analyst\"]\n\n    E1 &lt;--&gt;|\"SendMessage\"| E2\n    E2 &lt;--&gt;|\"SendMessage\"| E3\n    E1 &lt;--&gt;|\"SendMessage\"| E3\n    SY --&gt;|\"follow-up questions\"| E1\n    SY --&gt;|\"follow-up questions\"| E2\n    SY --&gt;|\"follow-up questions\"| E3\n    SY --&gt;|\"delegate investigation\"| AN</code></pre> <p>Used by: <code>teams-deep-analysis</code></p> <p>The team-based workflow creates a named team with 5 agents: 3 explorers, 1 synthesizer, and 1 deep analyst. Explorers proactively share significant discoveries (shared utilities, unexpected integration points, cross-cutting patterns) with their teammates via <code>SendMessage</code>. The synthesizer can ask explorers follow-up questions to clarify conflicts. The deep analyst activates on demand for complex investigations that require <code>Bash</code> access (git history, dependency trees, static analysis).</p>"},{"location":"plugins/overview/#wave-based-concurrency","title":"Wave-Based Concurrency","text":"<p>Tasks are organized into dependency-based waves using topological sorting. Within each wave, up to <code>max_parallel</code> agents execute simultaneously. The next wave starts only after the current wave completes.</p> <pre><code>graph TB\n    subgraph Wave1[\"Wave 1 (no dependencies)\"]\n        T1[\"Task 1\"]\n        T2[\"Task 2\"]\n        T3[\"Task 3\"]\n    end\n    subgraph Wave2[\"Wave 2 (depends on Wave 1)\"]\n        T4[\"Task 4\"]\n        T5[\"Task 5\"]\n    end\n    subgraph Wave3[\"Wave 3 (depends on Wave 2)\"]\n        T6[\"Task 6\"]\n    end\n    Wave1 --&gt; Wave2\n    Wave2 --&gt; Wave3</code></pre> <p>Used by: <code>execute-tasks</code></p> <p>The <code>execute-tasks</code> skill builds a dependency graph from task <code>blockedBy</code> relationships and assigns tasks to waves via topological sort. Wave 1 contains all tasks with no dependencies, Wave 2 contains tasks that depend only on Wave 1 tasks, and so on. Within each wave, tasks are sorted by priority (<code>critical</code> &gt; <code>high</code> &gt; <code>medium</code> &gt; <code>low</code>) and by how many other tasks they unblock. If a wave exceeds <code>max_parallel</code>, it splits into sub-waves.</p> <p>Each task in a wave is executed by a dedicated <code>task-executor</code> agent that follows a 4-phase workflow: Understand, Implement, Verify, Complete. Agents share learnings across tasks through a shared <code>execution_context.md</code> file.</p>"},{"location":"plugins/overview/#plugin-directory-layout","title":"Plugin Directory Layout","text":"<p>Both plugins follow the same structural conventions:</p> <pre><code>plugins/{name}/\n\u251c\u2500\u2500 agents/\n\u2502   \u2514\u2500\u2500 {agent-name}.md            # Agent definition (kebab-case filename)\n\u251c\u2500\u2500 skills/\n\u2502   \u2514\u2500\u2500 {skill-name}/\n\u2502       \u251c\u2500\u2500 SKILL.md                # Skill definition with YAML frontmatter\n\u2502       \u2514\u2500\u2500 references/             # Optional: reference materials loaded at runtime\n\u2502           \u251c\u2500\u2500 template.md\n\u2502           \u2514\u2500\u2500 examples.md\n\u251c\u2500\u2500 hooks/                          # Optional: event-driven automation\n\u2502   \u251c\u2500\u2500 hooks.json                  # Hook configuration\n\u2502   \u2514\u2500\u2500 *.sh                        # Hook scripts\n\u251c\u2500\u2500 .claude-plugin/\n\u2502   \u2514\u2500\u2500 plugin.json                 # Plugin manifest (name, version, metadata)\n\u2514\u2500\u2500 README.md                       # Plugin documentation\n</code></pre> <p>Naming Conventions</p> <ul> <li>Plugin names: <code>claude-alchemy-{category}</code> (e.g., <code>claude-alchemy-tools</code>, <code>claude-alchemy-sdd</code>)</li> <li>Skill directories: kebab-case matching the <code>name</code> field in <code>SKILL.md</code> (e.g., <code>feature-dev/</code>, <code>git-commit/</code>)</li> <li>Agent files: kebab-case with <code>.md</code> extension (e.g., <code>code-explorer.md</code>, <code>task-executor.md</code>)</li> <li>Skill definitions: Always named <code>SKILL.md</code> (uppercase)</li> </ul>"},{"location":"plugins/overview/#runtime-variables","title":"Runtime Variables","text":"<p>Plugins have access to these variables at runtime:</p> Variable Description Example <code>${CLAUDE_PLUGIN_ROOT}</code> Absolute path to the plugin root directory <code>/path/to/plugins/tools</code> <code>$ARGUMENTS</code> Raw text passed after the skill name during invocation <code>implement auth --teams</code> <p>Skills use <code>${CLAUDE_PLUGIN_ROOT}</code> to load reference materials and compose other skills:</p> <pre><code>Read `${CLAUDE_PLUGIN_ROOT}/skills/deep-analysis/SKILL.md` and follow its workflow.\n</code></pre>"},{"location":"plugins/overview/#related-pages","title":"Related Pages","text":"<ul> <li>Tools Plugin -- Detailed reference for all tools plugin skills and agents</li> <li>SDD Plugin -- Detailed reference for the spec-driven development plugin</li> <li>SDD Workflow -- End-to-end walkthrough of the SDD lifecycle</li> <li>Architecture Overview -- High-level system architecture including plugins</li> </ul>"},{"location":"plugins/sdd-plugin/","title":"SDD Plugin","text":""},{"location":"plugins/sdd-plugin/#sdd-plugin","title":"SDD Plugin","text":"<p>The <code>claude-alchemy-sdd</code> plugin (v0.2.6) implements a Spec-Driven Development workflow for Claude Code. It covers the full lifecycle from specification authoring through quality analysis and task decomposition to autonomous, wave-based parallel execution.</p> <p>All four skills are user-invocable with the <code>/sdd:</code> prefix. The plugin is pure markdown with no build step -- skills, agents, and reference materials are loaded as context at runtime.</p> Package <code>claude-alchemy-sdd</code> Version 0.2.6 Skills 4 (all user-invocable) Agents 2 Hooks 1 (<code>PreToolUse</code>) License MIT"},{"location":"plugins/sdd-plugin/#workflow-overview","title":"Workflow Overview","text":"<p>The SDD plugin is designed around a four-step pipeline. Each step maps to a skill:</p> <pre><code>graph LR\n    A[\"/sdd:create-spec\"] --&gt; B[\"/sdd:analyze-spec\"]\n    B --&gt; C[\"/sdd:create-tasks\"]\n    C --&gt; D[\"/sdd:execute-tasks\"]\n\n    A -.-&gt;|\"specs/SPEC-*.md\"| B\n    B -.-&gt;|\"*.analysis.md\\n*.analysis.html\"| B\n    C -.-&gt;|\"Claude Code Tasks\"| D</code></pre> <ol> <li>Create Spec -- Define requirements through an adaptive interview</li> <li>Analyze Spec -- Review the spec for quality issues</li> <li>Create Tasks -- Decompose the spec into dependency-aware tasks</li> <li>Execute Tasks -- Run tasks autonomously with wave-based parallelism</li> </ol> <p>Typical Usage</p> <p>You do not have to run all four skills sequentially. Each skill works independently. You can analyze an existing spec, create tasks from a hand-written document, or execute tasks that were created manually.</p>"},{"location":"plugins/sdd-plugin/#directory-structure","title":"Directory Structure","text":"<pre><code>plugins/sdd/\n\u251c\u2500\u2500 .claude-plugin/\n\u2502   \u2514\u2500\u2500 plugin.json              # Plugin manifest (name, version, metadata)\n\u251c\u2500\u2500 agents/\n\u2502   \u251c\u2500\u2500 task-executor.md         # Per-task execution agent\n\u2502   \u2514\u2500\u2500 spec-analyzer.md         # Spec quality analysis agent\n\u251c\u2500\u2500 hooks/\n\u2502   \u2514\u2500\u2500 auto-approve-session.sh  # PreToolUse hook for session files\n\u251c\u2500\u2500 skills/\n\u2502   \u251c\u2500\u2500 create-spec/\n\u2502   \u2502   \u251c\u2500\u2500 SKILL.md\n\u2502   \u2502   \u2514\u2500\u2500 references/\n\u2502   \u2502       \u251c\u2500\u2500 interview-questions.md\n\u2502   \u2502       \u251c\u2500\u2500 recommendation-format.md\n\u2502   \u2502       \u251c\u2500\u2500 recommendation-triggers.md\n\u2502   \u2502       \u2514\u2500\u2500 templates/\n\u2502   \u2502           \u251c\u2500\u2500 high-level.md\n\u2502   \u2502           \u251c\u2500\u2500 detailed.md\n\u2502   \u2502           \u2514\u2500\u2500 full-tech.md\n\u2502   \u251c\u2500\u2500 analyze-spec/\n\u2502   \u2502   \u251c\u2500\u2500 SKILL.md\n\u2502   \u2502   \u251c\u2500\u2500 references/\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 analysis-criteria.md\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 common-issues.md\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 html-review-guide.md\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 report-template.md\n\u2502   \u2502   \u2514\u2500\u2500 templates/\n\u2502   \u2502       \u2514\u2500\u2500 review-template.html\n\u2502   \u251c\u2500\u2500 create-tasks/\n\u2502   \u2502   \u251c\u2500\u2500 SKILL.md\n\u2502   \u2502   \u2514\u2500\u2500 references/\n\u2502   \u2502       \u251c\u2500\u2500 decomposition-patterns.md\n\u2502   \u2502       \u251c\u2500\u2500 dependency-inference.md\n\u2502   \u2502       \u2514\u2500\u2500 testing-requirements.md\n\u2502   \u2514\u2500\u2500 execute-tasks/\n\u2502       \u251c\u2500\u2500 SKILL.md\n\u2502       \u2514\u2500\u2500 references/\n\u2502           \u251c\u2500\u2500 execution-workflow.md\n\u2502           \u251c\u2500\u2500 orchestration.md\n\u2502           \u2514\u2500\u2500 verification-patterns.md\n\u2514\u2500\u2500 README.md\n</code></pre>"},{"location":"plugins/sdd-plugin/#skills","title":"Skills","text":""},{"location":"plugins/sdd-plugin/#create-spec","title":"create-spec","text":"<p>Creates a new specification document through an adaptive, multi-round interview process with proactive recommendations and optional external research.</p> Invocation <code>/sdd:create-spec</code> Model inherit Allowed tools <code>AskUserQuestion</code>, <code>Task</code>, <code>Read</code>, <code>Write</code>, <code>Glob</code>, <code>Grep</code> Output <code>specs/SPEC-{name}.md</code>"},{"location":"plugins/sdd-plugin/#7-phase-workflow","title":"7-Phase Workflow","text":"Phase Name Description 1 Settings Check Load user configuration from <code>.claude/claude-alchemy.local.md</code> 2 Initial Inputs Gather spec name, type (new product / new feature), depth level, and description 3 Adaptive Interview Multi-round depth-aware interview with trigger-based recommendations 4 Recommendations Round Dedicated round for accumulated best-practice suggestions 5 Pre-Compilation Summary Present gathered requirements for user confirmation 6 Spec Compilation Generate spec from depth-appropriate template and write to file 7 Post-Compilation Analysis Offer Offer to analyze the spec for quality issues"},{"location":"plugins/sdd-plugin/#spec-depth-levels","title":"Spec Depth Levels","text":"<p>The interview adapts its scope and output template based on the chosen depth:</p> High-Level OverviewDetailed SpecificationsFull Technical Documentation <ul> <li>Rounds: 2-3 interview rounds, 6-10 questions total</li> <li>Focus: Problem, goals, key features, success metrics</li> <li>Template: <code>references/templates/high-level.md</code></li> <li>Use case: Executive summaries, stakeholder alignment, initial scoping</li> </ul> <ul> <li>Rounds: 3-4 interview rounds, 12-18 questions total</li> <li>Focus: Balanced coverage of all categories, acceptance criteria, technical constraints</li> <li>Template: <code>references/templates/detailed.md</code></li> <li>Use case: Standard development specs with clear requirements</li> </ul> <ul> <li>Rounds: 4-5 interview rounds, 18-25 questions total</li> <li>Focus: Deep technical probing, API endpoints, data models, performance targets</li> <li>Template: <code>references/templates/full-tech.md</code></li> <li>Use case: Complex features requiring API specs, data models, and architecture diagrams</li> </ul>"},{"location":"plugins/sdd-plugin/#interview-categories","title":"Interview Categories","text":"<p>Questions are drawn from four categories, with depth adjusted per level:</p> <ol> <li>Problem &amp; Goals -- Problem statement, success metrics, user personas, business value</li> <li>Functional Requirements -- Features, user stories, acceptance criteria, workflows</li> <li>Technical Specs -- Architecture, tech stack, data models, APIs, constraints</li> <li>Implementation -- Phases, dependencies, risks, out-of-scope items</li> </ol>"},{"location":"plugins/sdd-plugin/#proactive-recommendations","title":"Proactive Recommendations","text":"<p>The skill monitors user responses for patterns that indicate opportunities for best-practice suggestions. Trigger domains include authentication, scale and performance, security and compliance, real-time features, file and media handling, API design, search and discovery, testing, and accessibility.</p> <ul> <li>Inline insights: Up to 2 brief suggestions per round when triggers are detected</li> <li>Recommendations round: Accumulated recommendations presented in Phase 4 for user approval</li> <li>Recommendations are always presented for acceptance, modification, or rejection -- never assumed</li> </ul>"},{"location":"plugins/sdd-plugin/#external-research","title":"External Research","text":"<p>Research can be invoked on-demand when the user requests it, or proactively (up to 2 times per interview) for high-value topics such as compliance requirements (GDPR, HIPAA, PCI DSS) or when the user expresses uncertainty.</p>"},{"location":"plugins/sdd-plugin/#early-exit","title":"Early Exit","text":"<p>If the user signals they want to wrap up early, the skill gracefully truncates the interview, presents a summary of what was gathered, and generates the spec with a <code>Draft (Partial)</code> status marker.</p>"},{"location":"plugins/sdd-plugin/#example","title":"Example","text":"<pre><code>/sdd:create-spec\n</code></pre> <p>The skill will prompt for the spec name, type, depth, and description, then begin the adaptive interview.</p>"},{"location":"plugins/sdd-plugin/#analyze-spec","title":"analyze-spec","text":"<p>Launches the <code>spec-analyzer</code> agent to perform a comprehensive quality review of an existing specification. Generates both a markdown report and an interactive HTML review page.</p> Invocation <code>/sdd:analyze-spec specs/SPEC-*.md</code> Model inherit Arguments <code>spec-path</code> (required) -- path to the spec file Allowed tools <code>AskUserQuestion</code>, <code>Task</code>, <code>Read</code>, <code>Glob</code> Output <code>.analysis.md</code> report and <code>.analysis.html</code> interactive review"},{"location":"plugins/sdd-plugin/#5-phase-analysis","title":"5-Phase Analysis","text":"Phase Name Description 1 Structure Scan Verify all required sections for the depth level exist 2 Consistency Scan Build glossary, track priorities, map goals to metrics, find contradictions 3 Completeness Scan Check features for expected attributes, find missing dependencies 4 Clarity Scan Flag vague quantifiers, ambiguous pronouns, open-ended lists 5 Interactive Resolution Walk through findings with the user to apply fixes"},{"location":"plugins/sdd-plugin/#finding-categories","title":"Finding Categories","text":"Category What It Catches Inconsistencies Feature naming mismatches, priority contradictions, conflicting requirements Missing Information Absent sections, undefined terms, features without acceptance criteria Ambiguities Vague quantifiers (\"fast\", \"scalable\"), unclear pronouns, open-ended lists Structure Issues Missing sections, misplaced content, formatting inconsistencies"},{"location":"plugins/sdd-plugin/#severity-levels","title":"Severity Levels","text":"Severity Meaning Example Critical Would cause implementation to fail Auth required but no auth requirements defined Warning Could cause confusion or implementation problems \"Search should be fast\" without defining \"fast\" Suggestion Quality improvements, not blocking Inconsistent user story formatting"},{"location":"plugins/sdd-plugin/#depth-aware-analysis","title":"Depth-Aware Analysis","text":"<p>The analysis adapts to the spec's depth level. A high-level spec is not flagged for missing API specifications, and a full-tech spec is scrutinized for technical completeness. Depth is auto-detected from content or read from the <code>**Spec Depth**:</code> metadata field.</p>"},{"location":"plugins/sdd-plugin/#review-modes","title":"Review Modes","text":"<p>After generating the report, the user chooses how to review findings:</p> Interactive HTML Review (Recommended)CLI Update ModeReports Only <p>Opens a self-contained <code>.analysis.html</code> file in the browser. The user can:</p> <ul> <li>Filter findings by status, severity, and category</li> <li>Approve or reject each finding</li> <li>Add comments</li> <li>Click Copy Prompt to generate a natural-language prompt</li> <li>Paste the prompt back into Claude Code to apply approved changes</li> </ul> <p>Walks through each finding interactively in the terminal. For each finding, the user can:</p> <ul> <li>Apply the proposed fix</li> <li>Modify with custom text</li> <li>Skip with an optional reason</li> </ul> <p>Keeps the <code>.analysis.md</code> and <code>.analysis.html</code> files as-is with no interactive resolution.</p>"},{"location":"plugins/sdd-plugin/#example_1","title":"Example","text":"<pre><code>/sdd:analyze-spec specs/SPEC-User-Authentication.md\n</code></pre>"},{"location":"plugins/sdd-plugin/#create-tasks","title":"create-tasks","text":"<p>Decomposes a specification into Claude Code native Tasks with acceptance criteria, dependency relationships, testing requirements, and task UIDs for merge tracking.</p> Invocation <code>/sdd:create-tasks specs/SPEC-*.md</code> Model inherit Arguments <code>spec-path</code> (required) -- path to the spec file Allowed tools <code>AskUserQuestion</code>, <code>Read</code>, <code>Glob</code>, <code>Grep</code>, <code>TaskCreate</code>, <code>TaskUpdate</code>, <code>TaskList</code>, <code>TaskGet</code> Output Claude Code native Tasks"},{"location":"plugins/sdd-plugin/#8-phase-workflow","title":"8-Phase Workflow","text":"Phase Name Description 1 Validate &amp; Load Validate spec file, read content, check settings, load reference files 2 Detect Depth &amp; Check Existing Detect spec depth level, check for existing tasks (merge mode) 3 Analyze Spec Extract features, requirements, priorities, and structure 4 Decompose Tasks Break features into atomic tasks with categorized acceptance criteria 5 Infer Dependencies Map blocking relationships between tasks 6 Preview &amp; Confirm Show summary, get user approval before creating 7 Create Tasks Create tasks via <code>TaskCreate</code>/<code>TaskUpdate</code> (fresh or merge mode) 8 Error Handling Handle spec parsing issues, circular deps, missing info"},{"location":"plugins/sdd-plugin/#task-granularity-by-depth","title":"Task Granularity by Depth","text":"Depth Tasks per Feature Granularity Example High-Level 1-2 Feature-level deliverables \"Implement user authentication\" Detailed 3-5 Functional decomposition \"Implement login endpoint\", \"Add password validation\" Full-Tech 5-10 Technical decomposition \"Create User model\", \"Implement POST /auth/login\", \"Add auth middleware\""},{"location":"plugins/sdd-plugin/#task-decomposition-pattern","title":"Task Decomposition Pattern","text":"<p>For each feature, the skill applies a standard layer pattern:</p> <pre><code>1. Data Model Tasks      \u2192 \"Create {Entity} data model\"\n2. API/Service Tasks     \u2192 \"Implement {endpoint} endpoint\"\n3. Business Logic Tasks  \u2192 \"Implement {feature} business logic\"\n4. UI/Frontend Tasks     \u2192 \"Build {feature} UI component\"\n5. Test Tasks            \u2192 \"Add tests for {feature}\"\n</code></pre>"},{"location":"plugins/sdd-plugin/#task-metadata","title":"Task Metadata","text":"<p>Every task includes structured metadata for tracking and execution:</p> Field Description Example <code>priority</code> Mapped from P0-P3 <code>critical</code>, <code>high</code>, <code>medium</code>, <code>low</code> <code>complexity</code> Estimated size <code>XS</code>, <code>S</code>, <code>M</code>, <code>L</code>, <code>XL</code> <code>source_section</code> Spec section reference <code>\"7.3 Data Models\"</code> <code>spec_path</code> Source spec file <code>\"specs/SPEC-Auth.md\"</code> <code>feature_name</code> Parent feature <code>\"User Authentication\"</code> <code>task_uid</code> Unique ID for merge tracking <code>\"specs/SPEC-Auth.md:user-auth:model:001\"</code> <code>task_group</code> Group name from spec title <code>\"user-authentication\"</code> <p>task_group is Required</p> <p>The <code>task_group</code> field is set on every task. The <code>execute-tasks</code> skill relies on <code>metadata.task_group</code> for <code>--task-group</code> filtering and session ID generation. Tasks without <code>task_group</code> will be invisible to group-filtered execution runs.</p>"},{"location":"plugins/sdd-plugin/#acceptance-criteria-categories","title":"Acceptance Criteria Categories","text":"<p>Each task's acceptance criteria are organized into four categories:</p> Category What to Include Functional Core behavior, expected outputs, state changes Edge Cases Boundaries, empty/null, max values, concurrent operations Error Handling Invalid input, failures, timeouts, graceful degradation Performance Response times, throughput, resource limits (if applicable)"},{"location":"plugins/sdd-plugin/#dependency-inference","title":"Dependency Inference","text":"<p>Dependencies are inferred automatically from three sources:</p> <ol> <li>Layer dependencies -- Data Model \u2192 API \u2192 UI \u2192 Tests</li> <li>Phase dependencies -- Phase 2 tasks blocked by Phase 1 completion</li> <li>Explicit spec dependencies -- Section 10 \"requires X\" \u2192 <code>blockedBy</code> X</li> <li>Cross-feature dependencies -- Shared data models, shared services, auth dependencies</li> </ol>"},{"location":"plugins/sdd-plugin/#merge-mode","title":"Merge Mode","text":"<p>When tasks already exist for a spec (matched by <code>task_uid</code>), the skill enters merge mode:</p> Existing Status Action <code>pending</code> Update description if changed <code>in_progress</code> Preserve status, optionally update description <code>completed</code> Never modify No match Create as new task No spec requirement Flag as potentially obsolete, ask user"},{"location":"plugins/sdd-plugin/#example_2","title":"Example","text":"<pre><code>/sdd:create-tasks specs/SPEC-User-Authentication.md\n</code></pre>"},{"location":"plugins/sdd-plugin/#execute-tasks","title":"execute-tasks","text":"<p>Orchestrates autonomous task execution with wave-based concurrent parallelism, dependency-aware ordering, shared execution context, and session management.</p> Invocation <code>/sdd:execute-tasks</code> Model inherit Arguments <code>task-id</code> (optional), <code>--task-group &lt;group&gt;</code>, <code>--retries &lt;n&gt;</code> (default 3), <code>--max-parallel &lt;n&gt;</code> (default 5) Allowed tools <code>Task</code>, <code>Read</code>, <code>Write</code>, <code>Glob</code>, <code>Grep</code>, <code>Bash</code>, <code>AskUserQuestion</code>, <code>TaskList</code>, <code>TaskGet</code>, <code>TaskUpdate</code> Output Completed tasks, session artifacts in <code>.claude/sessions/</code>"},{"location":"plugins/sdd-plugin/#10-step-orchestration-loop","title":"10-Step Orchestration Loop","text":"Step Name Description 1 Load Task List Retrieve tasks, apply <code>--task-group</code> filter if specified 2 Validate State Handle empty list, all completed, blocked tasks, circular deps 3 Build Execution Plan Build dependency graph, assign tasks to waves by topological level 4 Check Settings Read <code>.claude/claude-alchemy.local.md</code> for execution preferences 5 Initialize Execution Directory Create session directory, <code>.lock</code> file, archive stale sessions 6 Present Plan &amp; Confirm Display plan, ask user to confirm before executing 7 Initialize Execution Context Read or merge prior execution context 8 Execute Loop Wave-based execution with parallel agent launches and retry handling 9 Session Summary Display results, archive session from <code>__live_session__/</code> 10 Update CLAUDE.md Add project-wide learnings discovered during execution"},{"location":"plugins/sdd-plugin/#wave-based-execution","title":"Wave-Based Execution","text":"<p>Tasks are organized into waves based on their dependency graph. Within each wave, up to <code>max_parallel</code> tasks execute concurrently:</p> <pre><code>graph TB\n    subgraph Wave1[\"Wave 1 (no dependencies)\"]\n        T1[\"Create User model\"]\n        T2[\"Create Session model\"]\n    end\n\n    subgraph Wave2[\"Wave 2 (depends on Wave 1)\"]\n        T3[\"Implement POST /auth/login\"]\n        T4[\"Implement POST /auth/register\"]\n    end\n\n    subgraph Wave3[\"Wave 3 (depends on Wave 2)\"]\n        T5[\"Build login UI\"]\n        T6[\"Add auth middleware\"]\n    end\n\n    T1 --&gt; T3\n    T1 --&gt; T4\n    T2 --&gt; T3\n    T3 --&gt; T5\n    T3 --&gt; T6</code></pre> <p>Within each wave, tasks are sorted by priority (critical &gt; high &gt; medium &gt; low), with ties broken by which task unblocks the most downstream work.</p>"},{"location":"plugins/sdd-plugin/#session-management","title":"Session Management","text":"<p>The skill manages execution sessions through a dedicated directory structure:</p> <pre><code>.claude/sessions/\n\u251c\u2500\u2500 __live_session__/              # Active session (only one at a time)\n\u2502   \u251c\u2500\u2500 .lock                      # Concurrency guard\n\u2502   \u251c\u2500\u2500 execution_plan.md          # Saved execution plan\n\u2502   \u251c\u2500\u2500 execution_context.md       # Shared learnings across tasks\n\u2502   \u251c\u2500\u2500 task_log.md                # Task results table\n\u2502   \u251c\u2500\u2500 progress.md                # Real-time progress for Task Manager\n\u2502   \u2514\u2500\u2500 tasks/                     # Archived completed task JSONs\n\u251c\u2500\u2500 user-auth-20260208-143022/     # Archived session\n\u2514\u2500\u2500 interrupted-20260207-091500/   # Auto-recovered interrupted session\n</code></pre> <p>Execution Pointer</p> <p>An <code>execution_pointer.md</code> file is written to <code>~/.claude/tasks/{listId}/</code> containing the absolute path to <code>__live_session__/</code>. The Task Manager reads this pointer to locate and display execution artifacts.</p> <p>Concurrency guard: A <code>.lock</code> file in <code>__live_session__/</code> prevents concurrent execution sessions. Stale locks older than 4 hours auto-expire.</p> <p>Interrupted session recovery: If a stale <code>__live_session__/</code> directory is found from a previous interrupted run, it is automatically archived and any <code>in_progress</code> tasks are reset to <code>pending</code>.</p>"},{"location":"plugins/sdd-plugin/#shared-execution-context","title":"Shared Execution Context","text":"<p>Tasks within a session share learnings through <code>execution_context.md</code>:</p> <ul> <li>Before each wave: The orchestrator snapshots the context file so all agents in the wave read the same baseline</li> <li>During execution: Each concurrent agent writes to an isolated <code>context-task-{id}.md</code> file to avoid write contention</li> <li>After each wave: The orchestrator merges per-task context files into the shared <code>execution_context.md</code></li> <li>Sections tracked: Project Patterns, Key Decisions, Known Issues, File Map, Task History</li> </ul> <p>This enables later tasks to benefit from discoveries made by earlier tasks, and retry attempts to learn from previous failures.</p>"},{"location":"plugins/sdd-plugin/#retry-behavior","title":"Retry Behavior","text":"<p>Failed tasks are retried up to <code>--retries</code> times (default 3). Each retry includes the previous attempt's failure details so the agent can try a different approach. Failed tasks with retries remaining are re-launched immediately within the current wave.</p> <p>After all retries are exhausted, tasks remain <code>in_progress</code> (not falsely marked completed) and execution continues with the next wave.</p>"},{"location":"plugins/sdd-plugin/#configurable-parameters","title":"Configurable Parameters","text":"Parameter Default Source Precedence <code>max_parallel</code> 5 CLI <code>--max-parallel</code> &gt; <code>.claude/claude-alchemy.local.md</code> &gt; default <code>retries</code> 3 CLI <code>--retries</code> &gt; default"},{"location":"plugins/sdd-plugin/#session-id-generation","title":"Session ID Generation","text":"<p>The <code>task_execution_id</code> is generated using three-tier resolution:</p> <ol> <li>If <code>--task-group</code> provided: <code>{task_group}-{YYYYMMDD}-{HHMMSS}</code></li> <li>Else if all open tasks share the same <code>task_group</code>: <code>{task_group}-{YYYYMMDD}-{HHMMSS}</code></li> <li>Else: <code>exec-session-{YYYYMMDD}-{HHMMSS}</code></li> </ol>"},{"location":"plugins/sdd-plugin/#examples","title":"Examples","text":"<pre><code># Execute all unblocked tasks\n/sdd:execute-tasks\n\n# Execute a specific task\n/sdd:execute-tasks 5\n\n# Execute tasks for a specific group\n/sdd:execute-tasks --task-group user-authentication\n\n# Execute with limited parallelism\n/sdd:execute-tasks --max-parallel 2\n\n# Execute sequentially (no concurrency)\n/sdd:execute-tasks --max-parallel 1\n\n# Execute with custom retry limit and parallelism\n/sdd:execute-tasks --task-group payments --max-parallel 3 --retries 1\n</code></pre>"},{"location":"plugins/sdd-plugin/#agents","title":"Agents","text":""},{"location":"plugins/sdd-plugin/#task-executor","title":"task-executor","text":"<p>A per-task execution agent that implements code changes autonomously through a 4-phase workflow. Spawned by the <code>execute-tasks</code> skill -- one agent instance per task.</p> Model inherit Spawned by <code>execute-tasks</code> skill Skills loaded <code>execute-tasks</code> (for reference files and verification patterns) Tools <code>Read</code>, <code>Write</code>, <code>Edit</code>, <code>Glob</code>, <code>Grep</code>, <code>Bash</code>, <code>TaskGet</code>, <code>TaskUpdate</code>, <code>TaskList</code>"},{"location":"plugins/sdd-plugin/#4-phase-execution","title":"4-Phase Execution","text":"<pre><code>graph LR\n    A[\"Phase 1\\nUnderstand\"] --&gt; B[\"Phase 2\\nImplement\"]\n    B --&gt; C[\"Phase 3\\nVerify\"]\n    C --&gt; D[\"Phase 4\\nComplete\"]</code></pre> <p>Phase 1 -- Understand: Load execution context, read task details, classify the task (spec-generated vs. general), parse acceptance criteria, explore the codebase, and plan the implementation.</p> <p>Phase 2 -- Implement: Read all target files before modifying them. Follow the project's implementation order (data \u2192 service \u2192 interface \u2192 tests). Match existing coding patterns. Run mid-implementation checks (linter, existing tests) to catch issues early.</p> <p>Phase 3 -- Verify: Walk each acceptance criteria category (Functional, Edge Cases, Error Handling, Performance) for spec-generated tasks, or infer a checklist from the description for general tasks. Run the test suite. Determine pass/fail status.</p> <p>Phase 4 -- Complete: Update task status via <code>TaskUpdate</code>, append learnings to the execution context, and return a structured verification report.</p>"},{"location":"plugins/sdd-plugin/#task-classification","title":"Task Classification","text":"Detection Check Result Description contains <code>**Acceptance Criteria:**</code> with categorized criteria Spec-generated Metadata contains <code>spec_path</code> Spec-generated Description contains <code>Source: {path} Section {number}</code> Spec-generated None of the above General task"},{"location":"plugins/sdd-plugin/#status-determination","title":"Status Determination","text":"Condition Status All Functional criteria pass + Tests pass PASS \u2192 task marked <code>completed</code> All Functional pass + Tests pass + Edge/Error/Perf issues PARTIAL \u2192 task stays <code>in_progress</code> Any Functional criterion fails FAIL \u2192 task stays <code>in_progress</code> Any test failure FAIL \u2192 task stays <code>in_progress</code> <p>Honest Reporting</p> <p>The agent never marks a task as completed if verification fails. PARTIAL and FAIL results leave the task as <code>in_progress</code> for the orchestrator to decide whether to retry.</p>"},{"location":"plugins/sdd-plugin/#key-behaviors","title":"Key Behaviors","text":"<ul> <li>No user interaction: Works entirely autonomously once launched</li> <li>No sub-agents: Does not use the <code>Task</code> tool; handles everything directly</li> <li>Read before write: Always reads files before modifying them</li> <li>Minimal changes: Only modifies what the task requires</li> <li>Context sharing: Appends learnings to the execution context even on failure</li> </ul>"},{"location":"plugins/sdd-plugin/#spec-analyzer","title":"spec-analyzer","text":"<p>A comprehensive spec quality analysis agent that generates reports and guides users through interactive resolution of findings.</p> Model inherit Spawned by <code>analyze-spec</code> skill (also launchable from <code>create-spec</code> Phase 7) Skills loaded <code>analyze-spec</code> Tools <code>AskUserQuestion</code>, <code>Read</code>, <code>Write</code>, <code>Edit</code>, <code>Glob</code>, <code>Grep</code>"},{"location":"plugins/sdd-plugin/#analysis-process","title":"Analysis Process","text":"<ol> <li>Load Knowledge -- Read analysis criteria, common issue patterns, report template, and HTML review guide</li> <li>Systematic Analysis -- Four-pass scan (Structure, Consistency, Completeness, Clarity)</li> <li>Categorize Findings -- Assign category, severity, location, and recommendation to each finding</li> <li>Generate Report -- Save <code>.analysis.md</code> with summary statistics and findings by severity</li> <li>Generate HTML Review -- Produce a self-contained <code>.analysis.html</code> with interactive filtering and approval</li> <li>Present Results -- Show summary and offer review mode selection (HTML review, CLI update, reports only)</li> </ol>"},{"location":"plugins/sdd-plugin/#html-review-generation","title":"HTML Review Generation","text":"<p>The agent produces a self-contained HTML file by injecting two JSON data structures into a template:</p> <ul> <li>SPEC_CONTENT -- Spec path, name, depth level, timestamp, and full markdown content</li> <li>FINDINGS_DATA -- Array of findings with id, title, category, severity, location, line number, current text, issue description, proposed fix, and status</li> </ul> <p>The resulting HTML file requires no external dependencies and can be opened directly in any browser.</p>"},{"location":"plugins/sdd-plugin/#hook","title":"Hook","text":""},{"location":"plugins/sdd-plugin/#auto-approve-sessionsh","title":"auto-approve-session.sh","text":"<p>A <code>PreToolUse</code> hook that enables unattended execution by auto-approving file operations targeting session directories. Without this hook, the <code>execute-tasks</code> skill would prompt for permission on every session file write, making autonomous execution impractical.</p> Type PreToolUse Matches <code>Write</code>, <code>Edit</code>, <code>Bash</code> tool invocations Location <code>plugins/sdd/hooks/auto-approve-session.sh</code>"},{"location":"plugins/sdd-plugin/#approval-rules","title":"Approval Rules","text":"Tool Pattern Action <code>Write</code> / <code>Edit</code> <code>~/.claude/tasks/*/execution_pointer.md</code> Auto-approve <code>Write</code> / <code>Edit</code> <code>*/.claude/sessions/*</code> Auto-approve <code>Bash</code> Commands with <code>mkdir</code> or <code>mv</code> targeting <code>.claude/sessions/</code> Auto-approve Any other Any other path No opinion (normal permission flow) <p>Scope is Intentionally Narrow</p> <p>The hook only approves operations on execution session paths and the execution pointer file. All other file operations -- including writes to application code, configuration, and spec files -- go through the normal Claude Code permission flow. This keeps the autonomy boundary tight.</p>"},{"location":"plugins/sdd-plugin/#reference-materials","title":"Reference Materials","text":"<p>Each skill loads reference materials at runtime to guide its behavior. These markdown files are never shown to the user directly but inform how the skill operates.</p>"},{"location":"plugins/sdd-plugin/#create-spec-references","title":"create-spec References","text":"File Purpose <code>interview-questions.md</code> Question bank organized by category and depth level <code>recommendation-triggers.md</code> Trigger patterns for proactive recommendations across domains <code>recommendation-format.md</code> Templates for presenting recommendations to the user <code>templates/high-level.md</code> Streamlined executive overview spec template <code>templates/detailed.md</code> Standard spec template with all sections <code>templates/full-tech.md</code> Extended template with API specs, data models, architecture"},{"location":"plugins/sdd-plugin/#analyze-spec-references","title":"analyze-spec References","text":"File Purpose <code>analysis-criteria.md</code> Depth-specific checklists and detection algorithms <code>common-issues.md</code> Issue pattern library with examples <code>html-review-guide.md</code> HTML review generation instructions and JSON data schemas <code>report-template.md</code> Standard analysis report format <code>templates/review-template.html</code> Self-contained interactive HTML review template"},{"location":"plugins/sdd-plugin/#create-tasks-references","title":"create-tasks References","text":"File Purpose <code>decomposition-patterns.md</code> Feature decomposition patterns by type <code>dependency-inference.md</code> Automatic dependency inference rules <code>testing-requirements.md</code> Test type mappings and acceptance criteria patterns"},{"location":"plugins/sdd-plugin/#execute-tasks-references","title":"execute-tasks References","text":"File Purpose <code>orchestration.md</code> 10-step orchestration loop with retry handling and session summary <code>execution-workflow.md</code> Detailed phase-by-phase procedures for the 4-phase workflow <code>verification-patterns.md</code> Task classification, criterion verification, and pass/fail rules"},{"location":"plugins/sdd-plugin/#integration-with-task-manager","title":"Integration with Task Manager","text":"<p>The SDD plugin communicates with the Task Manager exclusively through the filesystem:</p> <pre><code>sequenceDiagram\n    participant User\n    participant SDD as SDD Plugin\n    participant FS as Filesystem\n    participant TM as Task Manager\n\n    User-&gt;&gt;SDD: /sdd:create-tasks\n    SDD-&gt;&gt;FS: Write task JSON files to ~/.claude/tasks/\n\n    User-&gt;&gt;SDD: /sdd:execute-tasks\n    SDD-&gt;&gt;FS: Write execution_pointer.md\n    SDD-&gt;&gt;FS: Create .claude/sessions/__live_session__/\n    SDD-&gt;&gt;FS: Update progress.md during execution\n\n    TM--&gt;&gt;FS: Chokidar watches for changes\n    TM-&gt;&gt;TM: Display tasks in Kanban board\n    TM-&gt;&gt;TM: Show real-time execution progress</code></pre> File Written by SDD Read by Task Manager Content <code>~/.claude/tasks/{listId}/*.json</code> <code>taskService.ts</code> Task definitions (id, subject, status, dependencies) <code>~/.claude/tasks/{listId}/execution_pointer.md</code> <code>taskService.ts</code> Absolute path to <code>__live_session__/</code> <code>.claude/sessions/__live_session__/progress.md</code> Via execution pointer Real-time execution status <code>.claude/sessions/__live_session__/execution_context.md</code> Via execution pointer Shared learnings and context <code>.claude/sessions/__live_session__/task_log.md</code> Via execution pointer Task results table"},{"location":"plugins/sdd-plugin/#configuration","title":"Configuration","text":"<p>The SDD plugin reads optional settings from <code>.claude/claude-alchemy.local.md</code> in the project root. This file is not required -- all settings have sensible defaults.</p> <p>Supported settings:</p> Setting Used by Description Output path <code>create-spec</code>, <code>create-tasks</code> Custom directory for spec output Author name <code>create-spec</code>, <code>analyze-spec</code> Attribution in spec metadata <code>max_parallel</code> <code>execute-tasks</code> Default concurrent task limit (overridden by <code>--max-parallel</code> CLI arg)"},{"location":"plugins/sdd-plugin/#related-pages","title":"Related Pages","text":"<ul> <li>Architecture Overview -- System-wide architecture and design decisions</li> <li>Task Manager Overview -- The web UI that visualizes SDD execution</li> <li>Filesystem Message Bus -- How plugins communicate through the filesystem</li> </ul>"},{"location":"plugins/sdd-workflow/","title":"SDD Workflow","text":""},{"location":"plugins/sdd-workflow/#sdd-workflow","title":"SDD Workflow","text":"<p>The Spec-Driven Development (SDD) plugin (<code>claude-alchemy-sdd</code>) implements a four-stage pipeline that takes you from an idea to a fully implemented feature -- with autonomous execution handling the heavy lifting. Each stage produces artifacts that feed into the next, creating a traceable chain from requirements to code.</p> <pre><code>graph LR\n    A[\"1. Create Spec\\n/sdd:create-spec\"] --&gt; B[\"2. Analyze Spec\\n/sdd:analyze-spec\"]\n    B --&gt; C[\"3. Create Tasks\\n/sdd:create-tasks\"]\n    C --&gt; D[\"4. Execute Tasks\\n/sdd:execute-tasks\"]\n\n    A -- \"specs/SPEC-*.md\" --&gt; B\n    B -- \".analysis.md\\n.analysis.html\" --&gt; B2[\"Resolve findings\\nUpdate spec\"]\n    B2 --&gt; C\n    C -- \"~/.claude/tasks/\" --&gt; D\n    D -- \".claude/sessions/\" --&gt; E[\"Monitor via\\nTask Manager\"]\n\n    style A fill:#4a9eff,color:#fff\n    style B fill:#f5a623,color:#fff\n    style C fill:#7b68ee,color:#fff\n    style D fill:#2ecc71,color:#fff\n    style E fill:#95a5a6,color:#fff</code></pre>"},{"location":"plugins/sdd-workflow/#quick-start","title":"Quick Start","text":"<p>The fastest path from idea to implementation:</p> <pre><code># Step 1: Create a spec from your requirements\n/sdd:create-spec\n\n# Step 2 (optional but recommended): Analyze spec quality\n/sdd:analyze-spec specs/SPEC-User-Auth.md\n\n# Step 3: Decompose spec into executable tasks\n/sdd:create-tasks specs/SPEC-User-Auth.md\n\n# Step 4: Execute tasks autonomously\n/sdd:execute-tasks\n</code></pre> <p>You can chain steps</p> <p>After <code>create-spec</code> completes, it offers to run <code>analyze-spec</code> automatically. After analysis, you can invoke <code>create-tasks</code> on the updated spec, then <code>execute-tasks</code> to run everything.</p>"},{"location":"plugins/sdd-workflow/#step-1-create-spec","title":"Step 1: Create Spec","text":"<p>Skill: <code>/sdd:create-spec</code> Output: <code>specs/SPEC-{name}.md</code></p> <p>The <code>create-spec</code> skill generates a comprehensive specification document through an adaptive, multi-round interview process. It gathers requirements interactively, offers proactive recommendations based on industry best practices, and optionally performs codebase exploration and external research.</p>"},{"location":"plugins/sdd-workflow/#7-phase-workflow","title":"7-Phase Workflow","text":"<pre><code>graph TD\n    P1[\"Phase 1: Settings Check\"] --&gt; P2[\"Phase 2: Initial Inputs\"]\n    P2 --&gt; P3[\"Phase 3: Adaptive Interview\"]\n    P3 --&gt; P4[\"Phase 4: Recommendations Round\"]\n    P4 --&gt; P5[\"Phase 5: Pre-Compilation Summary\"]\n    P5 --&gt; P6[\"Phase 6: Spec Compilation\"]\n    P6 --&gt; P7[\"Phase 7: Offer Analysis\"]</code></pre>"},{"location":"plugins/sdd-workflow/#phase-1-settings-check","title":"Phase 1: Settings Check","text":"<p>Loads user configuration from <code>.claude/claude-alchemy.local.md</code> if it exists. This file can specify a custom output path, author name, and other preferences.</p>"},{"location":"plugins/sdd-workflow/#phase-2-initial-inputs","title":"Phase 2: Initial Inputs","text":"<p>Collects four pieces of starting information using <code>AskUserQuestion</code>:</p> Input Options Spec Name Free text -- a descriptive name for the spec Type \"New product\" or \"New feature\" Depth High-Level Overview, Detailed Specifications, or Full Technical Documentation Description Free text -- problem statement, key features, and constraints"},{"location":"plugins/sdd-workflow/#phase-3-adaptive-interview","title":"Phase 3: Adaptive Interview","text":"<p>The interview adapts its depth and coverage based on the depth level chosen in Phase 2:</p> Depth Level Rounds Questions Focus High-Level 2-3 6-10 Problem, goals, key features, success metrics Detailed 3-4 12-18 Balanced coverage with acceptance criteria Full-Tech 4-5 18-25 Deep probing with API endpoints, data models <p>Each round follows a structured pattern:</p> <ol> <li>Summarize what has been learned so far</li> <li>Ask 3-5 focused questions (mix of multiple choice and open text)</li> <li>Detect recommendation triggers in responses</li> <li>Offer 1-2 inline insights if high-priority triggers are found</li> <li>Acknowledge responses before moving to the next round</li> </ol> <p>Questions cover four categories: Problem &amp; Goals, Functional Requirements, Technical Specs, and Implementation.</p> <p>Codebase Exploration</p> <p>For \"New feature\" type specs, the skill offers to explore the existing codebase to understand patterns, conventions, integration points, and data models that should inform the new feature's design. This exploration uses <code>Glob</code>, <code>Grep</code>, and <code>Read</code> tools.</p> <p>External Research</p> <p>Research can be triggered two ways:</p> <ul> <li>On-demand: When you explicitly ask (\"Research the Stripe API docs\", \"Look up WCAG requirements\")</li> <li>Proactive: The skill may auto-research up to 2 topics per interview for compliance mentions (GDPR, HIPAA, PCI DSS), user uncertainty (\"what do you recommend?\"), or complex trade-offs</li> </ul> <p>Research is performed by the <code>research-agent</code> sub-agent using WebSearch and Context7 MCP tools.</p>"},{"location":"plugins/sdd-workflow/#phase-4-recommendations-round","title":"Phase 4: Recommendations Round","text":"<p>After the main interview, accumulated best-practice recommendations are presented for review. This phase is skipped for high-level specs or when no triggers were detected.</p> <p>Recommendations are organized by category (Architecture, Security, User Experience, Operational) and presented individually for accept/modify/skip decisions.</p>"},{"location":"plugins/sdd-workflow/#phase-5-pre-compilation-summary","title":"Phase 5: Pre-Compilation Summary","text":"<p>A comprehensive summary of all gathered requirements is presented for confirmation before spec generation. The summary clearly distinguishes user-provided requirements from agent recommendations. You must explicitly approve the summary before compilation proceeds.</p>"},{"location":"plugins/sdd-workflow/#phase-6-spec-compilation","title":"Phase 6: Spec Compilation","text":"<p>The skill selects a depth-appropriate template and generates the spec document:</p> Depth Template Sections Included High-Level <code>templates/high-level.md</code> Executive summary, problem statement, solution overview, feature table with priorities Detailed <code>templates/detailed.md</code> All above + numbered requirements (REQ-001), user stories, acceptance criteria, technical architecture, implementation phases Full-Tech <code>templates/full-tech.md</code> All above + API endpoint specs, data model schemas, testing strategy, code examples <p>The output file is written to <code>specs/SPEC-{name}.md</code> (or a custom path from settings).</p>"},{"location":"plugins/sdd-workflow/#phase-7-post-compilation-analysis-offer","title":"Phase 7: Post-Compilation Analysis Offer","text":"<p>After the spec is saved, you are offered three options:</p> <ul> <li>\"Yes, analyze it\" -- Launches the spec analyzer agent immediately</li> <li>\"Yes, clear context first\" -- Provides instructions to clear the conversation and run analysis with a fresh context window</li> <li>\"No, I'm done\" -- Ends the workflow</li> </ul> <p>Early Exit</p> <p>You can wrap up the interview early at any time. The skill will generate a spec from whatever information has been gathered and mark it as <code>Draft (Partial)</code>.</p>"},{"location":"plugins/sdd-workflow/#step-2-analyze-spec","title":"Step 2: Analyze Spec","text":"<p>Skill: <code>/sdd:analyze-spec specs/SPEC-{name}.md</code> Output: <code>specs/SPEC-{name}.analysis.md</code> + <code>specs/SPEC-{name}.analysis.html</code> Status: Optional but recommended</p> <p>The <code>analyze-spec</code> skill performs a comprehensive quality review of an existing specification, identifying inconsistencies, missing information, ambiguities, and structural issues. It launches the <code>spec-analyzer</code> agent to conduct a systematic 5-phase analysis.</p>"},{"location":"plugins/sdd-workflow/#analysis-pipeline","title":"Analysis Pipeline","text":"<pre><code>graph LR\n    A[\"Read &amp; Detect\\nDepth Level\"] --&gt; B[\"Load Criteria\\nfor Depth\"]\n    B --&gt; C[\"Systematic\\nScan\"]\n    C --&gt; D[\"Categorize\\n&amp; Prioritize\"]\n    D --&gt; E[\"Generate\\nReports\"]\n    E --&gt; F[\"Interactive\\nResolution\"]</code></pre>"},{"location":"plugins/sdd-workflow/#analysis-categories","title":"Analysis Categories","text":"<p>The analyzer scans for four categories of issues:</p> Category What It Catches Inconsistencies Feature naming conflicts, priority mismatches, contradictory requirements, metric/goal misalignment Missing Information Absent required sections, undefined terms, features without acceptance criteria, unlisted dependencies Ambiguities Vague quantifiers (\"fast\", \"scalable\"), undefined priority language, ambiguous pronouns, open-ended lists Structure Issues Missing sections for depth level, misplaced content, inconsistent formatting, orphaned references"},{"location":"plugins/sdd-workflow/#severity-levels","title":"Severity Levels","text":"<p>Each finding is assigned a severity:</p> Severity Meaning Example Critical Would cause implementation failure \"Auth required\" but no auth requirements defined Warning Could cause confusion or problems \"Search should be fast\" without defining \"fast\" Suggestion Would improve quality but not blocking Inconsistent user story formatting <p>Depth-Aware Analysis</p> <p>The analyzer respects the spec's depth level. A high-level spec will not be flagged for missing API specifications, and a detailed spec will not be expected to include data model schemas. Only issues appropriate to the document's depth are reported.</p>"},{"location":"plugins/sdd-workflow/#report-outputs","title":"Report Outputs","text":"<p>Markdown Report (<code>.analysis.md</code>): A structured report with summary statistics, findings organized by severity, and an overall assessment.</p> <p>Interactive HTML Review (<code>.analysis.html</code>): A self-contained HTML file you can open in any browser. It provides:</p> <ul> <li>Side-by-side spec content and findings panels</li> <li>Severity and status filtering</li> <li>Approve/reject buttons per finding</li> <li>Comment fields for notes</li> <li>A \"Copy Prompt\" button that generates a natural language prompt you can paste back into Claude Code to apply approved changes</li> </ul>"},{"location":"plugins/sdd-workflow/#resolution-modes","title":"Resolution Modes","text":"<p>After analysis completes, you choose how to address findings:</p> Interactive HTML Review (Recommended)CLI Update ModeReports Only <ol> <li>Open the <code>.analysis.html</code> file in your browser</li> <li>Review findings -- click to expand details</li> <li>Click Approve or Reject on each finding</li> <li>Add optional comments</li> <li>Click Copy Prompt to copy a natural language change request</li> <li>Paste the prompt back into Claude Code to apply approved changes</li> </ol> <p>Walk through each finding interactively in the terminal:</p> <ul> <li>Apply -- Use the proposed fix</li> <li>Modify -- Provide your own text</li> <li>Skip -- Leave as-is (with optional reason)</li> </ul> <p>Progress is tracked: <code>Finding 3/12 (2 resolved, 1 skipped)</code></p> <p>Keep both report files as reference without making any changes to the spec. Useful for team review before editing.</p>"},{"location":"plugins/sdd-workflow/#step-3-create-tasks","title":"Step 3: Create Tasks","text":"<p>Skill: <code>/sdd:create-tasks specs/SPEC-{name}.md</code> Output: Tasks in <code>~/.claude/tasks/{listId}/</code></p> <p>The <code>create-tasks</code> skill transforms a specification into actionable Claude Code Tasks with acceptance criteria, testing requirements, dependency relationships, and metadata for traceability back to the spec.</p>"},{"location":"plugins/sdd-workflow/#8-phase-workflow","title":"8-Phase Workflow","text":"<pre><code>graph TD\n    P1[\"Phase 1: Validate &amp; Load\"] --&gt; P2[\"Phase 2: Detect Depth\\n&amp; Check Existing\"]\n    P2 --&gt; P3[\"Phase 3: Analyze Spec\"]\n    P3 --&gt; P4[\"Phase 4: Decompose Tasks\"]\n    P4 --&gt; P5[\"Phase 5: Infer Dependencies\"]\n    P5 --&gt; P6[\"Phase 6: Preview &amp; Confirm\"]\n    P6 --&gt; P7[\"Phase 7: Create Tasks\"]\n    P7 --&gt; P8[\"Phase 8: Error Handling\"]</code></pre>"},{"location":"plugins/sdd-workflow/#task-granularity-by-depth","title":"Task Granularity by Depth","text":"<p>The number of tasks generated scales with the spec's depth level:</p> Depth Tasks per Feature Decomposition Style Example High-Level 1-2 Feature-level deliverables \"Implement user authentication\" Detailed 3-5 Functional decomposition \"Implement login endpoint\", \"Add password validation\" Full-Tech 5-10 Technical decomposition \"Create User model\", \"Implement POST /auth/login\", \"Add auth middleware\""},{"location":"plugins/sdd-workflow/#task-decomposition-pattern","title":"Task Decomposition Pattern","text":"<p>Each feature is decomposed following a standard layer pattern:</p> <pre><code>1. Data Model Tasks       \u2192 \"Create {Entity} data model\"\n2. API/Service Tasks      \u2192 \"Implement {endpoint} endpoint\"\n3. Business Logic Tasks   \u2192 \"Implement {feature} business logic\"\n4. UI/Frontend Tasks      \u2192 \"Build {feature} UI component\"\n5. Test Tasks             \u2192 \"Add tests for {feature}\"\n</code></pre>"},{"location":"plugins/sdd-workflow/#task-structure","title":"Task Structure","text":"<p>Every generated task includes:</p> <ul> <li>Subject: Imperative mood (\"Create User data model\")</li> <li>Active form: Present continuous (\"Creating User data model\")</li> <li>Description: What needs to be done, technical details, and categorized acceptance criteria</li> <li>Acceptance criteria: Grouped into Functional, Edge Cases, Error Handling, and Performance</li> <li>Testing requirements: Inferred from task type + extracted from spec</li> <li>Source reference: Spec path and section number for traceability</li> <li>Metadata: Priority, complexity, feature name, task UID, task group</li> </ul>"},{"location":"plugins/sdd-workflow/#dependency-inference","title":"Dependency Inference","text":"<p>Dependencies are automatically inferred using three mechanisms:</p> <p>Layer dependencies:</p> <pre><code>Data Model \u2192 API \u2192 UI \u2192 Tests\n</code></pre> <p>Phase dependencies (from spec implementation plan):</p> <pre><code>Phase 1 tasks \u2190 Phase 2 tasks \u2190 Phase 3 tasks\n</code></pre> <p>Cross-feature dependencies:</p> <ul> <li>Shared data models: both features depend on model creation</li> <li>Shared services: both features depend on service implementation</li> <li>Auth: all protected features depend on auth setup</li> </ul> <p>Explicit Overrides</p> <p>Explicit dependencies from Section 10 of the spec always override inferred dependencies. The skill also detects circular dependencies and breaks them at the weakest link.</p>"},{"location":"plugins/sdd-workflow/#task-uids-and-merge-mode","title":"Task UIDs and Merge Mode","text":"<p>Each task receives a unique identifier in the format:</p> <pre><code>{spec_path}:{feature_slug}:{task_type}:{sequence}\n</code></pre> <p>For example: <code>specs/SPEC-Auth.md:user-auth:api-login:001</code></p> <p>When you re-run <code>create-tasks</code> on a spec that already has tasks, the skill enters merge mode:</p> Existing Task Status Merge Behavior <code>pending</code> Update description if spec changed <code>in_progress</code> Preserve status, optionally update description <code>completed</code> Never modified Not in spec Flagged as potentially obsolete -- you decide to keep or remove"},{"location":"plugins/sdd-workflow/#preview-and-confirmation","title":"Preview and Confirmation","text":"<p>Before creating any tasks, you see a summary:</p> <pre><code>\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\nTASK GENERATION PREVIEW\n\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\nSpec: User Authentication\nDepth: Detailed\n\nSUMMARY:\n\u2022 Total tasks: 14\n\u2022 By priority: 3 critical, 5 high, 4 medium, 2 low\n\u2022 By complexity: 2 XS, 4 S, 5 M, 2 L, 1 XL\n\nFEATURES:\n\u2022 User Registration \u2192 4 tasks\n\u2022 Login/Logout \u2192 5 tasks\n\u2022 Session Management \u2192 3 tasks\n\u2022 Password Reset \u2192 2 tasks\n\nDEPENDENCIES:\n\u2022 18 dependency relationships inferred\n\u2022 Longest chain: 5 tasks\n\nFIRST TASKS (no blockers):\n\u2022 Create User data model (critical)\n\u2022 Create Session data model (critical)\n\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\n</code></pre> <p>You can request full task details before confirming creation.</p>"},{"location":"plugins/sdd-workflow/#step-4-execute-tasks","title":"Step 4: Execute Tasks","text":"<p>Skill: <code>/sdd:execute-tasks</code> Output: <code>.claude/sessions/__live_session__/</code> (then archived to <code>.claude/sessions/{session-id}/</code>)</p> <p>The <code>execute-tasks</code> skill is the most complex component in the SDD pipeline. It orchestrates autonomous, wave-based parallel execution of tasks with dependency resolution, retry logic, shared execution context, and session management.</p>"},{"location":"plugins/sdd-workflow/#10-step-orchestration","title":"10-Step Orchestration","text":"<pre><code>graph TD\n    S1[\"Step 1: Load Task List\"] --&gt; S2[\"Step 2: Validate State\"]\n    S2 --&gt; S3[\"Step 3: Build Execution Plan\"]\n    S3 --&gt; S4[\"Step 4: Check Settings\"]\n    S4 --&gt; S5[\"Step 5: Initialize Session\"]\n    S5 --&gt; S6[\"Step 6: Present Plan &amp; Confirm\"]\n    S6 --&gt; S7[\"Step 7: Initialize Context\"]\n    S7 --&gt; S8[\"Step 8: Execute Loop\"]\n    S8 --&gt; S9[\"Step 9: Session Summary\"]\n    S9 --&gt; S10[\"Step 10: Update CLAUDE.md\"]\n\n    subgraph ExecuteLoop[\"Step 8: Wave-Based Execution\"]\n        W1[\"Initialize Wave\"] --&gt; W2[\"Snapshot Context\"]\n        W2 --&gt; W3[\"Launch Agents\\n(parallel)\"]\n        W3 --&gt; W4[\"Process Results\"]\n        W4 --&gt; W5[\"Within-Wave Retry\"]\n        W5 --&gt; W6[\"Merge Context\"]\n        W6 --&gt; W7[\"Rebuild Next Wave\"]\n        W7 --&gt;|\"More waves\"| W1\n    end</code></pre>"},{"location":"plugins/sdd-workflow/#wave-based-concurrent-execution","title":"Wave-Based Concurrent Execution","text":"<p>Tasks are organized into waves based on their dependency relationships:</p> <ul> <li>Wave 1: All tasks with no dependencies (can run immediately)</li> <li>Wave 2: Tasks whose dependencies are all in Wave 1</li> <li>Wave 3: Tasks whose dependencies are all in Wave 1 or Wave 2</li> <li>And so on...</li> </ul> <p>Within each wave, tasks run simultaneously (up to <code>max_parallel</code> concurrent agents). Tasks are sorted by priority within each wave: critical first, then high, medium, low.</p> <pre><code>Wave 1: [Create User model] [Create Session model]     \u2190 parallel\n            \u2193                       \u2193\nWave 2: [Implement login API] [Implement register API]  \u2190 parallel, after Wave 1\n            \u2193                       \u2193\nWave 3: [Build login UI] [Build register UI]            \u2190 parallel, after Wave 2\n            \u2193               \u2193\nWave 4: [Add E2E tests]                                 \u2190 after Wave 3\n</code></pre>"},{"location":"plugins/sdd-workflow/#configurable-parallelism","title":"Configurable Parallelism","text":"Source Setting Precedence CLI argument <code>--max-parallel 3</code> Highest Settings file <code>max_parallel</code> in <code>.claude/claude-alchemy.local.md</code> Medium Default 5 Lowest <p>Set <code>--max-parallel 1</code> for sequential execution (no concurrency).</p>"},{"location":"plugins/sdd-workflow/#task-executor-agent-4-phase-workflow","title":"Task Executor Agent (4-Phase Workflow)","text":"<p>Each task is executed by a dedicated <code>task-executor</code> agent that follows a strict 4-phase workflow:</p> Phase 1: UnderstandPhase 2: ImplementPhase 3: VerifyPhase 4: Complete <ul> <li>Read the execute-tasks skill and reference files</li> <li>Read shared <code>execution_context.md</code> for learnings from prior tasks</li> <li>Load task details and classify as spec-generated or general</li> <li>Parse acceptance criteria or infer requirements from description</li> <li>Explore affected files using Glob/Grep/Read</li> <li>Read <code>CLAUDE.md</code> for project conventions</li> </ul> <ul> <li>Read all target files before modifying them</li> <li>Follow dependency order: data layer, service layer, interface layer, tests</li> <li>Match existing coding patterns and conventions</li> <li>Write tests if specified in testing requirements</li> <li>Run mid-implementation checks (linter, existing tests) to catch issues early</li> </ul> <p>Spec-generated tasks: Walk each acceptance criteria category:</p> <ul> <li>Functional (ALL must pass for PASS)</li> <li>Edge Cases (flagged but don't block)</li> <li>Error Handling (flagged but don't block)</li> <li>Performance (flagged but don't block)</li> <li>Run full test suite</li> </ul> <p>General tasks: Verify core change works, no test regressions, no linter violations.</p> <ul> <li>Determine status: PASS, PARTIAL, or FAIL</li> <li>If PASS: mark task as <code>completed</code></li> <li>If PARTIAL/FAIL: leave as <code>in_progress</code> for retry or manual review</li> <li>Append learnings to execution context (files modified, patterns discovered, issues hit)</li> <li>Return structured verification report</li> </ul>"},{"location":"plugins/sdd-workflow/#verification-status-rules","title":"Verification Status Rules","text":"Condition Status Task Updated? All Functional pass + Tests pass PASS Marked <code>completed</code> All Functional pass + Tests pass + Edge/Error/Perf issues PARTIAL Left as <code>in_progress</code> Any Functional criteria fail FAIL Left as <code>in_progress</code> Any test failure FAIL Left as <code>in_progress</code>"},{"location":"plugins/sdd-workflow/#retry-logic","title":"Retry Logic","text":"<p>Failed tasks are retried up to 3 times by default (configurable with <code>--retries</code>):</p> <ul> <li>Retries happen immediately within the current wave -- no waiting for other agents</li> <li>Each retry receives the previous attempt's failure details and recommendations</li> <li>The agent checks for partial changes from previous attempts before retrying</li> <li>After retries are exhausted, the task stays as <code>in_progress</code> and execution continues</li> </ul>"},{"location":"plugins/sdd-workflow/#shared-execution-context","title":"Shared Execution Context","text":"<p>Tasks share knowledge through <code>.claude/sessions/__live_session__/execution_context.md</code>:</p> Section Contents Project Patterns Coding patterns, conventions, tech stack details Key Decisions Architecture choices made during execution Known Issues Problems encountered, workarounds applied File Map Important files discovered and their purposes Task History Brief log of task outcomes with relevant context <p>During concurrent execution, write contention is avoided through per-task context files (<code>context-task-{id}.md</code>). These are merged into the shared context after each wave completes.</p>"},{"location":"plugins/sdd-workflow/#session-management","title":"Session Management","text":"<p>Lock file: A <code>.lock</code> file in <code>__live_session__/</code> prevents concurrent execution sessions. Stale locks older than 4 hours auto-expire.</p> <p>Interrupted recovery: If a previous session was interrupted, stale files are archived to <code>.claude/sessions/interrupted-{timestamp}/</code> and any <code>in_progress</code> tasks are automatically reset to <code>pending</code>.</p> <p>Session archival: After execution completes, all session artifacts are moved from <code>__live_session__/</code> to <code>.claude/sessions/{task_execution_id}/</code> for historical reference.</p>"},{"location":"plugins/sdd-workflow/#session-files","title":"Session Files","text":"File Purpose <code>execution_plan.md</code> The wave-based plan showing task ordering <code>execution_context.md</code> Shared knowledge base across tasks <code>task_log.md</code> Table of task results with duration and token usage <code>progress.md</code> Real-time status for the Task Manager to display <code>session_summary.md</code> Final execution results (created at completion) <code>.lock</code> Concurrency guard <code>tasks/</code> Archive of completed task JSON files"},{"location":"plugins/sdd-workflow/#usage-examples","title":"Usage Examples","text":"<pre><code># Execute all unblocked tasks (default: 5 parallel, 3 retries)\n/sdd:execute-tasks\n\n# Execute a specific task by ID\n/sdd:execute-tasks 5\n\n# Execute only tasks from a specific spec\n/sdd:execute-tasks --task-group user-authentication\n\n# Limit parallelism\n/sdd:execute-tasks --max-parallel 2\n\n# Sequential execution (no concurrency)\n/sdd:execute-tasks --max-parallel 1\n\n# Custom retry limit\n/sdd:execute-tasks --retries 1\n\n# Combine options\n/sdd:execute-tasks --task-group payments --max-parallel 3 --retries 1\n</code></pre>"},{"location":"plugins/sdd-workflow/#monitoring-execution","title":"Monitoring Execution","text":"<p>The Task Manager web application provides real-time visibility into task execution.</p>"},{"location":"plugins/sdd-workflow/#setup","title":"Setup","text":"<pre><code># Start the Task Manager (from the monorepo root)\npnpm dev:task-manager\n</code></pre> <p>Then open http://localhost:3030 in your browser.</p>"},{"location":"plugins/sdd-workflow/#what-you-see","title":"What You See","text":"<p>The Task Manager displays:</p> <ol> <li> <p>Kanban Board -- Three-column view (Pending, In Progress, Completed) showing all tasks with their priority, complexity, and dependency information. Updates in real-time as the <code>execute-tasks</code> skill progresses.</p> </li> <li> <p>Execution Progress Bar -- Shows the current wave number, active tasks count, and overall completion percentage.</p> </li> <li> <p>Execution Dialog -- Click to expand and see:</p> <ul> <li>Execution Plan: The wave-based plan with task ordering</li> <li>Progress: Current wave status and active tasks</li> <li>Execution Context: Shared knowledge accumulated across tasks</li> <li>Task Log: Table of completed tasks with status, duration, and token usage</li> </ul> </li> </ol>"},{"location":"plugins/sdd-workflow/#real-time-data-flow","title":"Real-Time Data Flow","text":"<pre><code>sequenceDiagram\n    participant SDD as execute-tasks\n    participant FS as Filesystem\n    participant CK as Chokidar\n    participant SSE as SSE Endpoint\n    participant UI as Task Manager\n\n    SDD-&gt;&gt;FS: Update task status\n    SDD-&gt;&gt;FS: Update progress.md\n    CK--&gt;&gt;FS: Detect changes (300ms)\n    CK-&gt;&gt;SSE: Emit events\n    SSE-&gt;&gt;UI: Stream via SSE\n    UI-&gt;&gt;UI: Invalidate cache\n    UI-&gt;&gt;UI: Re-render</code></pre> <p>The Task Manager watches <code>~/.claude/tasks/</code> for task file changes and <code>.claude/sessions/__live_session__/</code> for execution artifacts via a Chokidar file watcher, streaming updates to the browser through Server-Sent Events.</p> <p>Task Manager is read-only</p> <p>The Task Manager never writes to the filesystem. It is a pure consumer of data produced by the SDD plugin. You can safely open and close it at any point during execution without affecting the running session.</p>"},{"location":"plugins/sdd-workflow/#end-to-end-example","title":"End-to-End Example","text":"<p>Here is a complete walkthrough of building a user authentication feature using the SDD pipeline:</p>"},{"location":"plugins/sdd-workflow/#1-create-the-spec","title":"1. Create the Spec","text":"<pre><code>/sdd:create-spec\n</code></pre> <ul> <li>Name: User Authentication</li> <li>Type: New feature</li> <li>Depth: Detailed specifications</li> <li>Description: Add email/password authentication with login, registration, password reset, and session management</li> </ul> <p>The interview covers functional requirements, security considerations, and technical constraints across 3-4 rounds. The skill detects security-related triggers and offers recommendations for bcrypt hashing, rate limiting, and CSRF protection.</p> <p>Output: <code>specs/SPEC-User-Authentication.md</code></p>"},{"location":"plugins/sdd-workflow/#2-analyze-the-spec","title":"2. Analyze the Spec","text":"<pre><code>/sdd:analyze-spec specs/SPEC-User-Authentication.md\n</code></pre> <p>The analyzer detects the spec is at \"Detailed\" depth and runs a full quality scan. It finds 8 findings: 1 critical (missing session expiry requirement), 3 warnings (vague performance targets), and 4 suggestions (formatting improvements).</p> <p>You open the <code>.analysis.html</code> file in your browser, approve all findings, click \"Copy Prompt\", and paste it back to apply changes.</p> <p>Output: Updated <code>specs/SPEC-User-Authentication.md</code></p>"},{"location":"plugins/sdd-workflow/#3-create-tasks","title":"3. Create Tasks","text":"<pre><code>/sdd:create-tasks specs/SPEC-User-Authentication.md\n</code></pre> <p>The skill decomposes the spec into 14 tasks across 4 features, infers 18 dependency relationships, and identifies the longest dependency chain (5 tasks). You review the preview and confirm.</p> <p>Output: 14 tasks in <code>~/.claude/tasks/{listId}/</code></p>"},{"location":"plugins/sdd-workflow/#4-execute-tasks","title":"4. Execute Tasks","text":"<pre><code># In a separate terminal, start the Task Manager\npnpm dev:task-manager\n\n# Back in Claude Code\n/sdd:execute-tasks --task-group user-authentication\n</code></pre> <p>Execution proceeds in 4 waves:</p> <ul> <li>Wave 1: Create User model, Create Session model (2 parallel)</li> <li>Wave 2: Implement login API, Implement register API, Create auth middleware (3 parallel)</li> <li>Wave 3: Build login UI, Build register UI, Add route protection (3 parallel)</li> <li>Wave 4: Integration tests, E2E tests (2 parallel)</li> </ul> <p>The Task Manager at <code>localhost:3030</code> shows progress in real-time. After completion, a session summary reports 14/14 tasks passed, and <code>CLAUDE.md</code> is updated with any new project-wide patterns discovered during execution.</p>"},{"location":"plugins/sdd-workflow/#related-pages","title":"Related Pages","text":"<ul> <li>Architecture Overview -- System architecture and design decisions</li> <li>Filesystem Message Bus -- How subsystems communicate through files</li> <li>Task Manager Overview -- Task Manager features and setup</li> <li>Real-Time System -- How real-time updates flow from files to UI</li> </ul>"},{"location":"plugins/tools-plugin/","title":"Tools Plugin","text":""},{"location":"plugins/tools-plugin/#tools-plugin","title":"Tools Plugin","text":"<p>claude-alchemy-tools v0.2.2 --- General developer skills and agents for codebase analysis, feature development, documentation management, Git workflows, and release automation.</p>"},{"location":"plugins/tools-plugin/#overview","title":"Overview","text":"<p>The Tools Plugin provides 8 user-invocable skills, 5 supporting skills, and 10 specialized agents that work together to automate common development workflows. Skills orchestrate agents via the Task tool with model tiering --- lightweight tasks run on Haiku, exploration on Sonnet, and synthesis/architecture/review work on Opus.</p> <pre><code>graph TD\n    subgraph \"User-Invocable Skills\"\n        FD[feature-dev]\n        CA[codebase-analysis]\n        DA[deep-analysis]\n        TDA[teams-deep-analysis]\n        DM[docs-manager]\n        GC[git-commit]\n        BPV[bump-plugin-version]\n        REL[release]\n    end\n\n    subgraph \"Agents\"\n        CE[code-explorer]\n        TCE[team-code-explorer]\n        CAR[code-architect]\n        CR[code-reviewer]\n        CS[codebase-synthesizer]\n        TCS[team-codebase-synthesizer]\n        TDNA[team-deep-analyst]\n        CHA[changelog-agent]\n        DW[docs-writer]\n        RES[researcher]\n    end\n\n    FD --&gt; CE\n    FD --&gt; CS\n    FD --&gt; CAR\n    FD --&gt; CR\n    CA --&gt; CE\n    CA --&gt; CS\n    DA --&gt; CE\n    DA --&gt; CS\n    TDA --&gt; TCE\n    TDA --&gt; TCS\n    TDA --&gt; TDNA\n    DM --&gt; CE\n    DM --&gt; CS\n    DM --&gt; DW\n    REL --&gt; CHA</code></pre>"},{"location":"plugins/tools-plugin/#installation","title":"Installation","text":"<p>The plugin is located at <code>plugins/tools/</code> within the Claude Alchemy monorepo. It requires no build step --- skills are Markdown files with YAML frontmatter, and agents are standalone Markdown definitions.</p> <p>All skills are invoked with the <code>/tools:</code> prefix:</p> <pre><code>/tools:skill-name [arguments]\n</code></pre>"},{"location":"plugins/tools-plugin/#user-invocable-skills","title":"User-Invocable Skills","text":"<p>These skills are triggered directly by the user via the <code>/tools:</code> prefix.</p>"},{"location":"plugins/tools-plugin/#feature-dev","title":"feature-dev","text":"<p>Model: inherit | Invocation: <code>/tools:feature-dev &lt;feature-description&gt; [--teams]</code></p> <p>A comprehensive 7-phase feature development workflow that guides a feature from understanding through implementation and review.</p> <p>Phases:</p> # Phase Description 1 Discovery Analyze feature requirements and confirm understanding with the user 2 Codebase Exploration Run <code>deep-analysis</code> (or <code>teams-deep-analysis</code> with <code>--teams</code>) to map relevant code 3 Clarifying Questions Resolve ambiguities that would impact implementation 4 Architecture Design Launch 2--3 <code>code-architect</code> agents with different approaches, present trade-offs, user selects, and an ADR is generated 5 Implementation Build the feature following the chosen architecture design 6 Quality Review Launch 3 <code>code-reviewer</code> agents (correctness, security, maintainability) with confidence-scored findings (&gt;=80 threshold) 7 Summary Document accomplishments and update CHANGELOG.md <p>Agents spawned: <code>code-explorer</code> (Sonnet), <code>codebase-synthesizer</code> (Opus), <code>code-architect</code> (Opus), <code>code-reviewer</code> (Opus)</p> <p>Supporting skills loaded: <code>project-conventions</code>, <code>language-patterns</code>, <code>architecture-patterns</code>, <code>code-quality</code>, <code>changelog-format</code></p> <p>Usage</p> <pre><code>/tools:feature-dev Add OAuth2 login flow with Google and GitHub providers\n/tools:feature-dev Add dark mode toggle --teams\n</code></pre>"},{"location":"plugins/tools-plugin/#codebase-analysis","title":"codebase-analysis","text":"<p>Model: inherit | Invocation: <code>/tools:codebase-analysis &lt;analysis-context&gt; [--teams]</code></p> <p>A 3-phase structured codebase analysis workflow that explores the codebase, presents a detailed report, and offers post-analysis actions.</p> <p>Phases:</p> # Phase Description 1 Deep Analysis Run <code>deep-analysis</code> (or <code>teams-deep-analysis</code> with <code>--teams</code>) for exploration and synthesis 2 Reporting Present structured report: executive summary, architecture overview, critical files, patterns, risks, recommendations 3 Post-Analysis Actions Multi-select menu: save report, update README/CLAUDE.md, retain summary in memory, address actionable insights <p>The post-analysis \"Address Actionable Insights\" action extracts challenges and recommendations from the report, ranks them by severity, and lets the user select which ones to fix --- spawning <code>code-architect</code> or <code>code-explorer</code> agents as needed for complex items.</p> <p>Agents spawned: <code>code-explorer</code> (Sonnet), <code>codebase-synthesizer</code> (Opus)</p> <p>Usage</p> <pre><code>/tools:codebase-analysis authentication and authorization flow\n/tools:codebase-analysis --teams\n</code></pre>"},{"location":"plugins/tools-plugin/#deep-analysis","title":"deep-analysis","text":"<p>Model: inherit | Invocation: <code>/tools:deep-analysis &lt;analysis-context&gt;</code></p> <p>A reusable exploration and synthesis building block. Launches parallel <code>code-explorer</code> agents to investigate distinct focus areas, then merges findings with a <code>codebase-synthesizer</code> agent. Other skills (like <code>feature-dev</code> and <code>codebase-analysis</code>) load this skill as an internal workflow step.</p> <p>Workflow:</p> <ol> <li>Determine focus areas (2--3 agents depending on scope)</li> <li>Launch <code>code-explorer</code> agents in parallel with distinct focus areas</li> <li>Wait for all explorers to complete</li> <li>Launch <code>codebase-synthesizer</code> to merge, deduplicate, and deepen the analysis</li> <li>Return synthesized results (standalone: present to user; loaded by another skill: return control)</li> </ol> <p>Agents spawned: <code>code-explorer</code> (Sonnet, 2--3 instances), <code>codebase-synthesizer</code> (Opus)</p> <p>Supporting skills loaded: <code>project-conventions</code>, <code>language-patterns</code></p> <p>Usage</p> <pre><code>/tools:deep-analysis real-time data synchronization layer\n/tools:deep-analysis\n</code></pre>"},{"location":"plugins/tools-plugin/#teams-deep-analysis","title":"teams-deep-analysis","text":"<p>Model: inherit | Invocation: <code>/tools:teams-deep-analysis &lt;analysis-context&gt;</code></p> <p>A team-based variant of <code>deep-analysis</code> that uses Agent Teams for inter-agent collaboration. Explorers share discoveries with each other via <code>SendMessage</code> as they work, the synthesizer can ask explorers follow-up questions, and a deep analyst agent is available on demand for complex cross-cutting investigations.</p> <p>Phases:</p> # Phase Description 1 Team Setup Create team, spawn 5 teammates (3 explorers + 1 synthesizer + 1 analyst), create and assign tasks with dependencies 2 Collaborative Exploration Explorers work in parallel, proactively sharing discoveries with each other 3 Lead Checkpoint + Synthesis Verify exploration completeness, launch synthesizer with access to all explorers and the deep analyst 4 Completion + Cleanup Collect results, present or return, shut down all teammates, delete team <p>Agents spawned: <code>team-code-explorer</code> (Sonnet, 3 instances), <code>team-codebase-synthesizer</code> (Opus), <code>team-deep-analyst</code> (Opus)</p> <p>Supporting skills loaded: <code>project-conventions</code>, <code>language-patterns</code></p> <p>When to use teams</p> <p>Use the <code>--teams</code> flag (or invoke this skill directly) when analyzing large or complex codebases where inter-agent collaboration and follow-up questions would improve analysis depth. For simpler codebases, the standard <code>deep-analysis</code> is faster and uses fewer resources.</p> <p>Usage</p> <pre><code>/tools:teams-deep-analysis microservices communication patterns\n</code></pre>"},{"location":"plugins/tools-plugin/#docs-manager","title":"docs-manager","text":"<p>Model: inherit | Invocation: <code>/tools:docs-manager &lt;action-or-description&gt; [--teams]</code></p> <p>A 6-phase documentation management workflow that supports three documentation formats and multiple action types.</p> <p>Supported documentation types:</p> Type Output Examples MkDocs site Material for MkDocs pages under <code>docs/</code> API reference, architecture guides, getting started Basic Markdown Standalone GFM files README.md, CONTRIBUTING.md, ARCHITECTURE.md Change Summary Changelog entries, release notes Markdown changelog, commit message, MkDocs page <p>Phases:</p> # Phase Description 1 Interactive Discovery Determine doc type, format, and scope through user interaction 2 Project Detection &amp; Setup Detect project metadata, check existing docs, conditionally scaffold MkDocs 3 Codebase Analysis Run <code>deep-analysis</code> for documentation-focused exploration (skipped for change summaries) 4 Documentation Planning Translate findings into a concrete plan with page list, outlines, and nav structure 5 Documentation Generation Launch <code>docs-writer</code> agents --- parallel for independent pages, sequential for dependent pages 6 Integration &amp; Finalization Write files, validate cross-references, present results <p>Agents spawned: <code>code-explorer</code> (Sonnet), <code>codebase-synthesizer</code> (Opus), <code>docs-writer</code> (Opus)</p> <p>Reference materials: <code>mkdocs-config-template.md</code>, <code>change-summary-templates.md</code>, <code>markdown-file-templates.md</code></p> <p>Usage</p> <pre><code>/tools:docs-manager create MkDocs documentation site\n/tools:docs-manager write README and CONTRIBUTING\n/tools:docs-manager changelog since last tag\n/tools:docs-manager update API docs --teams\n</code></pre>"},{"location":"plugins/tools-plugin/#git-commit","title":"git-commit","text":"<p>Model: haiku | Invocation: <code>/tools:git-commit</code></p> <p>Stages all changes, analyzes the diff, and generates a conventional commit message. Runs on Haiku for speed and cost efficiency.</p> <p>Workflow:</p> <ol> <li>Check repository state (<code>git status</code>)</li> <li>Stage all changes (<code>git add .</code>)</li> <li>Analyze the staged diff to determine type, scope, and description</li> <li>Construct a conventional commit message (imperative mood, lowercase, under 72 characters)</li> <li>Create the commit</li> <li>Report the result (or handle pre-commit hook failures)</li> </ol> <p>Commit types: <code>feat</code>, <code>fix</code>, <code>docs</code>, <code>style</code>, <code>refactor</code>, <code>test</code>, <code>chore</code>, <code>build</code>, <code>ci</code>, <code>perf</code></p> <p>Stages all changes</p> <p>This skill runs <code>git add .</code> before committing. All untracked files and modifications will be included. Review your working directory before invoking.</p> <p>Usage</p> <pre><code>/tools:git-commit\n</code></pre>"},{"location":"plugins/tools-plugin/#bump-plugin-version","title":"bump-plugin-version","text":"<p>Model: haiku | Invocation: <code>/tools:bump-plugin-version</code></p> <p>Discovers all plugins in the repository, prompts the user to select one and choose a bump level, then updates both the plugin's <code>plugin.json</code> and the root <code>marketplace.json</code>.</p> <p>Workflow:</p> <ol> <li>Discover plugins by scanning <code>plugins/*/</code> directories</li> <li>Present plugins with current versions for user selection</li> <li>Prompt for bump level: patch, minor, or major</li> <li>Calculate the new version using semver rules</li> <li>Update <code>plugins/{name}/.claude-plugin/plugin.json</code></li> <li>Update <code>.claude-plugin/marketplace.json</code></li> </ol> <p>Usage</p> <pre><code>/tools:bump-plugin-version\n</code></pre>"},{"location":"plugins/tools-plugin/#release","title":"release","text":"<p>Model: haiku | Invocation: <code>/tools:release [version-override]</code></p> <p>A Python release workflow with pre-flight checks, automated tests, version calculation from CHANGELOG.md, and git tag creation. Uses <code>uv</code> and <code>ruff</code> for Python tooling.</p> <p>Workflow (9 steps, fail-fast):</p> # Step Description 1 Pre-flight Checks Must be on <code>main</code>, clean working directory, pull latest 2 Run Tests <code>uv run pytest</code> 3 Run Linting <code>uv run ruff check</code> and <code>uv run ruff format --check</code> 4 Verify Build <code>uv build</code> 5 Changelog Update Check Optionally spawn <code>changelog-agent</code> to update <code>[Unreleased]</code> section 6 Calculate Version Parse CHANGELOG.md, apply semver rules based on change types, user confirms 7 Update CHANGELOG.md Move <code>[Unreleased]</code> entries to new version section with date and comparison links 8 Commit Changelog Stage, commit, and push the changelog update 9 Create and Push Tag Annotated tag <code>v{version}</code>, push to remote <p>Agents spawned (optional): <code>changelog-agent</code></p> <p>Usage</p> <pre><code>/tools:release\n/tools:release 2.0.0\n</code></pre>"},{"location":"plugins/tools-plugin/#supporting-skills","title":"Supporting Skills","text":"<p>These skills are not directly invocable by the user. They are loaded at runtime by other skills to provide domain knowledge and guidance.</p>"},{"location":"plugins/tools-plugin/#architecture-patterns","title":"architecture-patterns","text":"<p>Provides architectural pattern knowledge including MVC, event-driven, layered, microservices, and CQRS patterns. Includes a pattern selection guide based on existing architecture, team familiarity, feature requirements, and scale.</p> <p>Loaded by: <code>feature-dev</code> (Phase 4: Architecture Design)</p>"},{"location":"plugins/tools-plugin/#language-patterns","title":"language-patterns","text":"<p>Provides language-specific patterns and idioms for TypeScript, Python, and React. Covers type safety, error handling, component patterns, and framework-specific best practices.</p> <p>Loaded by: <code>feature-dev</code> (Phase 4: Architecture Design), <code>deep-analysis</code> (Phase 1), <code>teams-deep-analysis</code> (Phase 1)</p>"},{"location":"plugins/tools-plugin/#project-conventions","title":"project-conventions","text":"<p>Guides discovery and application of project-specific conventions by inspecting configuration files (<code>tsconfig.json</code>, <code>pyproject.toml</code>, <code>.eslintrc</code>, etc.) and existing code patterns. Covers naming, structure, and team practices.</p> <p>Loaded by: <code>deep-analysis</code> (Phase 1), <code>teams-deep-analysis</code> (Phase 1)</p>"},{"location":"plugins/tools-plugin/#code-quality","title":"code-quality","text":"<p>Provides code quality principles including SOLID, DRY, testing strategies, and review standards. Used as a reference during code review phases.</p> <p>Loaded by: <code>feature-dev</code> (Phase 6: Quality Review)</p>"},{"location":"plugins/tools-plugin/#changelog-format","title":"changelog-format","text":"<p>Keep a Changelog specification and entry writing best practices. Covers change categories (Added, Changed, Deprecated, Removed, Fixed, Security), formatting rules, and version comparison links.</p> <p>Loaded by: <code>feature-dev</code> (Phase 7: Summary), <code>changelog-agent</code></p>"},{"location":"plugins/tools-plugin/#agents","title":"Agents","text":"<p>Agents are specialized sub-agents spawned by skills via the Task tool. Each agent has a focused role, a specific model tier, and a defined set of tools.</p>"},{"location":"plugins/tools-plugin/#code-explorer","title":"code-explorer","text":"Property Value Model Sonnet Tools Read, Glob, Grep, Bash Skills project-conventions, language-patterns <p>A codebase exploration specialist. Given a focus area and analysis context, it investigates the codebase to find relevant files, traces execution paths, maps architecture, and reports structured findings including key files, code patterns, important functions, integration points, and potential challenges.</p> <p>Exploration strategies: Start from entry points, follow the data, find similar features, map dependencies.</p> <p>Spawned by: <code>deep-analysis</code>, <code>codebase-analysis</code> (change-summary path), <code>docs-manager</code> (change-summary path)</p>"},{"location":"plugins/tools-plugin/#team-code-explorer","title":"team-code-explorer","text":"Property Value Model Sonnet Tools Read, Glob, Grep, Bash, SendMessage, TaskUpdate, TaskGet, TaskList Skills project-conventions, language-patterns <p>The team-enabled variant of <code>code-explorer</code>. Same exploration capabilities, plus the ability to proactively share significant discoveries with other explorers via <code>SendMessage</code> and respond to follow-up questions from the synthesizer.</p> <p>Communication guidelines: Shares cross-cutting patterns, shared utilities, unexpected integration points, and critical configuration. Does not broadcast routine findings.</p> <p>Spawned by: <code>teams-deep-analysis</code></p>"},{"location":"plugins/tools-plugin/#code-architect","title":"code-architect","text":"Property Value Model inherit (Opus when launched by feature-dev) Tools Read, Glob, Grep <p>Designs implementation blueprints for features. Given a feature description, exploration findings, and a design approach, it produces a detailed blueprint covering files to create/modify, code structure, data flow, API changes, error handling, risks, and testing strategy.</p> <p>Design approaches:</p> <ul> <li>Minimal/Simple --- Fewest files changed, direct implementation, good for small features</li> <li>Flexible/Extensible --- Abstractions for reuse, configuration over hardcoding, good for growing features</li> <li>Project-Aligned --- Match existing patterns exactly, follow team conventions</li> </ul> <p>Spawned by: <code>feature-dev</code> (Phase 4, 2--3 instances), <code>codebase-analysis</code> (actionable insights, complex items)</p>"},{"location":"plugins/tools-plugin/#code-reviewer","title":"code-reviewer","text":"Property Value Model inherit (Opus when launched by feature-dev) Tools Read, Glob, Grep <p>Reviews code for correctness, security, and maintainability with confidence-scored findings. Only reports issues with confidence &gt;= 80 to minimize noise.</p> <p>Review focuses:</p> <ul> <li>Correctness &amp; Edge Cases --- Logic errors, null handling, race conditions, type mismatches</li> <li>Security &amp; Error Handling --- Input validation, auth, data sanitization, error exposure</li> <li>Maintainability &amp; Code Quality --- Readability, naming, duplication, abstractions</li> </ul> <p>Confidence scoring: 90--100 = definite issue, 80--89 = very likely issue, below 80 = not reported.</p> <p>Spawned by: <code>feature-dev</code> (Phase 6, 3 instances with different focuses)</p>"},{"location":"plugins/tools-plugin/#codebase-synthesizer","title":"codebase-synthesizer","text":"Property Value Model inherit (Opus) Tools Read, Glob, Grep <p>Merges raw exploration findings from multiple <code>code-explorer</code> agents into a unified, actionable analysis. Deduplicates entries, reads critical files in depth, maps relationships between components, identifies patterns and conventions, and assesses challenges.</p> <p>Synthesis process: Merge findings, read critical files, map relationships, identify patterns, assess challenges.</p> <p>Output sections: Architecture overview, critical files with details, relationship map, patterns and conventions, challenges and risks, recommendations, open questions.</p> <p>Spawned by: <code>deep-analysis</code></p>"},{"location":"plugins/tools-plugin/#team-codebase-synthesizer","title":"team-codebase-synthesizer","text":"Property Value Model inherit (Opus) Tools Read, Glob, Grep, SendMessage, TaskUpdate, TaskGet, TaskList <p>The team-enabled variant of <code>codebase-synthesizer</code>. Same synthesis capabilities, plus the ability to ask explorers targeted follow-up questions to resolve conflicts and fill gaps, and to delegate complex investigations to the <code>team-deep-analyst</code>.</p> <p>Key differentiator: Interactive synthesis --- identifies conflicting assessments, thin coverage, and missing connections, then messages specific explorers for clarification before finalizing.</p> <p>Delegation to analyst: Cross-cutting concerns, security audits, performance investigations, architecture assessments, and conflict resolution requiring git history.</p> <p>Spawned by: <code>teams-deep-analysis</code></p>"},{"location":"plugins/tools-plugin/#team-deep-analyst","title":"team-deep-analyst","text":"Property Value Model Opus Tools Read, Glob, Grep, Bash, SendMessage, TaskUpdate, TaskGet, TaskList Skills project-conventions, language-patterns <p>An on-demand specialist analyst that activates when the <code>team-codebase-synthesizer</code> delegates complex investigations. Has Bash access for git history analysis, dependency trees, and static analysis --- capabilities the synthesizer lacks.</p> <p>Analysis capabilities:</p> <ul> <li>Cross-cutting concerns --- Trace patterns across 3+ modules</li> <li>Security audits --- End-to-end auth review, vulnerability analysis, secret handling</li> <li>Performance analysis --- N+1 queries, hot paths, bundle sizes</li> <li>Architecture assessment --- Pattern adherence, boundary violations, dependency direction</li> <li>Conflict resolution --- Use <code>git blame</code>/<code>git log</code> when explorer reports conflict</li> </ul> <p>Communication: Receives from and reports to the synthesizer only.</p> <p>Spawned by: <code>teams-deep-analysis</code></p>"},{"location":"plugins/tools-plugin/#changelog-agent","title":"changelog-agent","text":"Property Value Model inherit Tools Bash, Read, Edit, Glob, Grep, AskUserQuestion <p>Analyzes git history and updates CHANGELOG.md following the Keep a Changelog specification. Performs deep diff analysis to detect new/removed public APIs and breaking changes, enriches entries with PR/issue context via <code>gh</code> CLI, and presents categorized entries for user approval before writing.</p> <p>Detection capabilities: New public interfaces, removed interfaces (breaking), dependency changes, PR labels (<code>breaking-change</code>, <code>security</code>), conventional commit prefixes.</p> <p>Spawned by: <code>release</code> (Step 5, optional)</p>"},{"location":"plugins/tools-plugin/#docs-writer","title":"docs-writer","text":"Property Value Model inherit (Opus) Tools Read, Glob, Grep, Bash <p>Generates complete documentation pages in either MkDocs-flavored or standard GitHub-flavored Markdown. Supports API references, architecture guides, how-to guides, standalone markdown files (README, CONTRIBUTING, ARCHITECTURE), and change summaries.</p> <p>MkDocs mode features: Admonitions, tabbed content, code block titles, Mermaid diagrams.</p> <p>Basic Markdown mode features: Blockquote callouts, standard code blocks, Mermaid diagrams (GitHub-native).</p> <p>Spawned by: <code>docs-manager</code> (Phase 5)</p>"},{"location":"plugins/tools-plugin/#researcher","title":"researcher","text":"Property Value Model inherit Tools WebSearch, WebFetch, Context7 (resolve-library-id, query-docs) <p>Researches technical documentation, domain knowledge, competitive landscape, and best practices using web search and Context7 MCP tools. Prioritizes Context7 for library/framework documentation and falls back to web search for general topics.</p> <p>Research types: Library/framework docs, third-party API specs, best practices, competitive analysis, compliance/regulatory, domain knowledge.</p> <p>Spawned by: Available for use by any skill that needs external research context.</p>"},{"location":"plugins/tools-plugin/#plugin-structure","title":"Plugin Structure","text":"<pre><code>plugins/tools/\n\u251c\u2500\u2500 .claude-plugin/\n\u2502   \u2514\u2500\u2500 plugin.json              # Plugin metadata and version\n\u251c\u2500\u2500 agents/\n\u2502   \u251c\u2500\u2500 changelog-agent.md\n\u2502   \u251c\u2500\u2500 code-architect.md\n\u2502   \u251c\u2500\u2500 code-explorer.md\n\u2502   \u251c\u2500\u2500 code-reviewer.md\n\u2502   \u251c\u2500\u2500 codebase-synthesizer.md\n\u2502   \u251c\u2500\u2500 docs-writer.md\n\u2502   \u251c\u2500\u2500 researcher.md\n\u2502   \u251c\u2500\u2500 team-code-explorer.md\n\u2502   \u251c\u2500\u2500 team-codebase-synthesizer.md\n\u2502   \u2514\u2500\u2500 team-deep-analyst.md\n\u251c\u2500\u2500 skills/\n\u2502   \u251c\u2500\u2500 architecture-patterns/\n\u2502   \u2502   \u2514\u2500\u2500 SKILL.md\n\u2502   \u251c\u2500\u2500 bump-plugin-version/\n\u2502   \u2502   \u2514\u2500\u2500 SKILL.md\n\u2502   \u251c\u2500\u2500 changelog-format/\n\u2502   \u2502   \u251c\u2500\u2500 SKILL.md\n\u2502   \u2502   \u2514\u2500\u2500 references/\n\u2502   \u2502       \u2514\u2500\u2500 entry-examples.md\n\u2502   \u251c\u2500\u2500 codebase-analysis/\n\u2502   \u2502   \u251c\u2500\u2500 SKILL.md\n\u2502   \u2502   \u2514\u2500\u2500 references/\n\u2502   \u2502       \u251c\u2500\u2500 actionable-insights-template.md\n\u2502   \u2502       \u2514\u2500\u2500 report-template.md\n\u2502   \u251c\u2500\u2500 code-quality/\n\u2502   \u2502   \u2514\u2500\u2500 SKILL.md\n\u2502   \u251c\u2500\u2500 deep-analysis/\n\u2502   \u2502   \u2514\u2500\u2500 SKILL.md\n\u2502   \u251c\u2500\u2500 docs-manager/\n\u2502   \u2502   \u251c\u2500\u2500 SKILL.md\n\u2502   \u2502   \u2514\u2500\u2500 references/\n\u2502   \u2502       \u251c\u2500\u2500 change-summary-templates.md\n\u2502   \u2502       \u251c\u2500\u2500 markdown-file-templates.md\n\u2502   \u2502       \u2514\u2500\u2500 mkdocs-config-template.md\n\u2502   \u251c\u2500\u2500 feature-dev/\n\u2502   \u2502   \u251c\u2500\u2500 SKILL.md\n\u2502   \u2502   \u2514\u2500\u2500 references/\n\u2502   \u2502       \u251c\u2500\u2500 adr-template.md\n\u2502   \u2502       \u2514\u2500\u2500 changelog-entry-template.md\n\u2502   \u251c\u2500\u2500 git-commit/\n\u2502   \u2502   \u2514\u2500\u2500 SKILL.md\n\u2502   \u251c\u2500\u2500 language-patterns/\n\u2502   \u2502   \u2514\u2500\u2500 SKILL.md\n\u2502   \u251c\u2500\u2500 project-conventions/\n\u2502   \u2502   \u2514\u2500\u2500 SKILL.md\n\u2502   \u251c\u2500\u2500 release/\n\u2502   \u2502   \u2514\u2500\u2500 SKILL.md\n\u2502   \u2514\u2500\u2500 teams-deep-analysis/\n\u2502       \u2514\u2500\u2500 SKILL.md\n\u2514\u2500\u2500 README.md\n</code></pre>"},{"location":"plugins/tools-plugin/#model-tiering","title":"Model Tiering","text":"<p>The plugin uses a deliberate model tiering strategy to balance quality, speed, and cost:</p> Tier Model Used For Fast Haiku Git commits, version bumps, release automation Balanced Sonnet Codebase exploration (code-explorer agents) Deep Opus Synthesis, architecture design, code review, documentation writing, deep analysis Inherit Parent model Skills that adapt to whatever model the user is running <p>Model inheritance</p> <p>Skills with <code>model: inherit</code> run at whatever model the user's Claude Code session is using. Agents spawned by those skills may specify their own model (e.g., <code>code-explorer</code> always runs Sonnet, <code>codebase-synthesizer</code> always runs Opus regardless of the parent skill's model).</p>"},{"location":"plugins/tools-plugin/#reference-materials","title":"Reference Materials","text":"<p>Skills bundle reference materials in <code>references/</code> subdirectories that are loaded at runtime to provide templates and formatting guidance:</p> Skill Reference File Purpose <code>feature-dev</code> <code>adr-template.md</code> Architecture Decision Record template <code>feature-dev</code> <code>changelog-entry-template.md</code> Changelog entry format <code>codebase-analysis</code> <code>report-template.md</code> Structured analysis report template <code>codebase-analysis</code> <code>actionable-insights-template.md</code> Severity-ranked insight presentation <code>docs-manager</code> <code>mkdocs-config-template.md</code> MkDocs configuration scaffold <code>docs-manager</code> <code>change-summary-templates.md</code> Changelog and release note formats <code>docs-manager</code> <code>markdown-file-templates.md</code> README, CONTRIBUTING, ARCHITECTURE structures <code>changelog-format</code> <code>entry-examples.md</code> Good and poor changelog entry examples"},{"location":"task-manager/api-reference/","title":"API Reference","text":""},{"location":"task-manager/api-reference/#task-manager-api-reference","title":"Task Manager API Reference","text":"<p>The Task Manager exposes a read-only REST API over Next.js App Router route handlers. All endpoints serve JSON (except the SSE stream) and read task data from the filesystem at <code>~/.claude/tasks/</code>. There are no mutations \u2014 task files are created and modified externally by Claude Code plugins.</p> <p>Base URL: <code>http://localhost:3000/api</code> (default development port)</p>"},{"location":"task-manager/api-reference/#endpoints-overview","title":"Endpoints Overview","text":"Method Endpoint Description <code>GET</code> <code>/api/health</code> Health check <code>GET</code> <code>/api/task-lists</code> List all task lists <code>GET</code> <code>/api/tasks/:listId</code> Get tasks in a list <code>GET</code> <code>/api/execution-context/:listId</code> Get execution artifacts <code>GET</code> <code>/api/events</code> SSE stream for real-time updates"},{"location":"task-manager/api-reference/#get-apihealth","title":"<code>GET /api/health</code>","text":"<p>Simple health check endpoint. Returns the server status and current timestamp.</p> <p>Source: <code>src/app/api/health/route.ts</code></p>"},{"location":"task-manager/api-reference/#response","title":"Response","text":"200 OK<pre><code>{\n  \"status\": \"ok\",\n  \"timestamp\": \"2025-01-15T09:32:17.045Z\"\n}\n</code></pre> Field Type Description <code>status</code> <code>string</code> Always <code>\"ok\"</code> <code>timestamp</code> <code>string</code> ISO-8601 UTC timestamp of the response"},{"location":"task-manager/api-reference/#example","title":"Example","text":"cURL<pre><code>curl http://localhost:3000/api/health\n</code></pre>"},{"location":"task-manager/api-reference/#get-apitask-lists","title":"<code>GET /api/task-lists</code>","text":"<p>Returns all task list directories under <code>~/.claude/tasks/</code> that contain at least one <code>.json</code> file. Results are sorted alphabetically by name.</p> <p>Source: <code>src/app/api/task-lists/route.ts</code> \u2192 <code>taskService.getTaskLists()</code></p>"},{"location":"task-manager/api-reference/#response_1","title":"Response","text":"200 OK<pre><code>{\n  \"taskLists\": [\n    {\n      \"id\": \"claude-alchemy\",\n      \"name\": \"claude-alchemy\",\n      \"taskCount\": 12\n    },\n    {\n      \"id\": \"my-project\",\n      \"name\": \"my-project\",\n      \"taskCount\": 5\n    }\n  ]\n}\n</code></pre> Field Type Description <code>taskLists</code> <code>TaskList[]</code> Array of task list objects <p>Empty Response</p> <p>If <code>~/.claude/tasks/</code> does not exist or contains no directories with <code>.json</code> files, the response will be <code>{ \"taskLists\": [] }</code>.</p>"},{"location":"task-manager/api-reference/#error-response","title":"Error Response","text":"500 Internal Server Error<pre><code>{\n  \"error\": \"Failed to fetch task lists\"\n}\n</code></pre>"},{"location":"task-manager/api-reference/#example_1","title":"Example","text":"cURL<pre><code>curl http://localhost:3000/api/task-lists\n</code></pre>"},{"location":"task-manager/api-reference/#get-apitaskslistid","title":"<code>GET /api/tasks/:listId</code>","text":"<p>Returns all tasks in a specific task list, parsed from individual JSON files in <code>~/.claude/tasks/&lt;listId&gt;/</code>. Tasks are sorted by numeric ID when possible, falling back to alphabetical sort.</p> <p>Source: <code>src/app/api/tasks/[listId]/route.ts</code> \u2192 <code>taskService.getTasks()</code></p>"},{"location":"task-manager/api-reference/#path-parameters","title":"Path Parameters","text":"Parameter Type Required Description <code>listId</code> <code>string</code> Yes The task list directory name <p>Input Validation</p> <p>The <code>listId</code> parameter is validated against path traversal attacks. Requests containing <code>..</code> or <code>/</code> in the <code>listId</code> will be rejected with a <code>400</code> error. This validation occurs before any filesystem access.</p>"},{"location":"task-manager/api-reference/#response_2","title":"Response","text":"200 OK<pre><code>{\n  \"tasks\": [\n    {\n      \"id\": \"1\",\n      \"subject\": \"Set up project scaffolding\",\n      \"description\": \"Initialize the monorepo with pnpm workspaces\",\n      \"status\": \"completed\",\n      \"blocks\": [\"2\", \"3\"],\n      \"blockedBy\": [],\n      \"metadata\": {\n        \"priority\": \"high\",\n        \"complexity\": \"M\",\n        \"phase\": 1\n      }\n    },\n    {\n      \"id\": \"2\",\n      \"subject\": \"Implement authentication\",\n      \"description\": \"Add OAuth2 login flow with JWT tokens\",\n      \"status\": \"in_progress\",\n      \"blocks\": [],\n      \"blockedBy\": [\"1\"],\n      \"activeForm\": \"Setting up OAuth provider configuration\",\n      \"metadata\": {\n        \"priority\": \"critical\",\n        \"complexity\": \"L\",\n        \"phase\": 2,\n        \"feature_name\": \"auth\"\n      }\n    }\n  ]\n}\n</code></pre> Field Type Description <code>tasks</code> <code>Task[]</code> Array of task objects, sorted by ID"},{"location":"task-manager/api-reference/#error-responses","title":"Error Responses","text":"400 Bad Request500 Internal Server Error <p>Returned when <code>listId</code> contains path traversal characters.</p> <pre><code>{\n  \"error\": \"Invalid task list ID\"\n}\n</code></pre> <p>Returned on unexpected filesystem or parsing errors.</p> <pre><code>{\n  \"error\": \"Failed to fetch tasks\"\n}\n</code></pre> <p>Missing Task List</p> <p>If the specified <code>listId</code> directory does not exist, the endpoint returns <code>200 OK</code> with an empty array: <code>{ \"tasks\": [] }</code>. This is not treated as an error.</p>"},{"location":"task-manager/api-reference/#parsing-behavior","title":"Parsing Behavior","text":"<p>The <code>parseTask()</code> function in <code>taskService.ts</code> applies defensive normalization when reading task JSON files:</p> Field Behavior <code>id</code> Coerced to <code>string</code>. Falls back to the filename (without <code>.json</code>) if missing or invalid <code>subject</code> Required. Tasks without a string <code>subject</code> are silently skipped <code>status</code> Defaults to <code>\"pending\"</code> if the value is not a valid <code>TaskStatus</code> <code>blocks</code> Defaults to <code>[]</code>. Each element is coerced to <code>string</code> <code>blockedBy</code> Defaults to <code>[]</code>. Each element is coerced to <code>string</code> <code>description</code> Defaults to <code>\"\"</code> if missing or non-string <code>activeForm</code> Removed from the task object if present but not a string"},{"location":"task-manager/api-reference/#example_2","title":"Example","text":"cURL<pre><code>curl http://localhost:3000/api/tasks/claude-alchemy\n</code></pre>"},{"location":"task-manager/api-reference/#get-apiexecution-contextlistid","title":"<code>GET /api/execution-context/:listId</code>","text":"<p>Returns the execution context for a task list, including session artifacts and progress information. The execution context is resolved from an <code>execution_pointer.md</code> file located in the task list directory, which contains an absolute path to the active session's execution directory.</p> <p>Source: <code>src/app/api/execution-context/[listId]/route.ts</code> \u2192 <code>taskService.getExecutionContext()</code></p>"},{"location":"task-manager/api-reference/#path-parameters_1","title":"Path Parameters","text":"Parameter Type Required Description <code>listId</code> <code>string</code> Yes The task list directory name <p>Input Validation</p> <p>The <code>listId</code> parameter is validated identically to the tasks endpoint. Requests containing <code>..</code> or <code>/</code> are rejected with <code>400</code>.</p> <p>Path Traversal Guard</p> <p>The <code>resolveExecutionDir()</code> function applies a secondary security check: the resolved execution directory path must be under the user's home directory. Pointer files that resolve to paths outside <code>$HOME</code> are rejected and return <code>null</code>.</p>"},{"location":"task-manager/api-reference/#response-active-execution","title":"Response \u2014 Active Execution","text":"200 OK<pre><code>{\n  \"executionContext\": {\n    \"executionDir\": \"/Users/you/.claude/sessions/__live_session__\",\n    \"artifacts\": [\n      {\n        \"name\": \"execution_context\",\n        \"content\": \"# Execution Context\\n\\nProject: claude-alchemy\\n...\",\n        \"lastModified\": 1705312337045\n      },\n      {\n        \"name\": \"task_log\",\n        \"content\": \"# Task Log\\n\\n## [1] Set up scaffolding\\n- Status: completed\\n...\",\n        \"lastModified\": 1705312400123\n      },\n      {\n        \"name\": \"execution_plan\",\n        \"content\": \"# Execution Plan\\n\\nWave 1: Tasks 1, 4\\nWave 2: Tasks 2, 3\\n...\",\n        \"lastModified\": 1705312337045\n      },\n      {\n        \"name\": \"progress\",\n        \"content\": \"Status: executing\\nWave: 2 of 3\\nMax Parallel: 2\\nUpdated: 2025-01-15T09:32:17Z\\n...\",\n        \"lastModified\": 1705312500789\n      }\n    ],\n    \"progress\": {\n      \"status\": \"executing\",\n      \"wave\": 2,\n      \"totalWaves\": 3,\n      \"maxParallel\": 2,\n      \"updated\": \"2025-01-15T09:32:17Z\",\n      \"activeTasks\": [\n        {\n          \"id\": \"2\",\n          \"subject\": \"Implement authentication\",\n          \"phase\": \"implementation\"\n        }\n      ],\n      \"completedTasks\": [\n        {\n          \"id\": \"1\",\n          \"subject\": \"Set up project scaffolding\",\n          \"result\": \"completed successfully\"\n        }\n      ]\n    }\n  }\n}\n</code></pre>"},{"location":"task-manager/api-reference/#response-no-execution","title":"Response \u2014 No Execution","text":"<p>When there is no active execution (no pointer file, invalid pointer, or empty execution directory):</p> 200 OK<pre><code>{\n  \"executionContext\": null\n}\n</code></pre>"},{"location":"task-manager/api-reference/#artifact-sort-order","title":"Artifact Sort Order","text":"<p>Artifacts are returned in a fixed priority order:</p> Priority Artifact Name Description 1 <code>execution_context</code> Session configuration and parameters 2 <code>task_log</code> Chronological log of task execution 3 <code>execution_plan</code> Wave-based execution plan 4 <code>session_summary</code> Post-execution summary 5+ (alphabetical) Any other <code>.md</code> artifacts <p>Filtered Artifacts</p> <p>Temporary per-wave context files (those with names starting with <code>context-task-</code>) are filtered out and never returned in the response.</p>"},{"location":"task-manager/api-reference/#error-responses_1","title":"Error Responses","text":"400 Bad Request500 Internal Server Error <pre><code>{\n  \"error\": \"Invalid task list ID\"\n}\n</code></pre> <pre><code>{\n  \"error\": \"Failed to fetch execution context\"\n}\n</code></pre>"},{"location":"task-manager/api-reference/#example_3","title":"Example","text":"cURL<pre><code>curl http://localhost:3000/api/execution-context/claude-alchemy\n</code></pre>"},{"location":"task-manager/api-reference/#get-apievents","title":"<code>GET /api/events</code>","text":"<p>Server-Sent Events (SSE) endpoint for real-time push updates. The client opens a persistent HTTP connection and receives events whenever task files or execution artifacts change on disk.</p> <p>Source: <code>src/app/api/events/route.ts</code></p> <p>Runtime Requirements</p> <p>This route is configured with <code>dynamic = 'force-dynamic'</code> and <code>runtime = 'nodejs'</code> to ensure it runs as a streaming Node.js handler, bypassing Next.js static optimization and edge runtime.</p>"},{"location":"task-manager/api-reference/#query-parameters","title":"Query Parameters","text":"Parameter Type Required Description <code>taskListId</code> <code>string</code> No Filter events to a specific task list. If provided, the server also begins watching the list's execution directory for artifact changes."},{"location":"task-manager/api-reference/#response-headers","title":"Response Headers","text":"Header Value Purpose <code>Content-Type</code> <code>text/event-stream</code> Identifies the response as an SSE stream <code>Cache-Control</code> <code>no-cache, no-transform</code> Prevents caching by browsers and proxies <code>Connection</code> <code>keep-alive</code> Maintains the persistent connection <code>X-Accel-Buffering</code> <code>no</code> Disables nginx response buffering"},{"location":"task-manager/api-reference/#connection-lifecycle","title":"Connection Lifecycle","text":"<pre><code>sequenceDiagram\n    participant Client\n    participant SSE Route\n    participant FileWatcher\n    participant Filesystem\n\n    Client-&gt;&gt;SSE Route: GET /api/events?taskListId=my-list\n    SSE Route-&gt;&gt;FileWatcher: Ensure watcher started\n    SSE Route-&gt;&gt;FileWatcher: Watch execution dir (if exists)\n    SSE Route--&gt;&gt;Client: event: connected\n\n    loop File changes\n        Filesystem-&gt;&gt;FileWatcher: File created/modified/deleted\n        FileWatcher-&gt;&gt;SSE Route: taskEvent / executionEvent\n        SSE Route--&gt;&gt;Client: event: task:updated (filtered by taskListId)\n    end\n\n    loop Every 30 seconds\n        SSE Route--&gt;&gt;Client: :heartbeat\n    end\n\n    Client-&gt;&gt;SSE Route: Connection closed (abort signal)\n    SSE Route-&gt;&gt;FileWatcher: Unsubscribe listeners</code></pre>"},{"location":"task-manager/api-reference/#event-types","title":"Event Types","text":""},{"location":"task-manager/api-reference/#connected","title":"<code>connected</code>","text":"<p>Sent immediately after the connection is established. Contains no meaningful data.</p> <pre><code>event: connected\ndata: {}\n</code></pre>"},{"location":"task-manager/api-reference/#taskcreated","title":"<code>task:created</code>","text":"<p>Emitted when a new <code>.json</code> task file is added to the watched directory.</p> <pre><code>event: task:created\ndata: {\"type\":\"task:created\",\"taskListId\":\"claude-alchemy\",\"taskId\":\"5\",\"task\":{\"id\":\"5\",\"subject\":\"New task\",\"description\":\"\",\"status\":\"pending\",\"blocks\":[],\"blockedBy\":[]}}\n</code></pre>"},{"location":"task-manager/api-reference/#taskupdated","title":"<code>task:updated</code>","text":"<p>Emitted when an existing <code>.json</code> task file is modified.</p> <pre><code>event: task:updated\ndata: {\"type\":\"task:updated\",\"taskListId\":\"claude-alchemy\",\"taskId\":\"2\",\"task\":{\"id\":\"2\",\"subject\":\"Implement auth\",\"description\":\"...\",\"status\":\"completed\",\"blocks\":[],\"blockedBy\":[\"1\"]}}\n</code></pre>"},{"location":"task-manager/api-reference/#taskdeleted","title":"<code>task:deleted</code>","text":"<p>Emitted when a <code>.json</code> task file is removed. The <code>task</code> field is absent for delete events.</p> <pre><code>event: task:deleted\ndata: {\"type\":\"task:deleted\",\"taskListId\":\"claude-alchemy\",\"taskId\":\"5\"}\n</code></pre>"},{"location":"task-manager/api-reference/#executionupdated","title":"<code>execution:updated</code>","text":"<p>Emitted when any <code>.md</code> or <code>.txt</code> file changes in the watched execution directory.</p> <pre><code>event: execution:updated\ndata: {\"type\":\"execution:updated\",\"taskListId\":\"claude-alchemy\"}\n</code></pre>"},{"location":"task-manager/api-reference/#heartbeat","title":"Heartbeat","text":"<p>A comment-only keepalive sent every 30 seconds to prevent connection timeouts. This is not a named event and will not trigger <code>EventSource</code> event listeners.</p> <pre><code>:heartbeat\n</code></pre>"},{"location":"task-manager/api-reference/#client-usage","title":"Client Usage","text":"<p>The Task Manager connects to this endpoint via the <code>useSSE</code> hook, which manages the <code>EventSource</code> lifecycle and triggers TanStack Query cache invalidation on each event.</p> Connecting from a browser client<pre><code>const eventSource = new EventSource(\n  `/api/events?taskListId=${encodeURIComponent(listId)}`\n);\n\neventSource.addEventListener('connected', () =&gt; {\n  console.log('SSE connection established');\n});\n\neventSource.addEventListener('task:updated', (event) =&gt; {\n  const data = JSON.parse(event.data);\n  console.log(`Task ${data.taskId} updated in ${data.taskListId}`);\n  // Invalidate relevant queries to refresh the UI\n});\n\neventSource.addEventListener('execution:updated', (event) =&gt; {\n  const data = JSON.parse(event.data);\n  console.log(`Execution context updated for ${data.taskListId}`);\n});\n\neventSource.onerror = () =&gt; {\n  eventSource.close();\n  // Reconnect after delay\n  setTimeout(() =&gt; { /* re-create EventSource */ }, 3000);\n};\n</code></pre> <p>Automatic Reconnection</p> <p>The built-in <code>useSSE</code> hook automatically reconnects after a 3-second delay when the connection drops. If you implement a custom client, you should handle reconnection similarly.</p>"},{"location":"task-manager/api-reference/#example_4","title":"Example","text":"cURL (streaming)<pre><code>curl -N http://localhost:3000/api/events?taskListId=claude-alchemy\n</code></pre>"},{"location":"task-manager/api-reference/#data-models","title":"Data Models","text":""},{"location":"task-manager/api-reference/#task","title":"Task","text":"<p>Represents a single task parsed from a JSON file in <code>~/.claude/tasks/&lt;listId&gt;/&lt;id&gt;.json</code>.</p> src/types/task.ts<pre><code>interface Task {\n  id: string\n  subject: string\n  description: string\n  status: TaskStatus\n  blocks: string[]\n  blockedBy: string[]\n  activeForm?: string\n  metadata?: TaskMetadata\n}\n\ntype TaskStatus = 'pending' | 'in_progress' | 'completed'\n</code></pre> Field Type Required Description <code>id</code> <code>string</code> Yes Unique identifier, typically a numeric string. Derived from the filename if not present in the JSON. <code>subject</code> <code>string</code> Yes Short title of the task. Tasks without a subject are skipped during parsing. <code>description</code> <code>string</code> Yes Detailed task description. Defaults to <code>\"\"</code>. <code>status</code> <code>TaskStatus</code> Yes One of <code>\"pending\"</code>, <code>\"in_progress\"</code>, or <code>\"completed\"</code>. Defaults to <code>\"pending\"</code>. <code>blocks</code> <code>string[]</code> Yes IDs of tasks that this task blocks. Defaults to <code>[]</code>. <code>blockedBy</code> <code>string[]</code> Yes IDs of tasks that block this task. Defaults to <code>[]</code>. <code>activeForm</code> <code>string</code> No Free-text description of current work being done on this task. <code>metadata</code> <code>TaskMetadata</code> No Extensible metadata bag for priority, complexity, and other attributes."},{"location":"task-manager/api-reference/#taskmetadata","title":"TaskMetadata","text":"src/types/task.ts<pre><code>interface TaskMetadata {\n  priority?: 'critical' | 'high' | 'medium' | 'low'\n  complexity?: 'XS' | 'S' | 'M' | 'L' | 'XL'\n  source_section?: string\n  prd_path?: string\n  feature_name?: string\n  task_uid?: string\n  phase?: number\n  [key: string]: unknown\n}\n</code></pre> Field Type Description <code>priority</code> <code>string</code> Task priority: <code>\"critical\"</code>, <code>\"high\"</code>, <code>\"medium\"</code>, or <code>\"low\"</code> <code>complexity</code> <code>string</code> T-shirt size estimate: <code>\"XS\"</code>, <code>\"S\"</code>, <code>\"M\"</code>, <code>\"L\"</code>, or <code>\"XL\"</code> <code>source_section</code> <code>string</code> Reference to the PRD section that generated this task <code>prd_path</code> <code>string</code> Filesystem path to the source PRD document <code>feature_name</code> <code>string</code> Name of the feature this task belongs to <code>task_uid</code> <code>string</code> External unique identifier for cross-referencing <code>phase</code> <code>number</code> Execution phase number <code>[key: string]</code> <code>unknown</code> Arbitrary additional metadata (extensible index signature)"},{"location":"task-manager/api-reference/#tasklist","title":"TaskList","text":"src/types/task.ts<pre><code>interface TaskList {\n  id: string\n  name: string\n  taskCount: number\n}\n</code></pre> Field Type Description <code>id</code> <code>string</code> Directory name under <code>~/.claude/tasks/</code> <code>name</code> <code>string</code> Display name (currently identical to <code>id</code>) <code>taskCount</code> <code>number</code> Number of <code>.json</code> files in the directory"},{"location":"task-manager/api-reference/#executioncontext","title":"ExecutionContext","text":"src/types/execution.ts<pre><code>interface ExecutionContext {\n  executionDir: string\n  artifacts: ExecutionArtifact[]\n  progress?: ExecutionProgress | null\n}\n</code></pre> Field Type Description <code>executionDir</code> <code>string</code> Absolute path to the resolved execution session directory <code>artifacts</code> <code>ExecutionArtifact[]</code> Markdown files from the execution directory, sorted by priority <code>progress</code> <code>ExecutionProgress</code> Parsed progress data from <code>progress.md</code>, or <code>null</code> if unavailable"},{"location":"task-manager/api-reference/#executionartifact","title":"ExecutionArtifact","text":"src/types/execution.ts<pre><code>interface ExecutionArtifact {\n  name: string\n  content: string\n  lastModified: number\n}\n</code></pre> Field Type Description <code>name</code> <code>string</code> Artifact name (filename without <code>.md</code> extension) <code>content</code> <code>string</code> Full text content of the markdown file <code>lastModified</code> <code>number</code> Last modified time in milliseconds since epoch (<code>Date.now()</code> format)"},{"location":"task-manager/api-reference/#executionprogress","title":"ExecutionProgress","text":"<p>Parsed from the <code>progress.md</code> artifact using structured markdown conventions.</p> src/types/execution.ts<pre><code>interface ExecutionProgress {\n  status: string\n  wave: number\n  totalWaves: number\n  maxParallel?: number\n  updated: string\n  activeTasks: ActiveTask[]\n  completedTasks: CompletedTask[]\n}\n\ninterface ActiveTask {\n  id: string\n  subject: string\n  phase: string\n}\n\ninterface CompletedTask {\n  id: string\n  subject: string\n  result: string\n}\n</code></pre> Field Type Description <code>status</code> <code>string</code> Current execution status (e.g., <code>\"executing\"</code>, <code>\"completed\"</code>) <code>wave</code> <code>number</code> Current execution wave number <code>totalWaves</code> <code>number</code> Total number of planned waves <code>maxParallel</code> <code>number</code> Maximum parallel tasks per wave (optional) <code>updated</code> <code>string</code> Timestamp of the last progress update <code>activeTasks</code> <code>ActiveTask[]</code> Tasks currently being executed <code>completedTasks</code> <code>CompletedTask[]</code> Tasks completed in the current session"},{"location":"task-manager/api-reference/#sse-event-types","title":"SSE Event Types","text":"src/types/task.ts<pre><code>// Task file events\ninterface SSEEvent {\n  type: 'task:created' | 'task:updated' | 'task:deleted'\n  taskListId: string\n  taskId: string\n  task?: Task  // Present for created/updated, absent for deleted\n}\n\n// Execution artifact events\ninterface ExecutionSSEEvent {\n  type: 'execution:updated'\n  taskListId: string\n}\n</code></pre>"},{"location":"task-manager/api-reference/#architecture-notes","title":"Architecture Notes","text":""},{"location":"task-manager/api-reference/#filesystem-as-data-source","title":"Filesystem as Data Source","text":"<p>The API is entirely read-only. Task files are created and modified by Claude Code plugins (specifically the <code>execute-tasks</code> skill), and the Task Manager simply reads and serves them. There is no database, no write endpoints, and no shared runtime between the plugins and the web app.</p> <pre><code>graph LR\n    A[Claude Code Plugin] --&gt;|writes JSON| B[\"~/.claude/tasks/\"]\n    B --&gt;|reads| C[Task Manager API]\n    C --&gt;|JSON responses| D[Browser Client]\n    B --&gt;|Chokidar watches| E[FileWatcher]\n    E --&gt;|emits events| C\n    C --&gt;|SSE stream| D</code></pre>"},{"location":"task-manager/api-reference/#file-watcher","title":"File Watcher","text":"<p>The <code>FileWatcher</code> class (<code>src/lib/fileWatcher.ts</code>) is a Chokidar-based singleton that watches <code>~/.claude/tasks/</code> for changes. It uses a <code>globalThis</code> pattern to survive Next.js hot module replacement during development, preventing duplicate watchers.</p> <p>Key configuration:</p> <ul> <li>Polling interval: 300ms (<code>usePolling: true</code>)</li> <li>Watch depth: 2 directories deep</li> <li>Initial scan: Ignored (<code>ignoreInitial: true</code>)</li> <li>Persistence: Runs as long as the Next.js server is alive</li> </ul>"},{"location":"task-manager/api-reference/#security","title":"Security","text":"<p>All endpoints that accept a <code>listId</code> parameter apply two layers of protection:</p> <ol> <li>Route-level validation \u2014 The <code>listId</code> is checked for <code>..</code> and <code>/</code> characters before any filesystem access.</li> <li>Execution pointer validation \u2014 The <code>resolveExecutionDir()</code> function uses <code>path.relative()</code> to verify that resolved execution paths remain under the user's home directory.</li> </ol> <p>Security Boundary</p> <p>These validations assume the Task Manager runs as a local development tool. The API has no authentication and binds to <code>localhost</code> by default. Do not expose it to untrusted networks.</p>"},{"location":"task-manager/components/","title":"Components","text":""},{"location":"task-manager/components/#components-reference","title":"Components Reference","text":"<p>The Task Manager UI is built from a layered component hierarchy that separates server-side data fetching from client-side interactivity. Server Components handle initial data loading, while Client Components manage state, real-time updates, and user interaction through TanStack Query and Server-Sent Events.</p>"},{"location":"task-manager/components/#component-hierarchy","title":"Component Hierarchy","text":"<pre><code>graph TD\n    RootLayout[\"RootLayout (Server)\"]\n    Providers[\"Providers (Client)\"]\n    HomePage[\"HomePage (Server)\"]\n    TaskListPage[\"TaskListPage (Server)\"]\n    TaskBoardClient[\"TaskBoardClient (Client)\"]\n    Header[\"Header\"]\n    TLS[\"TaskListSelector\"]\n    SI[\"SearchInput\"]\n    EPB[\"ExecutionProgressBar\"]\n    TT[\"ThemeToggle\"]\n    SS[\"SummaryStats\"]\n    KB[\"KanbanBoard\"]\n    TC[\"Task Cards\"]\n    TD_[\"TaskDetail (Dialog)\"]\n    ED[\"ExecutionDialog (Dialog)\"]\n\n    RootLayout --&gt; Providers\n    Providers --&gt; HomePage\n    Providers --&gt; TaskListPage\n    TaskListPage --&gt; TaskBoardClient\n    TaskBoardClient --&gt; Header\n    Header --&gt; TLS\n    Header --&gt; SI\n    Header --&gt; EPB\n    Header --&gt; TT\n    TaskBoardClient --&gt; SS\n    TaskBoardClient --&gt; KB\n    KB --&gt; TC\n    TaskBoardClient --&gt; TD_\n    TaskBoardClient --&gt; ED</code></pre>"},{"location":"task-manager/components/#page-level-components","title":"Page-Level Components","text":""},{"location":"task-manager/components/#rootlayout","title":"RootLayout","text":"<p>Server Component that wraps the entire application with fonts and the <code>Providers</code> client boundary.</p> src/app/layout.tsx<pre><code>export default function RootLayout({\n  children,\n}: Readonly&lt;{ children: React.ReactNode }&gt;) {\n  return (\n    &lt;html lang=\"en\" suppressHydrationWarning&gt;\n      &lt;body className={`${geistSans.variable} ${geistMono.variable} antialiased`}&gt;\n        &lt;Providers&gt;{children}&lt;/Providers&gt;\n      &lt;/body&gt;\n    &lt;/html&gt;\n  )\n}\n</code></pre> Responsibility Detail Fonts Loads Geist Sans and Geist Mono via <code>next/font/google</code> Metadata Sets page title to \"Claude Task Manager\" Hydration Uses <code>suppressHydrationWarning</code> for <code>next-themes</code> compatibility"},{"location":"task-manager/components/#homepage","title":"HomePage","text":"<p>Server Component at <code>/</code> that redirects to the first available task list.</p> src/app/page.tsx<pre><code>export default async function HomePage() {\n  const taskLists = await getTaskLists()\n  if (taskLists.length &gt; 0) {\n    redirect(`/lists/${encodeURIComponent(taskLists[0].id)}`)\n  }\n  // Fallback: empty state message\n}\n</code></pre> <p>If no task lists exist in <code>~/.claude/tasks/</code>, it renders an empty state directing the user to create task files.</p>"},{"location":"task-manager/components/#tasklistpage","title":"TaskListPage","text":"<p>Server Component at <code>/lists/[listId]</code> that performs parallel data fetching and passes results to the client orchestrator.</p> src/app/lists/[listId]/page.tsx<pre><code>const [taskLists, tasks, executionContext] = await Promise.all([\n  getTaskLists(),\n  getTasks(decodedListId),\n  getExecutionContext(decodedListId),\n])\n</code></pre> Data Fetched Passed As <code>TaskList[]</code> <code>taskLists</code> <code>Task[]</code> <code>initialTasks</code> <code>ExecutionContext \\| null</code> <code>initialExecutionContext</code> <p>All three fetches run in parallel via <code>Promise.all</code> for optimal loading performance. If the decoded <code>listId</code> does not match any known task list, the page calls <code>notFound()</code>.</p>"},{"location":"task-manager/components/#core-components","title":"Core Components","text":""},{"location":"task-manager/components/#providers","title":"Providers","text":"<p>File: <code>src/components/Providers.tsx</code> \u00b7 Type: Client Component</p> <p>Wraps the entire component tree with TanStack Query and theme support.</p> src/components/Providers.tsx<pre><code>export function Providers({ children }: { children: React.ReactNode }) {\n  const [queryClient] = useState(\n    () =&gt;\n      new QueryClient({\n        defaultOptions: {\n          queries: {\n            staleTime: 1000 * 60, // 1 minute\n            refetchOnWindowFocus: false,\n          },\n        },\n      })\n  )\n\n  return (\n    &lt;QueryClientProvider client={queryClient}&gt;\n      &lt;ThemeProvider\n        attribute=\"class\"\n        defaultTheme=\"dark\"\n        enableSystem\n        disableTransitionOnChange\n      &gt;\n        {children}\n      &lt;/ThemeProvider&gt;\n    &lt;/QueryClientProvider&gt;\n  )\n}\n</code></pre> Setting Value Purpose <code>staleTime</code> 60 seconds Prevents unnecessary refetches; SSE handles real-time invalidation <code>refetchOnWindowFocus</code> <code>false</code> Avoids disruptive refetches when switching tabs <code>defaultTheme</code> <code>\"dark\"</code> Dark mode is the default appearance <code>enableSystem</code> <code>true</code> Respects OS-level theme preference <code>disableTransitionOnChange</code> <code>true</code> Prevents flash-of-wrong-theme during toggles <p>QueryClient Initialization</p> <p>The <code>QueryClient</code> is created inside <code>useState</code> to ensure a single instance per component lifecycle, avoiding re-creation on every render while remaining safe for React Strict Mode.</p>"},{"location":"task-manager/components/#taskboardclient","title":"TaskBoardClient","text":"<p>File: <code>src/components/TaskBoardClient.tsx</code> \u00b7 Type: Client Component</p> <p>The root client-side orchestrator. It composes all hooks and child components, manages UI state, and bridges server-fetched data into the reactive client layer.</p> src/components/TaskBoardClient.tsx<pre><code>interface TaskBoardClientProps {\n  listId: string\n  initialTasks: Task[]\n  taskLists: TaskList[]\n  initialExecutionContext?: ExecutionContext | null\n}\n</code></pre> <p>State managed:</p> State Type Purpose <code>selectedTask</code> <code>Task \\| null</code> Currently open task in the detail dialog <code>searchQuery</code> <code>string</code> Text filter applied to the Kanban board <code>executionDialogOpen</code> <code>boolean</code> Controls visibility of the execution dialog <p>Hooks composed:</p> Hook Purpose <code>useTasks(listId, initialTasks)</code> Keeps task data reactive with server-provided initial data <code>useExecutionContext(listId, initialExecutionContext)</code> Polls execution context with 5-second interval <code>useSSE(listId)</code> Opens SSE connection for real-time cache invalidation <p>Layout structure:</p> <p>The component renders four main areas in sequence:</p> <ol> <li>Header bar \u2014 <code>TaskListSelector</code>, <code>SearchInput</code>, <code>ExecutionProgressBar</code>, <code>ThemeToggle</code></li> <li>SummaryStats \u2014 Only rendered when tasks exist</li> <li>Main content \u2014 <code>KanbanBoard</code> or an empty state message</li> <li>Dialogs \u2014 <code>TaskDetail</code> and <code>ExecutionDialog</code> (portaled, conditionally visible)</li> </ol> <p>Server-to-Client Data Handoff</p> <p><code>initialTasks</code> and <code>initialExecutionContext</code> from the Server Component are passed directly as <code>initialData</code> to TanStack Query. This means the page renders instantly with server data, then stays in sync via SSE-triggered invalidations \u2014 no loading spinners on initial page load.</p>"},{"location":"task-manager/components/#kanbanboard","title":"KanbanBoard","text":"<p>File: <code>src/components/KanbanBoard.tsx</code> \u00b7 Type: Client Component</p> <p>A three-column Kanban grid that groups and displays tasks by status.</p> src/components/KanbanBoard.tsx<pre><code>interface KanbanBoardProps {\n  tasks: Task[]\n  searchQuery?: string\n  onTaskClick?: (task: Task) =&gt; void\n}\n</code></pre> <p>Columns:</p> Column Status Background Pending <code>pending</code> Slate tones In Progress <code>in_progress</code> Blue tones Completed <code>completed</code> Green tones <p>Search filtering: When <code>searchQuery</code> is provided, tasks are filtered by case-insensitive match against both <code>subject</code> and <code>description</code> fields before grouping.</p> <p>Task cards display:</p> <ul> <li>Task ID \u2014 monospace <code>#id</code> badge</li> <li>Active badge \u2014 blue \"Active\" pill when <code>task.activeForm</code> is set</li> <li>Subject \u2014 truncated to 2 lines via <code>line-clamp-2</code></li> <li>Dependency indicators \u2014 red \"Blocked by N\" and orange \"Blocks N\" counts</li> </ul> <p>Each column header shows its title and the count of tasks currently in that column. Empty columns display a \"No tasks\" placeholder.</p> <p>Responsive Layout</p> <p>The board uses a <code>grid-cols-1 md:grid-cols-3</code> layout \u2014 stacking vertically on mobile and showing all three columns side-by-side on medium+ screens. Each column scrolls independently via <code>overflow-y-auto</code>.</p>"},{"location":"task-manager/components/#taskdetail","title":"TaskDetail","text":"<p>File: <code>src/components/TaskDetail.tsx</code> \u00b7 Type: Client Component (Dialog)</p> <p>A modal dialog that displays the full details of a selected task, including metadata badges and navigable dependency links.</p> src/components/TaskDetail.tsx<pre><code>interface TaskDetailProps {\n  task: Task | null\n  onClose: () =&gt; void\n  onNavigateToTask?: (taskId: string) =&gt; void\n  onOpenExecutionContext?: () =&gt; void\n}\n</code></pre> <p>Sections rendered:</p> Section Condition Content Header Always Task ID, subject, status badge, active badge Description <code>task.description</code> exists Full description text with preserved whitespace Active Form <code>task.activeForm</code> exists Current active form label Blocked By <code>blockedBy.length &gt; 0</code> Clickable <code>#id</code> links (red) Blocks <code>blocks.length &gt; 0</code> Clickable <code>#id</code> links (orange) Metadata <code>metadata</code> has keys Priority badge, complexity badge, phase badge, plus any extra key-value pairs Execution Context <code>onOpenExecutionContext</code> provided \"View Execution Context\" button <p>Metadata badges:</p> PriorityComplexity Level Colors Critical Red background High Orange background Medium Yellow background Low Green background Size Colors XS Emerald background S Teal background M Cyan background L Sky background XL Indigo background <p>Dependency navigation: Clicking a <code>#id</code> link in the \"Blocked By\" or \"Blocks\" sections calls <code>onNavigateToTask(taskId)</code>, which in <code>TaskBoardClient</code> looks up the target task and opens it in the same dialog \u2014 allowing users to traverse the dependency graph without closing the modal.</p>"},{"location":"task-manager/components/#summarystats","title":"SummaryStats","text":"<p>File: <code>src/components/SummaryStats.tsx</code> \u00b7 Type: Client Component</p> <p>A horizontal stats bar that shows aggregate task metrics, rendered between the header and the Kanban board.</p> src/components/SummaryStats.tsx<pre><code>interface SummaryStatsProps {\n  tasks: Task[]\n}\n</code></pre> <p>Internally delegates to the <code>useTaskStats</code> hook for memoized computation. Renders six <code>StatCard</code> sub-components:</p> Card Value Color Total <code>stats.total</code> Slate Pending <code>stats.pending</code> Slate In Progress <code>stats.inProgress</code> Blue Completed <code>stats.completed</code> Green Blocked <code>stats.blocked</code> Red Completion <code>stats.completionRate</code> + \"%\" Emerald <p>The stats bar is only rendered when <code>currentTasks.length &gt; 0</code> (controlled by <code>TaskBoardClient</code>).</p>"},{"location":"task-manager/components/#executiondialog","title":"ExecutionDialog","text":"<p>File: <code>src/components/ExecutionDialog.tsx</code> \u00b7 Type: Client Component (Dialog)</p> <p>A large tabbed modal for viewing execution session artifacts. Renders markdown content with <code>react-markdown</code> and <code>remark-gfm</code>, or a structured <code>ProgressView</code> for the progress tab.</p> src/components/ExecutionDialog.tsx<pre><code>interface ExecutionDialogProps {\n  executionContext: ExecutionContext | null\n  open: boolean\n  onOpenChange: (open: boolean) =&gt; void\n}\n</code></pre> <p>Tab order and labels:</p> Artifact Name Tab Label Rendering <code>execution_plan</code> Plan Markdown <code>progress</code> Progress <code>ProgressView</code> component <code>execution_context</code> Context Markdown <code>task_log</code> Log Markdown <code>session_summary</code> Summary Markdown <p>Tabs are sorted in the order shown above. The default tab is <code>execution_plan</code> if available, otherwise the first artifact.</p> <p>ProgressView sub-component:</p> <p>When the progress tab is active and <code>executionContext.progress</code> is available, the dialog renders a structured view instead of raw markdown:</p> <ul> <li>Status badge \u2014 \"Initializing\", \"Executing\", or \"Complete\" with semantic colors</li> <li>Wave indicator \u2014 \"Wave X of Y\" with optional max-parallel count</li> <li>Active tasks list \u2014 Each active task shown with an animated green ping dot, task ID, subject, and current phase</li> <li>Completed tasks list \u2014 Each completed task shown with a PASS/FAIL badge, task ID, subject, and result summary</li> </ul> <p>Markdown Rendering</p> <p>All non-progress artifact tabs use <code>react-markdown</code> with <code>remark-gfm</code> for full GitHub-Flavored Markdown support, including tables, strikethrough, and task lists. Content is styled with Tailwind's <code>prose</code> typography classes and includes custom overrides for table borders and code block backgrounds.</p>"},{"location":"task-manager/components/#executionprogressbar","title":"ExecutionProgressBar","text":"<p>File: <code>src/components/ExecutionProgressBar.tsx</code> \u00b7 Type: Client Component</p> <p>A compact live execution indicator displayed in the header. It has two visual modes depending on execution state.</p> src/components/ExecutionProgressBar.tsx<pre><code>interface ExecutionProgressBarProps {\n  progress: ExecutionProgress | null | undefined\n  hasExecContext: boolean\n  onClick: () =&gt; void\n}\n</code></pre> <p>Rendering modes:</p> Active ExecutionInactive (Context Available)No Context <p>When <code>progress.status === 'Executing'</code>:</p> <pre><code>[\u25cf] Wave 2/5 | 3 active | 7 done\n</code></pre> <ul> <li>Animated green ping dot indicates live activity</li> <li>Shows current wave, active task count, and completed task count</li> <li>Entire bar is clickable to open the <code>ExecutionDialog</code></li> </ul> <p>When execution data exists but is not actively running:</p> <ul> <li>Renders a ghost-variant icon button with the <code>ScrollText</code> (Lucide) icon</li> <li>Clicking opens the <code>ExecutionDialog</code> to review past execution artifacts</li> </ul> <p>When <code>hasExecContext</code> is <code>false</code>:</p> <ul> <li>Returns <code>null</code> \u2014 the component is not rendered at all</li> </ul>"},{"location":"task-manager/components/#tasklistselector","title":"TaskListSelector","text":"<p>File: <code>src/components/TaskListSelector.tsx</code> \u00b7 Type: Client Component</p> <p>A dropdown select for switching between task lists, built on Radix <code>Select</code> primitives via shadcn/ui.</p> src/components/TaskListSelector.tsx<pre><code>interface TaskListSelectorProps {\n  taskLists: TaskList[]\n  currentListId: string\n}\n</code></pre> <p>Selection triggers URL-based navigation via <code>router.push(</code>/lists/${encodeURIComponent(value)}<code>)</code>. Each option displays the list name and task count (e.g., \"claude-alchemy (24)\"). When no task lists are available, it renders a muted \"No task lists found\" message instead of a select.</p>"},{"location":"task-manager/components/#searchinput","title":"SearchInput","text":"<p>File: <code>src/components/SearchInput.tsx</code> \u00b7 Type: Client Component</p> <p>A text input with search icon and clearable state.</p> src/components/SearchInput.tsx<pre><code>interface SearchInputProps {\n  value: string\n  onChange: (value: string) =&gt; void\n  placeholder?: string  // defaults to \"Search tasks...\"\n}\n</code></pre> <p>The search icon (<code>Lucide Search</code>) is positioned inside the input on the left. When the input has a value, an <code>X</code> button appears on the right to clear the field. The search query filters <code>KanbanBoard</code> tasks by matching against <code>subject</code> and <code>description</code>.</p>"},{"location":"task-manager/components/#themetoggle","title":"ThemeToggle","text":"<p>File: <code>src/components/ThemeToggle.tsx</code> \u00b7 Type: Client Component</p> <p>A button that toggles between dark and light themes, with SSR-safe mounting.</p> src/components/ThemeToggle.tsx<pre><code>export function ThemeToggle() {\n  const [mounted, setMounted] = useState(false)\n  const { theme, setTheme } = useTheme()\n\n  useEffect(() =&gt; { setMounted(true) }, [])\n\n  // Render placeholder during SSR\n  if (!mounted) {\n    return &lt;Button variant=\"ghost\" size=\"icon\" disabled&gt;\n      &lt;Sun className=\"h-5 w-5\" /&gt;\n    &lt;/Button&gt;\n  }\n  // ...\n}\n</code></pre> <p>Hydration Safety</p> <p>The component renders a disabled placeholder during SSR and only shows the interactive toggle after mounting. This prevents hydration mismatches because <code>next-themes</code> reads the theme from <code>localStorage</code>, which is not available on the server.</p> <p>The Sun and Moon icons are animated with CSS transforms \u2014 the Sun rotates and scales out when dark mode is active, while the Moon rotates and scales in.</p>"},{"location":"task-manager/components/#hooks","title":"Hooks","text":""},{"location":"task-manager/components/#usetasks","title":"useTasks","text":"<p>File: <code>src/hooks/useTasks.ts</code></p> <p>Fetches and caches tasks for a given list using TanStack Query.</p> src/hooks/useTasks.ts<pre><code>export const taskKeys = {\n  all: ['tasks'] as const,\n  list: (listId: string) =&gt; [...taskKeys.all, listId] as const,\n}\n\nexport function useTasks(taskListId: string | null, initialData?: Task[])\n</code></pre> Option Value Notes <code>queryKey</code> <code>['tasks', listId]</code> Scoped per task list <code>queryFn</code> <code>fetchTasks(taskListId)</code> Calls <code>GET /api/tasks/:listId</code> <code>enabled</code> <code>!!taskListId</code> Disabled when no list selected <code>initialData</code> Server-provided tasks Enables instant render <p>The exported <code>taskKeys</code> factory is used by <code>useSSE</code> to invalidate specific query keys on filesystem events.</p>"},{"location":"task-manager/components/#usetasklists","title":"useTaskLists","text":"<p>File: <code>src/hooks/useTaskLists.ts</code></p> <p>Fetches the list of available task lists.</p> src/hooks/useTaskLists.ts<pre><code>export const taskListKeys = {\n  all: ['task-lists'] as const,\n}\n\nexport function useTaskLists()\n</code></pre> Option Value <code>queryKey</code> <code>['task-lists']</code> <code>queryFn</code> <code>fetchTaskLists()</code> <p>Uses default <code>staleTime</code> (1 minute) from the <code>QueryClient</code> configuration. Invalidated by <code>useSSE</code> on <code>task:created</code>, <code>task:updated</code>, and <code>task:deleted</code> events to keep task counts accurate.</p>"},{"location":"task-manager/components/#useexecutioncontext","title":"useExecutionContext","text":"<p>File: <code>src/hooks/useExecutionContext.ts</code></p> <p>Fetches execution context data with aggressive polling for live updates.</p> src/hooks/useExecutionContext.ts<pre><code>export const executionContextKeys = {\n  all: ['execution-context'] as const,\n  list: (listId: string) =&gt; [...executionContextKeys.all, listId] as const,\n}\n\nexport function useExecutionContext(\n  taskListId: string | null,\n  initialData?: ExecutionContext | null\n)\n</code></pre> Option Value Purpose <code>staleTime</code> 2 seconds Execution data changes rapidly during active runs <code>refetchInterval</code> 5 seconds Polls for updates even without SSE events <code>initialData</code> Server-provided context Avoids loading state on first render <p>Dual Update Strategy</p> <p>Execution context updates through two channels: the 5-second polling interval catches progress changes written to <code>progress.md</code>, while SSE <code>execution:updated</code> events from <code>useSSE</code> trigger immediate invalidation for structural changes to session files.</p>"},{"location":"task-manager/components/#usesse","title":"useSSE","text":"<p>File: <code>src/hooks/useSSE.ts</code></p> <p>Establishes a Server-Sent Events connection and performs dual invalidation (TanStack Query cache + Next.js Server Components) on filesystem change events.</p> src/hooks/useSSE.ts<pre><code>export function useSSE(taskListId: string | null)\n</code></pre> <p>Event handling:</p> SSE Event Action <code>task:created</code> Invalidate <code>taskKeys.list(id)</code> + <code>taskListKeys.all</code> + <code>router.refresh()</code> <code>task:updated</code> Invalidate <code>taskKeys.list(id)</code> + <code>taskListKeys.all</code> + <code>router.refresh()</code> <code>task:deleted</code> Invalidate <code>taskKeys.list(id)</code> + <code>taskListKeys.all</code> + <code>router.refresh()</code> <code>execution:updated</code> Invalidate <code>executionContextKeys.list(id)</code> + <code>router.refresh()</code> <code>connected</code> Logs connection confirmation <p>Reconnection: On error, the EventSource is closed and a reconnection attempt is scheduled after 3 seconds by incrementing a <code>reconnectKey</code> state variable, which triggers the <code>useEffect</code> to re-run and create a new connection.</p> <p>Dual Invalidation Pattern</p> <p><code>router.refresh()</code> re-runs Server Components to update server-fetched data, while <code>queryClient.invalidateQueries()</code> triggers TanStack Query to refetch on the client side. Together, they ensure both the server-rendered initial data and the client-side cache stay consistent with the filesystem.</p>"},{"location":"task-manager/components/#usetaskstats","title":"useTaskStats","text":"<p>File: <code>src/hooks/useTaskStats.ts</code></p> <p>A memoized computation hook that derives aggregate statistics from a task array.</p> src/hooks/useTaskStats.ts<pre><code>export interface TaskStats {\n  total: number\n  pending: number\n  inProgress: number\n  completed: number\n  blocked: number\n  completionRate: number\n}\n\nexport function useTaskStats(tasks: Task[]): TaskStats\n</code></pre> Stat Computation <code>total</code> <code>tasks.length</code> <code>pending</code> Count where <code>status === 'pending'</code> <code>inProgress</code> Count where <code>status === 'in_progress'</code> <code>completed</code> Count where <code>status === 'completed'</code> <code>blocked</code> Count where <code>blockedBy.length &gt; 0</code> <code>completionRate</code> <code>Math.round((completed / total) * 100)</code>, or <code>0</code> if total is zero <p>The computation is wrapped in <code>useMemo</code> with <code>[tasks]</code> as the dependency, so it only recalculates when the task array reference changes.</p>"},{"location":"task-manager/components/#type-definitions","title":"Type Definitions","text":""},{"location":"task-manager/components/#task-types","title":"Task Types","text":"src/types/task.ts<pre><code>export type TaskStatus = 'pending' | 'in_progress' | 'completed'\n\nexport interface TaskMetadata {\n  priority?: 'critical' | 'high' | 'medium' | 'low'\n  complexity?: 'XS' | 'S' | 'M' | 'L' | 'XL'\n  source_section?: string\n  prd_path?: string\n  feature_name?: string\n  task_uid?: string\n  phase?: number\n  [key: string]: unknown  // extensible\n}\n\nexport interface Task {\n  id: string\n  subject: string\n  description: string\n  activeForm?: string\n  status: TaskStatus\n  blocks: string[]\n  blockedBy: string[]\n  metadata?: TaskMetadata\n}\n\nexport interface TaskList {\n  id: string\n  name: string\n  taskCount: number\n}\n</code></pre>"},{"location":"task-manager/components/#execution-types","title":"Execution Types","text":"src/types/execution.ts<pre><code>export interface ExecutionArtifact {\n  name: string\n  content: string\n  lastModified: number\n}\n\nexport interface ActiveTask {\n  id: string\n  subject: string\n  phase: string\n}\n\nexport interface CompletedTask {\n  id: string\n  subject: string\n  result: string\n}\n\nexport interface ExecutionProgress {\n  status: string          // \"Initializing\" | \"Executing\" | \"Complete\"\n  wave: number\n  totalWaves: number\n  maxParallel?: number\n  updated: string\n  activeTasks: ActiveTask[]\n  completedTasks: CompletedTask[]\n}\n\nexport interface ExecutionContext {\n  executionDir: string\n  artifacts: ExecutionArtifact[]\n  progress?: ExecutionProgress | null\n}\n</code></pre>"},{"location":"task-manager/components/#sse-event-types","title":"SSE Event Types","text":"src/types/task.ts<pre><code>export type SSEEventType = 'task:created' | 'task:updated' | 'task:deleted'\nexport type ExecutionSSEEventType = 'execution:updated'\n\nexport interface SSEEvent {\n  type: SSEEventType\n  taskListId: string\n  taskId: string\n  task?: Task\n}\n\nexport interface ExecutionSSEEvent {\n  type: ExecutionSSEEventType\n  taskListId: string\n}\n</code></pre>"},{"location":"task-manager/components/#ui-primitives","title":"UI Primitives","text":"<p>All base UI components are provided by shadcn/ui built on Radix primitives:</p> Component Source Used By <code>Button</code> <code>src/components/ui/button.tsx</code> ThemeToggle, SearchInput, TaskDetail, ExecutionProgressBar <code>Card</code> <code>src/components/ui/card.tsx</code> SummaryStats (StatCard) <code>Dialog</code> <code>src/components/ui/dialog.tsx</code> TaskDetail, ExecutionDialog <code>Input</code> <code>src/components/ui/input.tsx</code> SearchInput <code>Select</code> <code>src/components/ui/select.tsx</code> TaskListSelector <code>Tabs</code> <code>src/components/ui/tabs.tsx</code> ExecutionDialog"},{"location":"task-manager/components/#key-patterns","title":"Key Patterns","text":""},{"location":"task-manager/components/#server-to-client-data-handoff","title":"Server-to-Client Data Handoff","text":"<p>The application uses a \"fetch on the server, hydrate on the client\" pattern:</p> <pre><code>sequenceDiagram\n    participant S as Server Component\n    participant Q as TanStack Query\n    participant SSE as useSSE\n    participant FS as Filesystem\n\n    S-&gt;&gt;Q: Pass initialData (tasks, executionContext)\n    Q--&gt;&gt;Q: Populate cache (no loading state)\n    SSE-&gt;&gt;FS: Listen for changes via EventSource\n    FS--&gt;&gt;SSE: task:updated event\n    SSE-&gt;&gt;Q: invalidateQueries()\n    SSE-&gt;&gt;S: router.refresh()\n    Q-&gt;&gt;Q: Refetch from API</code></pre>"},{"location":"task-manager/components/#query-key-factories","title":"Query Key Factories","text":"<p>Each hook exports a <code>keys</code> factory object for consistent cache key management:</p> <pre><code>// Used by hooks and useSSE for targeted invalidation\ntaskKeys.all          // ['tasks']\ntaskKeys.list('abc')  // ['tasks', 'abc']\n\ntaskListKeys.all      // ['task-lists']\n\nexecutionContextKeys.all          // ['execution-context']\nexecutionContextKeys.list('abc')  // ['execution-context', 'abc']\n</code></pre>"},{"location":"task-manager/components/#theme-system","title":"Theme System","text":"<p>The application uses <code>next-themes</code> with a <code>class</code>-based strategy. Tailwind v4's <code>dark:</code> variant applies styles when the <code>dark</code> class is present on the <code>&lt;html&gt;</code> element. Colors use Tailwind's semantic tokens (<code>bg-card</code>, <code>text-muted-foreground</code>, <code>bg-background</code>) alongside direct color utilities for status-specific styling.</p>"},{"location":"task-manager/overview/","title":"Overview","text":""},{"location":"task-manager/overview/#task-manager-overview","title":"Task Manager Overview","text":"<p>The Task Manager is a Next.js 16.1.4 application that provides a real-time Kanban board for visualizing and monitoring Claude AI task files. It reads JSON task files from the filesystem (<code>~/.claude/tasks/</code>), renders them in a three-column board (Pending, In Progress, Completed), and keeps the UI synchronized with file changes through Server-Sent Events. The dev server runs on port 3030.</p>"},{"location":"task-manager/overview/#tech-stack","title":"Tech Stack","text":"Layer Technology Framework Next.js 16.1.4 (App Router) UI Library React 19.2.3 State Management TanStack Query v5.90.20 Styling Tailwind CSS v4, tailwind-merge Components shadcn/ui (new-york style) with Radix primitives File Watching Chokidar 5 (polling mode, 300ms interval) Theming next-themes (dark/light/system) Markdown Rendering react-markdown 10.1.0 + remark-gfm 4.0.1 Icons Lucide React Fonts Geist Sans + Geist Mono (via <code>next/font/google</code>)"},{"location":"task-manager/overview/#architecture-pattern","title":"Architecture Pattern","text":"<p>The Task Manager follows a Server-First with Real-Time Hydration pattern. Server Components fetch all data on initial page load, eliminating loading spinners. The client then takes over with TanStack Query for cache management and an SSE connection for real-time filesystem updates.</p> <pre><code>sequenceDiagram\n    participant FS as ~/.claude/tasks/\n    participant SC as Server Component\n    participant CC as Client Component\n    participant TQ as TanStack Query\n    participant SSE as SSE Connection\n    participant CK as Chokidar Watcher\n\n    SC-&gt;&gt;FS: Read tasks, taskLists, executionContext (parallel)\n    SC-&gt;&gt;CC: Pass as initialData props\n    CC-&gt;&gt;TQ: Initialize cache (no loading state)\n    CC-&gt;&gt;SSE: Open EventSource connection\n    FS--&gt;&gt;CK: File change detected\n    CK--&gt;&gt;SSE: Emit event via ReadableStream\n    SSE--&gt;&gt;TQ: Invalidate query cache\n    SSE--&gt;&gt;SC: router.refresh() triggers Server Component re-render</code></pre>"},{"location":"task-manager/overview/#data-flow-in-five-steps","title":"Data Flow in Five Steps","text":"<ol> <li>Server Component (<code>page.tsx</code>) fetches <code>tasks</code>, <code>taskLists</code>, and <code>executionContext</code> in parallel via <code>Promise.all()</code>, then passes them as <code>initialData</code> to <code>TaskBoardClient</code>.</li> <li>Client Component (<code>TaskBoardClient</code>) initializes TanStack Query with the server-provided data \u2014 the user sees a fully rendered board immediately.</li> <li>SSE Connection (<code>useSSE</code> hook) opens an <code>EventSource</code> to <code>/api/events?taskListId=&lt;id&gt;</code> for real-time updates.</li> <li>Chokidar (<code>fileWatcher.ts</code>) detects filesystem changes and emits typed events through the SSE <code>ReadableStream</code>.</li> <li>Dual Invalidation \u2014 on every SSE event, the client both invalidates the TanStack Query cache and calls <code>router.refresh()</code> to re-run the Server Component, keeping both data layers in sync.</li> </ol> <p>Why Dual Invalidation?</p> <p>TanStack Query handles client-side cache freshness, but Server Components fetch data independently on navigation. By calling <code>router.refresh()</code> alongside cache invalidation, the app guarantees that both the client cache and the server-rendered HTML stay current. This prevents stale data if the user navigates away and returns to the page.</p>"},{"location":"task-manager/overview/#project-structure","title":"Project Structure","text":"<pre><code>apps/task-manager/\n\u251c\u2500\u2500 src/\n\u2502   \u251c\u2500\u2500 app/\n\u2502   \u2502   \u251c\u2500\u2500 layout.tsx                  # Root layout with Providers\n\u2502   \u2502   \u251c\u2500\u2500 page.tsx                    # Redirects to first task list\n\u2502   \u2502   \u251c\u2500\u2500 globals.css                 # Tailwind CSS + shadcn/ui variables\n\u2502   \u2502   \u251c\u2500\u2500 lists/[listId]/\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 page.tsx                # Server Component \u2014 parallel data fetch\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 loading.tsx             # Loading skeleton\n\u2502   \u2502   \u2514\u2500\u2500 api/\n\u2502   \u2502       \u251c\u2500\u2500 task-lists/route.ts     # GET /api/task-lists\n\u2502   \u2502       \u251c\u2500\u2500 tasks/[listId]/route.ts # GET /api/tasks/:listId\n\u2502   \u2502       \u251c\u2500\u2500 events/route.ts         # SSE endpoint\n\u2502   \u2502       \u251c\u2500\u2500 execution-context/\n\u2502   \u2502       \u2502   \u2514\u2500\u2500 [listId]/route.ts   # GET /api/execution-context/:listId\n\u2502   \u2502       \u2514\u2500\u2500 health/route.ts         # Health check\n\u2502   \u251c\u2500\u2500 components/\n\u2502   \u2502   \u251c\u2500\u2500 TaskBoardClient.tsx         # Root client component (state + SSE)\n\u2502   \u2502   \u251c\u2500\u2500 KanbanBoard.tsx             # Three-column Kanban board\n\u2502   \u2502   \u251c\u2500\u2500 TaskDetail.tsx              # Task detail slide-over dialog\n\u2502   \u2502   \u251c\u2500\u2500 SummaryStats.tsx            # Task count statistics bar\n\u2502   \u2502   \u251c\u2500\u2500 TaskListSelector.tsx        # Dropdown to switch task lists\n\u2502   \u2502   \u251c\u2500\u2500 SearchInput.tsx             # Search/filter input\n\u2502   \u2502   \u251c\u2500\u2500 ExecutionProgressBar.tsx    # Header progress indicator\n\u2502   \u2502   \u251c\u2500\u2500 ExecutionDialog.tsx         # Execution artifacts viewer\n\u2502   \u2502   \u251c\u2500\u2500 ThemeToggle.tsx             # Dark/light mode toggle\n\u2502   \u2502   \u251c\u2500\u2500 Providers.tsx               # QueryClient + ThemeProvider\n\u2502   \u2502   \u2514\u2500\u2500 ui/                         # shadcn/ui primitives\n\u2502   \u251c\u2500\u2500 hooks/\n\u2502   \u2502   \u251c\u2500\u2500 useSSE.ts                   # SSE consumer + dual invalidation\n\u2502   \u2502   \u251c\u2500\u2500 useTasks.ts                 # TanStack Query \u2014 tasks\n\u2502   \u2502   \u251c\u2500\u2500 useTaskLists.ts             # TanStack Query \u2014 task lists\n\u2502   \u2502   \u251c\u2500\u2500 useExecutionContext.ts       # TanStack Query \u2014 execution context\n\u2502   \u2502   \u2514\u2500\u2500 useTaskStats.ts            # Computed task statistics\n\u2502   \u251c\u2500\u2500 lib/\n\u2502   \u2502   \u251c\u2500\u2500 taskService.ts             # Server-side filesystem reading\n\u2502   \u2502   \u251c\u2500\u2500 fileWatcher.ts             # Chokidar singleton + event emission\n\u2502   \u2502   \u251c\u2500\u2500 api.ts                     # Client-side fetch wrappers\n\u2502   \u2502   \u2514\u2500\u2500 utils.ts                   # cn() classname utility\n\u2502   \u2514\u2500\u2500 types/\n\u2502       \u251c\u2500\u2500 task.ts                    # Task, TaskList, SSE event types\n\u2502       \u2514\u2500\u2500 execution.ts              # ExecutionContext, artifacts, progress\n\u2514\u2500\u2500 package.json\n</code></pre>"},{"location":"task-manager/overview/#key-files","title":"Key Files","text":""},{"location":"task-manager/overview/#srclibtaskservicets-server-side-data-layer","title":"<code>src/lib/taskService.ts</code> \u2014 Server-Side Data Layer","text":"<p>The central module for reading task data from the filesystem. All functions are <code>async</code> and use Node.js <code>fs/promises</code>.</p> Function Purpose <code>getTaskLists()</code> Scans <code>~/.claude/tasks/</code> for subdirectories containing <code>.json</code> files <code>getTasks(listId)</code> Reads and parses all <code>.json</code> files in a task list directory <code>getTask(listId, id)</code> Reads a single task by ID <code>getExecutionContext(listId)</code> Reads <code>execution_pointer.md</code>, resolves the session directory, and returns artifacts <code>getTasksDir()</code> Returns the base tasks directory path <p>The <code>parseTask()</code> helper defensively normalizes JSON: it defaults <code>status</code> to <code>\"pending\"</code> for unknown values, coerces <code>id</code> to string, and ensures <code>blocks</code>/<code>blockedBy</code> are arrays.</p> <p>For full API details, see API Reference.</p>"},{"location":"task-manager/overview/#srclibfilewatcherts-chokidar-singleton","title":"<code>src/lib/fileWatcher.ts</code> \u2014 Chokidar Singleton","text":"<p>A <code>FileWatcher</code> class extending Node.js <code>EventEmitter</code>, configured with Chokidar 5 for filesystem monitoring.</p> Configuration<pre><code># Chokidar watcher settings\nusePolling: true    # Required for reliable cross-platform detection\ninterval: 300       # 300ms polling interval\ndepth: 2            # Watch two levels deep from base path\nignoreInitial: true # Skip existing files on startup\n</code></pre> <p>The singleton is stored on <code>globalThis</code> to survive Next.js Hot Module Replacement during development:</p> src/lib/fileWatcher.ts<pre><code>const globalForWatcher = globalThis as unknown as {\n  fileWatcher: FileWatcher | undefined\n}\n\nexport const fileWatcher = globalForWatcher.fileWatcher ?? new FileWatcher()\n\nif (process.env.NODE_ENV !== 'production') {\n  globalForWatcher.fileWatcher = fileWatcher\n}\n</code></pre> <p>The watcher emits two event types:</p> <ul> <li><code>taskEvent</code> \u2014 fired when <code>.json</code> files are created, changed, or deleted</li> <li><code>executionEvent</code> \u2014 fired when <code>.md</code> or <code>.txt</code> files change in a watched execution directory</li> </ul> <p>For implementation details, see Real-Time System.</p>"},{"location":"task-manager/overview/#srcappapieventsroutets-sse-endpoint","title":"<code>src/app/api/events/route.ts</code> \u2014 SSE Endpoint","text":"<p>A Next.js Route Handler that creates a <code>ReadableStream</code> and subscribes to the <code>fileWatcher</code> singleton. Key behaviors:</p> <ul> <li>Sends an initial <code>connected</code> event on stream open</li> <li>Filters events by <code>taskListId</code> query parameter</li> <li>Sends heartbeat comments (<code>:heartbeat</code>) every 30 seconds to keep the connection alive</li> <li>Cleans up event listeners on <code>AbortSignal</code> from the request</li> <li>Dynamically registers execution directory watches when a <code>taskListId</code> is provided</li> </ul>"},{"location":"task-manager/overview/#srchooksusessets-client-side-sse-consumer","title":"<code>src/hooks/useSSE.ts</code> \u2014 Client-Side SSE Consumer","text":"<p>Opens an <code>EventSource</code> to <code>/api/events</code> and performs dual invalidation on each event:</p> SSE Event Cache Invalidation <code>task:created</code> <code>taskKeys.list(listId)</code> + <code>taskListKeys.all</code> + <code>router.refresh()</code> <code>task:updated</code> <code>taskKeys.list(listId)</code> + <code>taskListKeys.all</code> + <code>router.refresh()</code> <code>task:deleted</code> <code>taskKeys.list(listId)</code> + <code>taskListKeys.all</code> + <code>router.refresh()</code> <code>execution:updated</code> <code>executionContextKeys.list(listId)</code> + <code>router.refresh()</code> <p>On connection error, the hook automatically reconnects after a 3-second delay using a <code>reconnectKey</code> state variable.</p>"},{"location":"task-manager/overview/#srcapplistslistidpagetsx-server-component-entry-point","title":"<code>src/app/lists/[listId]/page.tsx</code> \u2014 Server Component Entry Point","text":"<p>The main page Server Component. Fetches all data in parallel before rendering:</p> src/app/lists/[listId]/page.tsx<pre><code>const [taskLists, tasks, executionContext] = await Promise.all([\n  getTaskLists(),\n  getTasks(decodedListId),\n  getExecutionContext(decodedListId),\n])\n</code></pre> <p>If the requested <code>listId</code> does not exist in the fetched task lists, the page returns a 404 via <code>notFound()</code>.</p>"},{"location":"task-manager/overview/#srccomponentstaskboardclienttsx-root-client-component","title":"<code>src/components/TaskBoardClient.tsx</code> \u2014 Root Client Component","text":"<p>The top-level client component that wires together state management, real-time updates, and all UI components:</p> <pre><code>graph TD\n    TBC[TaskBoardClient] --&gt; KBD[KanbanBoard]\n    TBC --&gt; SS[SummaryStats]\n    TBC --&gt; TD[TaskDetail]\n    TBC --&gt; TLS[TaskListSelector]\n    TBC --&gt; SI[SearchInput]\n    TBC --&gt; EPB[ExecutionProgressBar]\n    TBC --&gt; TT[ThemeToggle]\n    TBC --&gt; ED[ExecutionDialog]</code></pre> <p>For details on individual components, see Components.</p>"},{"location":"task-manager/overview/#application-lifecycle","title":"Application Lifecycle","text":""},{"location":"task-manager/overview/#startup","title":"Startup","text":"<ol> <li>Root layout (<code>layout.tsx</code>) wraps the app in <code>Providers</code>, which initializes <code>QueryClient</code> (1-minute <code>staleTime</code>, no refetch-on-focus) and <code>ThemeProvider</code> (defaults to dark mode).</li> <li>The root page (<code>page.tsx</code>) fetches task lists and redirects to the first one, or shows an empty state if <code>~/.claude/tasks/</code> has no task lists.</li> <li>The <code>[listId]/page.tsx</code> Server Component fetches data and renders <code>TaskBoardClient</code> with <code>initialData</code>.</li> <li>On the client, <code>TaskBoardClient</code> calls <code>useSSE(listId)</code>, which opens the SSE connection. The SSE route handler lazily starts the Chokidar watcher if not already running.</li> </ol>"},{"location":"task-manager/overview/#real-time-update-cycle","title":"Real-Time Update Cycle","text":"<ol> <li>A Claude AI agent writes or updates a <code>.json</code> file in <code>~/.claude/tasks/&lt;listId&gt;/</code>.</li> <li>Chokidar detects the change (within ~300ms) and the <code>FileWatcher</code> emits a <code>taskEvent</code>.</li> <li>The SSE route handler serializes the event and pushes it to the <code>ReadableStream</code>.</li> <li>The browser's <code>EventSource</code> receives the event and fires the appropriate listener.</li> <li><code>useSSE</code> invalidates the TanStack Query cache and calls <code>router.refresh()</code>.</li> <li>TanStack Query re-fetches task data from the API route; the Server Component re-executes on the server.</li> <li>The UI updates without a full page reload.</li> </ol>"},{"location":"task-manager/overview/#execution-context-monitoring","title":"Execution Context Monitoring","text":"<p>When the <code>execute-tasks</code> plugin skill is running, it writes an <code>execution_pointer.md</code> file into the task list directory. This pointer contains the absolute path to the live session directory (e.g., <code>.claude/sessions/__live_session__/</code>).</p> <p>The SSE route handler detects this pointer and dynamically adds the execution directory to the Chokidar watcher. As execution artifacts (<code>progress.md</code>, <code>task_log.md</code>, <code>execution_plan.md</code>) are updated, the watcher emits <code>execution:updated</code> events.</p> <p>The <code>useExecutionContext</code> hook has a shorter <code>staleTime</code> (2 seconds) and a 5-second <code>refetchInterval</code> to keep execution state fresh even if SSE events are missed.</p> <p>Execution Artifacts</p> <p>Artifacts are sorted in a fixed display order: <code>execution_context</code> first, then <code>task_log</code>, <code>execution_plan</code>, <code>session_summary</code>, with any remaining files sorted alphabetically. Temporary per-wave context files (<code>context-task-*</code>) are filtered out.</p>"},{"location":"task-manager/overview/#task-file-format","title":"Task File Format","text":"<p>Task files are JSON stored at <code>~/.claude/tasks/&lt;list-name&gt;/&lt;id&gt;.json</code>:</p> Example: ~/.claude/tasks/my-project/1.json<pre><code>{\n  \"id\": \"1\",\n  \"subject\": \"Implement user authentication\",\n  \"description\": \"Add OAuth2 login flow with session management\",\n  \"status\": \"in_progress\",\n  \"activeForm\": \"Working on token refresh logic\",\n  \"blocks\": [\"2\", \"3\"],\n  \"blockedBy\": [],\n  \"metadata\": {\n    \"priority\": \"high\",\n    \"complexity\": \"L\"\n  }\n}\n</code></pre> Field Type Required Description <code>id</code> <code>string</code> Yes Unique identifier (coerced from number if needed) <code>subject</code> <code>string</code> Yes Short task title <code>description</code> <code>string</code> No Detailed description (defaults to <code>\"\"</code>) <code>status</code> <code>string</code> No <code>pending</code>, <code>in_progress</code>, or <code>completed</code> (defaults to <code>pending</code>) <code>activeForm</code> <code>string</code> No Current work-in-progress note <code>blocks</code> <code>string[]</code> No IDs of tasks this task blocks (defaults to <code>[]</code>) <code>blockedBy</code> <code>string[]</code> No IDs of tasks blocking this one (defaults to <code>[]</code>) <code>metadata</code> <code>object</code> No Arbitrary metadata (priority, complexity, etc.) <p>Valid <code>status</code> values: <code>pending</code> | <code>in_progress</code> | <code>completed</code></p> <p>Valid <code>priority</code> values: <code>critical</code> | <code>high</code> | <code>medium</code> | <code>low</code></p> <p>Valid <code>complexity</code> values: <code>XS</code> | <code>S</code> | <code>M</code> | <code>L</code> | <code>XL</code></p>"},{"location":"task-manager/overview/#api-endpoints","title":"API Endpoints","text":"Method Endpoint Description GET <code>/api/health</code> Health check GET <code>/api/task-lists</code> List all task lists GET <code>/api/tasks/:listId</code> Get tasks for a specific list GET <code>/api/execution-context/:listId</code> Get execution context for a list GET <code>/api/events?taskListId=&lt;id&gt;</code> SSE stream for real-time updates <p>For request/response schemas and detailed endpoint documentation, see API Reference.</p>"},{"location":"task-manager/overview/#security","title":"Security","text":"<p>The Task Manager implements several security measures to safely read from the filesystem:</p> <ul> <li>Path traversal guard \u2014 <code>resolveExecutionDir()</code> in <code>taskService.ts</code> uses <code>path.relative()</code> to verify that execution pointer targets stay under <code>$HOME</code>. Paths that escape the home directory are rejected.</li> <li>API route validation \u2014 The <code>GET /api/tasks/:listId</code> route rejects <code>listId</code> values containing <code>..</code> or <code>/</code> to prevent directory traversal.</li> <li>Defensive parsing \u2014 <code>parseTask()</code> normalizes all fields, defaulting unknown statuses to <code>\"pending\"</code> and coercing types, preventing malformed JSON from crashing the application.</li> <li>Read-only access \u2014 The Task Manager never writes to the filesystem. It is a pure read-only viewer.</li> </ul> <p>For a complete security analysis, see Security.</p>"},{"location":"task-manager/overview/#running-the-application","title":"Running the Application","text":"Development<pre><code>cd apps/task-manager\npnpm install\npnpm dev          # Starts on http://localhost:3030\n</code></pre> Production<pre><code>cd apps/task-manager\npnpm build\npnpm start\n</code></pre> <p>Prerequisites</p> <p>Task files must exist in <code>~/.claude/tasks/</code> for the board to display data. If no task lists are found, the app shows an empty state with instructions. Task files are typically created by the Claude Alchemy plugin skills \u2014 see the Plugin Architecture docs.</p>"},{"location":"task-manager/overview/#related-pages","title":"Related Pages","text":"<ul> <li>API Reference \u2014 Detailed endpoint documentation with request/response schemas</li> <li>Real-Time System \u2014 Deep dive into the Chokidar + SSE pipeline</li> <li>Components \u2014 UI component breakdown and props reference</li> <li>Security \u2014 Path traversal guards, input validation, and threat model</li> </ul>"},{"location":"task-manager/real-time-system/","title":"Real-Time System","text":""},{"location":"task-manager/real-time-system/#real-time-update-system","title":"Real-Time Update System","text":"<p>The Task Manager delivers live UI updates without polling from the browser. When a task JSON file changes on disk \u2014 whether written by a Claude plugin or edited manually \u2014 the change propagates through a four-stage pipeline and arrives in the React UI within milliseconds. This page documents every stage of that pipeline, the design decisions behind it, and the configuration that controls its behavior.</p>"},{"location":"task-manager/real-time-system/#pipeline-overview","title":"Pipeline Overview","text":"<p>The full data flow from filesystem change to rendered pixel:</p> <pre><code>~/.claude/tasks/*.json\n        \u2502\n        \u25bc\n  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n  \u2502 FileWatcher  \u2502  Chokidar (300ms poll) + Node EventEmitter\n  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n         \u2502  'taskEvent' / 'executionEvent'\n         \u25bc\n  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n  \u2502  SSE Route   \u2502  ReadableStream \u2192 text/event-stream\n  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n         \u2502  EventSource (browser)\n         \u25bc\n  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n  \u2502  useSSE Hook \u2502  TanStack Query invalidation + router.refresh()\n  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n         \u2502\n         \u25bc\n      React UI\n</code></pre> <pre><code>sequenceDiagram\n    participant FS as Filesystem&lt;br/&gt;~/.claude/tasks/\n    participant CK as Chokidar&lt;br/&gt;(FileWatcher)\n    participant EE as EventEmitter\n    participant SSE as SSE Route&lt;br/&gt;/api/events\n    participant ES as EventSource&lt;br/&gt;(Browser)\n    participant Hook as useSSE Hook\n    participant TQ as TanStack Query\n    participant SC as Server Components\n    participant UI as React UI\n\n    FS-&gt;&gt;CK: File change detected (300ms poll)\n    CK-&gt;&gt;EE: emit('taskEvent', event)\n    EE-&gt;&gt;SSE: handleTaskEvent callback\n    SSE-&gt;&gt;ES: event: task:updated\\ndata: {...}\n    ES-&gt;&gt;Hook: addEventListener('task:updated')\n    par Dual Invalidation\n        Hook-&gt;&gt;TQ: invalidateQueries({ queryKey })\n        TQ-&gt;&gt;UI: Re-render with fresh data\n    and\n        Hook-&gt;&gt;SC: router.refresh()\n        SC-&gt;&gt;UI: Re-render Server Components\n    end</code></pre>"},{"location":"task-manager/real-time-system/#event-types","title":"Event Types","text":"<p>The system emits two categories of events, defined in <code>src/types/task.ts</code>:</p> Event Category Trigger Payload <code>task:created</code> Task New <code>.json</code> file added <code>{ type, taskListId, taskId, task }</code> <code>task:updated</code> Task Existing <code>.json</code> file changed <code>{ type, taskListId, taskId, task }</code> <code>task:deleted</code> Task <code>.json</code> file removed <code>{ type, taskListId, taskId }</code> <code>execution:updated</code> Execution <code>.md</code> or <code>.txt</code> file changed in execution dir <code>{ type, taskListId }</code> src/types/task.ts<pre><code>export type SSEEventType = 'task:created' | 'task:updated' | 'task:deleted'\nexport type ExecutionSSEEventType = 'execution:updated'\n\nexport interface SSEEvent {\n  type: SSEEventType\n  taskListId: string\n  taskId: string\n  task?: Task\n}\n\nexport interface ExecutionSSEEvent {\n  type: ExecutionSSEEventType\n  taskListId: string\n}\n</code></pre>"},{"location":"task-manager/real-time-system/#stage-1-filewatcher","title":"Stage 1: FileWatcher","text":"<p>Source: <code>src/lib/fileWatcher.ts</code></p> <p>The <code>FileWatcher</code> class wraps Chokidar in a Node.js <code>EventEmitter</code> that translates filesystem events into typed application events.</p>"},{"location":"task-manager/real-time-system/#singleton-pattern","title":"Singleton Pattern","text":"<p>Next.js hot module replacement (HMR) re-executes module-level code on every file save during development. Without protection, each HMR cycle would spawn a new Chokidar watcher \u2014 leaking file descriptors and emitting duplicate events. The <code>globalThis</code> singleton pattern prevents this:</p> src/lib/fileWatcher.ts<pre><code>const globalForWatcher = globalThis as unknown as {\n  fileWatcher: FileWatcher | undefined\n}\n\nexport const fileWatcher = globalForWatcher.fileWatcher ?? new FileWatcher()\n\nif (process.env.NODE_ENV !== 'production') {\n  globalForWatcher.fileWatcher = fileWatcher\n}\n</code></pre> <p>In development, the instance is pinned to <code>globalThis</code> so it survives HMR. In production, module caching handles deduplication naturally.</p>"},{"location":"task-manager/real-time-system/#chokidar-configuration","title":"Chokidar Configuration","text":"src/lib/fileWatcher.ts<pre><code>this.watcher = watch(this.basePath, {\n  persistent: true,\n  ignoreInitial: true,\n  usePolling: true,\n  interval: 300,\n  depth: 2,\n})\n</code></pre> Option Value Rationale <code>persistent</code> <code>true</code> Keep the Node process alive for the watcher <code>ignoreInitial</code> <code>true</code> Don't emit events for files that already exist at startup <code>usePolling</code> <code>true</code> Filesystem events (<code>fsevents</code>/<code>inotify</code>) can miss changes written by external processes. Polling is more reliable for cross-process file watching <code>interval</code> <code>300</code> ms Balance between responsiveness and CPU usage <code>depth</code> <code>2</code> Watch <code>~/.claude/tasks/&lt;listId&gt;/&lt;file&gt;</code> \u2014 two levels deep from the base path"},{"location":"task-manager/real-time-system/#event-routing","title":"Event Routing","text":"<p>The watcher maps raw Chokidar events to typed application events based on file extension:</p> src/lib/fileWatcher.ts<pre><code>this.watcher\n  .on('add', (path) =&gt; {\n    if (path.endsWith('.json')) {\n      this.handleFileChange('task:created', path)\n    } else if (this.isExecutionFile(path)) {\n      this.handleExecutionChange(path)\n    }\n  })\n  .on('change', (path) =&gt; {\n    if (path.endsWith('.json')) {\n      this.handleFileChange('task:updated', path)\n    } else if (this.isExecutionFile(path)) {\n      this.handleExecutionChange(path)\n    }\n  })\n  .on('unlink', (path) =&gt; {\n    if (path.endsWith('.json')) {\n      this.handleFileDelete(path)\n    } else if (this.isExecutionFile(path)) {\n      this.handleExecutionChange(path)\n    }\n  })\n</code></pre> <ul> <li><code>.json</code> files become <code>taskEvent</code> emissions \u2014 the handler reads the file, parses it, and includes the full <code>Task</code> object in the event payload.</li> <li><code>.md</code> / <code>.txt</code> files become <code>executionEvent</code> emissions \u2014 lightweight events that carry only the <code>taskListId</code>, signaling the client to refetch execution context.</li> </ul>"},{"location":"task-manager/real-time-system/#dynamic-execution-directory-watching","title":"Dynamic Execution Directory Watching","text":"<p>Execution artifacts (like <code>progress.md</code> and <code>task_log.md</code>) live outside the base <code>~/.claude/tasks/</code> directory, in session-specific paths such as <code>.claude/sessions/__live_session__/</code>. The <code>watchExecutionDir</code> method dynamically adds these directories to the Chokidar watcher:</p> src/lib/fileWatcher.ts<pre><code>watchExecutionDir(taskListId: string, execDir: string): void {\n  if (!this.watcher || !this.started) return\n\n  const existing = this.watchedExecDirs.get(taskListId)\n  if (existing === execDir) return\n\n  // If there was a previous exec dir for this list, unwatch it\n  if (existing) {\n    this.watcher.unwatch(existing)\n  }\n\n  this.watchedExecDirs.set(taskListId, execDir)\n  this.watcher.add(execDir)\n}\n</code></pre> <p>Deduplication</p> <p>The <code>watchedExecDirs</code> map (keyed by <code>taskListId</code>) ensures only one execution directory is watched per task list at any time. When a new execution session starts and the pointer changes, the old directory is unwatched before the new one is added.</p>"},{"location":"task-manager/real-time-system/#event-interfaces","title":"Event Interfaces","text":"src/lib/fileWatcher.ts<pre><code>export interface FileWatcherEvent {\n  type: SSEEventType\n  taskListId: string\n  taskId: string\n  task?: Task\n}\n\nexport interface ExecutionWatcherEvent {\n  type: ExecutionSSEEventType\n  taskListId: string\n}\n</code></pre>"},{"location":"task-manager/real-time-system/#stage-2-sse-route","title":"Stage 2: SSE Route","text":"<p>Source: <code>src/app/api/events/route.ts</code></p> <p>The API route bridges the server-side <code>FileWatcher</code> to the browser using Server-Sent Events. It uses the Web Streams API (<code>ReadableStream</code>) to push events over a long-lived HTTP connection.</p>"},{"location":"task-manager/real-time-system/#route-configuration","title":"Route Configuration","text":"src/app/api/events/route.ts<pre><code>export const dynamic = 'force-dynamic'\nexport const runtime = 'nodejs'\n</code></pre> <ul> <li><code>force-dynamic</code> prevents Next.js from caching this route as static.</li> <li><code>runtime: 'nodejs'</code> is required because the route depends on Node.js APIs (<code>EventEmitter</code>, <code>chokidar</code>) that are unavailable in the Edge runtime.</li> </ul>"},{"location":"task-manager/real-time-system/#connection-lifecycle","title":"Connection Lifecycle","text":"src/app/api/events/route.ts<pre><code>export async function GET(request: Request) {\n  const { searchParams } = new URL(request.url)\n  const taskListId = searchParams.get('taskListId')\n\n  // Lazy initialization \u2014 watcher starts on first SSE connection\n  if (!fileWatcher.isStarted()) {\n    await fileWatcher.start()\n  }\n\n  // Dynamically watch execution directory for this task list\n  if (taskListId) {\n    const execDir = await getExecutionDir(taskListId)\n    if (execDir) {\n      fileWatcher.watchExecutionDir(taskListId, execDir)\n    }\n  }\n\n  // ... stream setup\n}\n</code></pre> <p>Lazy Start</p> <p>The <code>FileWatcher</code> starts only when the first browser connects. This avoids spinning up Chokidar during build or when the SSE endpoint is never called.</p>"},{"location":"task-manager/real-time-system/#stream-construction","title":"Stream Construction","text":"<p>The route constructs a <code>ReadableStream</code> that:</p> <ol> <li>Sends an initial <code>connected</code> event to confirm the connection is live.</li> <li>Subscribes to <code>taskEvent</code> and <code>executionEvent</code> on the <code>FileWatcher</code>.</li> <li>Filters events by the <code>taskListId</code> query parameter \u2014 each browser tab only receives events for the task list it is viewing.</li> <li>Sends a heartbeat comment (<code>:heartbeat</code>) every 30 seconds to keep the connection alive through proxies and load balancers.</li> <li>Cleans up listeners when the client disconnects (<code>request.signal.abort</code>).</li> </ol> src/app/api/events/route.ts<pre><code>const stream = new ReadableStream({\n  start(controller) {\n    controller.enqueue(encoder.encode(`event: connected\\ndata: {}\\n\\n`))\n\n    const handleTaskEvent = (event: FileWatcherEvent) =&gt; {\n      if (taskListId &amp;&amp; event.taskListId !== taskListId) return\n      const data = JSON.stringify(event)\n      controller.enqueue(encoder.encode(`event: ${event.type}\\ndata: ${data}\\n\\n`))\n    }\n\n    const handleExecutionEvent = (event: ExecutionWatcherEvent) =&gt; {\n      if (taskListId &amp;&amp; event.taskListId !== taskListId) return\n      const data = JSON.stringify(event)\n      controller.enqueue(encoder.encode(`event: ${event.type}\\ndata: ${data}\\n\\n`))\n    }\n\n    fileWatcher.on('taskEvent', handleTaskEvent)\n    fileWatcher.on('executionEvent', handleExecutionEvent)\n\n    const heartbeat = setInterval(() =&gt; {\n      try {\n        controller.enqueue(encoder.encode(`:heartbeat\\n\\n`))\n      } catch {\n        clearInterval(heartbeat)\n      }\n    }, 30000)\n\n    request.signal.addEventListener('abort', () =&gt; {\n      clearInterval(heartbeat)\n      fileWatcher.off('taskEvent', handleTaskEvent)\n      fileWatcher.off('executionEvent', handleExecutionEvent)\n    })\n  },\n})\n</code></pre>"},{"location":"task-manager/real-time-system/#response-headers","title":"Response Headers","text":"src/app/api/events/route.ts<pre><code>return new Response(stream, {\n  headers: {\n    'Content-Type': 'text/event-stream',\n    'Cache-Control': 'no-cache, no-transform',\n    'Connection': 'keep-alive',\n    'X-Accel-Buffering': 'no',\n  },\n})\n</code></pre> Header Purpose <code>Content-Type: text/event-stream</code> Standard SSE content type \u2014 tells the browser to use <code>EventSource</code> protocol <code>Cache-Control: no-cache, no-transform</code> Prevent caching and proxy transformation of the event stream <code>Connection: keep-alive</code> Signal that this is a persistent connection <code>X-Accel-Buffering: no</code> Disable buffering in nginx reverse proxies (common in deployment)"},{"location":"task-manager/real-time-system/#stage-3-usesse-hook","title":"Stage 3: useSSE Hook","text":"<p>Source: <code>src/hooks/useSSE.ts</code></p> <p>The <code>useSSE</code> hook is the client-side consumer. It creates a browser-native <code>EventSource</code> connection, listens for typed events, and triggers the dual invalidation strategy.</p>"},{"location":"task-manager/real-time-system/#connection-management","title":"Connection Management","text":"src/hooks/useSSE.ts<pre><code>export function useSSE(taskListId: string | null) {\n  const queryClient = useQueryClient()\n  const router = useRouter()\n  const eventSourceRef = useRef&lt;EventSource | null&gt;(null)\n  const [reconnectKey, setReconnectKey] = useState(0)\n\n  useEffect(() =&gt; {\n    if (!taskListId) return\n\n    const url = `/api/events?taskListId=${encodeURIComponent(taskListId)}`\n    const eventSource = new EventSource(url)\n    eventSourceRef.current = eventSource\n\n    // ... event listeners\n\n    return () =&gt; {\n      eventSource.close()\n      eventSourceRef.current = null\n    }\n  }, [taskListId, queryClient, router, reconnectKey])\n}\n</code></pre> <p>The <code>useEffect</code> dependency array includes <code>reconnectKey</code> \u2014 a piece of state used solely to force the effect to re-run and establish a new <code>EventSource</code> connection after an error.</p>"},{"location":"task-manager/real-time-system/#event-handlers","title":"Event Handlers","text":"src/hooks/useSSE.ts<pre><code>const handleTaskEvent = () =&gt; {\n  queryClient.invalidateQueries({ queryKey: taskKeys.list(taskListId) })\n  queryClient.invalidateQueries({ queryKey: taskListKeys.all })\n  router.refresh()\n}\n\nconst handleExecutionEvent = () =&gt; {\n  queryClient.invalidateQueries({\n    queryKey: executionContextKeys.list(taskListId),\n  })\n  router.refresh()\n}\n\neventSource.addEventListener('task:created', handleTaskEvent)\neventSource.addEventListener('task:updated', handleTaskEvent)\neventSource.addEventListener('task:deleted', handleTaskEvent)\neventSource.addEventListener('execution:updated', handleExecutionEvent)\n</code></pre> <p>Why invalidate <code>taskListKeys.all</code> on task events?</p> <p>Task list objects include a <code>taskCount</code> field. When a task is created or deleted, the count changes, so the task list query must also be invalidated to keep the sidebar accurate.</p>"},{"location":"task-manager/real-time-system/#auto-reconnection","title":"Auto-Reconnection","text":"src/hooks/useSSE.ts<pre><code>eventSource.onerror = (error) =&gt; {\n  console.error('SSE error:', error)\n  eventSource.close()\n\n  setTimeout(() =&gt; {\n    console.log('Attempting SSE reconnection...')\n    setReconnectKey((k) =&gt; k + 1)\n  }, 3000)\n}\n</code></pre> <p>When the connection drops (server restart, network blip), the hook:</p> <ol> <li>Closes the broken <code>EventSource</code> immediately.</li> <li>Waits 3 seconds to avoid hammering the server.</li> <li>Increments <code>reconnectKey</code>, which triggers the <code>useEffect</code> cleanup and re-run, establishing a fresh connection.</li> </ol>"},{"location":"task-manager/real-time-system/#stage-4-dual-invalidation","title":"Stage 4: Dual Invalidation","text":"<p>The system uses two parallel invalidation paths to ensure both client-cached data and server-rendered data stay current.</p> <pre><code>graph TD\n    SSE[SSE Event Received] --&gt; TQ[TanStack Query&lt;br/&gt;invalidateQueries]\n    SSE --&gt; RR[Next.js&lt;br/&gt;router.refresh]\n    TQ --&gt; CF[Client Fetch&lt;br/&gt;via queryFn]\n    CF --&gt; CR[Client Components&lt;br/&gt;re-render]\n    RR --&gt; SF[Server Re-render&lt;br/&gt;fetch fresh data]\n    SF --&gt; SR[Server Components&lt;br/&gt;hydrate new props]</code></pre>"},{"location":"task-manager/real-time-system/#why-both","title":"Why Both?","text":"<p>The Task Manager uses a hybrid rendering architecture:</p> <ul> <li>Server Components (<code>page.tsx</code>) fetch initial task data on the server and pass it as props. These components only re-render when <code>router.refresh()</code> is called.</li> <li>Client Components (<code>KanbanBoard</code>, <code>TaskBoardClient</code>) use TanStack Query for ongoing state. These components re-render when their query cache is invalidated.</li> </ul> <p>If only TanStack Query were invalidated, Server Component data would go stale. If only <code>router.refresh()</code> were called, client-side query caches would still hold old data until their <code>staleTime</code> expired.</p> <p>Order Independence</p> <p>Both invalidation paths fire simultaneously (not sequentially). There is no guarantee which update reaches the DOM first. This is safe because both paths converge on the same source of truth \u2014 the filesystem.</p>"},{"location":"task-manager/real-time-system/#query-configuration","title":"Query Configuration","text":""},{"location":"task-manager/real-time-system/#queryclient-defaults","title":"QueryClient Defaults","text":"src/components/Providers.tsx<pre><code>const queryClient = new QueryClient({\n  defaultOptions: {\n    queries: {\n      staleTime: 1000 * 60, // 1 minute\n      refetchOnWindowFocus: false,\n    },\n  },\n})\n</code></pre> Setting Value Rationale <code>staleTime</code> 60 seconds Since SSE pushes updates in real-time, aggressive background refetching is unnecessary. Data stays \"fresh\" for 1 minute <code>refetchOnWindowFocus</code> <code>false</code> Tab switching should not trigger refetches \u2014 SSE ensures data is already current"},{"location":"task-manager/real-time-system/#query-key-factories","title":"Query Key Factories","text":"<p>Each data domain defines a key factory for consistent cache management:</p> src/hooks/useTasks.ts<pre><code>export const taskKeys = {\n  all: ['tasks'] as const,\n  list: (listId: string) =&gt; [...taskKeys.all, listId] as const,\n}\n</code></pre> src/hooks/useTaskLists.ts<pre><code>export const taskListKeys = {\n  all: ['task-lists'] as const,\n}\n</code></pre> src/hooks/useExecutionContext.ts<pre><code>export const executionContextKeys = {\n  all: ['execution-context'] as const,\n  list: (listId: string) =&gt; [...executionContextKeys.all, listId] as const,\n}\n</code></pre>"},{"location":"task-manager/real-time-system/#execution-context-faster-polling","title":"Execution Context: Faster Polling","text":"<p>The execution context query uses more aggressive timing because execution progress changes rapidly during active task runs:</p> src/hooks/useExecutionContext.ts<pre><code>export function useExecutionContext(\n  taskListId: string | null,\n  initialData?: ExecutionContext | null\n) {\n  return useQuery({\n    queryKey: executionContextKeys.list(taskListId ?? ''),\n    queryFn: () =&gt; fetchExecutionContext(taskListId!),\n    enabled: !!taskListId,\n    initialData: initialData ?? undefined,\n    staleTime: 2000,\n    refetchInterval: 5000,\n  })\n}\n</code></pre> Setting Value Rationale <code>staleTime</code> 2 seconds Execution progress data becomes stale almost immediately <code>refetchInterval</code> 5 seconds Poll every 5s as a fallback in case an SSE event is missed <p>Belt and Suspenders</p> <p>The execution context uses both SSE-driven invalidation and interval-based polling. SSE provides low-latency updates, while the 5-second polling interval acts as a safety net for missed events \u2014 particularly useful during high-frequency file writes when Chokidar's 300ms polling might coalesce rapid changes.</p>"},{"location":"task-manager/real-time-system/#security-considerations","title":"Security Considerations","text":""},{"location":"task-manager/real-time-system/#path-traversal-protection","title":"Path Traversal Protection","text":"<p>The <code>resolveExecutionDir</code> function in <code>taskService.ts</code> guards against malicious execution pointers that could read arbitrary files:</p> src/lib/taskService.ts<pre><code>function resolveExecutionDir(pointerContent: string): string | null {\n  const raw = pointerContent.trim()\n  if (!raw) return null\n\n  const home = homedir()\n  const resolved = raw.startsWith('/') ? resolve(raw) : resolve(home, raw)\n\n  // Guard against path traversal \u2014 execution dir must be under home\n  const rel = relative(home, resolved)\n  if (rel.startsWith('..') || resolve(home, rel) !== resolved) {\n    console.warn(`Execution pointer path escapes home directory: ${raw}`)\n    return null\n  }\n\n  return resolved\n}\n</code></pre> <p>The <code>execution_pointer.md</code> file contains a path to the execution directory. Since this file is written by the plugin, a compromised or malformed pointer could attempt to escape the home directory (e.g., <code>../../../etc/</code>). The guard ensures the resolved path always remains under <code>$HOME</code>.</p>"},{"location":"task-manager/real-time-system/#event-filtering","title":"Event Filtering","text":"<p>The SSE route filters events by <code>taskListId</code>, preventing a client viewing one task list from receiving events for another. This is a convenience filter (not a security boundary), since all task data is local to the user's machine.</p>"},{"location":"task-manager/real-time-system/#troubleshooting","title":"Troubleshooting","text":""},{"location":"task-manager/real-time-system/#events-not-arriving-in-the-browser","title":"Events Not Arriving in the Browser","text":"<p>Diagnostic Steps</p> <ol> <li>Open the browser DevTools Network tab and look for the <code>/api/events</code> request. It should show as \"pending\" (long-lived connection).</li> <li>Check the Console for <code>SSE connected: {}</code> \u2014 this confirms the <code>EventSource</code> opened successfully.</li> <li>Look for <code>File watcher started: watching ...</code> in the Next.js server terminal output.</li> <li>Verify task files exist in <code>~/.claude/tasks/&lt;listId&gt;/</code> and are valid JSON.</li> </ol>"},{"location":"task-manager/real-time-system/#duplicate-events-or-stale-data","title":"Duplicate Events or Stale Data","text":"<p>The <code>globalThis</code> singleton prevents duplicate watchers during development HMR. If you see duplicate events:</p> <ol> <li>Restart the Next.js dev server (<code>pnpm dev</code>) to clear any orphaned watchers.</li> <li>Check that only one browser tab is connected to the same <code>taskListId</code> (multiple tabs are fine, but each opens its own SSE connection).</li> </ol>"},{"location":"task-manager/real-time-system/#sse-connection-drops","title":"SSE Connection Drops","text":"<p>The <code>useSSE</code> hook automatically reconnects after a 3-second delay. If connections drop repeatedly:</p> <ul> <li>Check for proxy or firewall timeout settings shorter than the 30-second heartbeat interval.</li> <li>Ensure <code>X-Accel-Buffering: no</code> is respected if running behind nginx.</li> </ul>"},{"location":"task-manager/real-time-system/#execution-context-not-updating","title":"Execution Context Not Updating","text":"<p>If task events work but execution context does not update:</p> <ol> <li>Verify <code>execution_pointer.md</code> exists in <code>~/.claude/tasks/&lt;listId&gt;/</code> and contains a valid absolute path.</li> <li>Check that the execution directory path resolves to a location under your home directory.</li> <li>Look for <code>File watcher: now watching execution dir for ...</code> in the server logs.</li> </ol>"},{"location":"task-manager/security/","title":"Security","text":""},{"location":"task-manager/security/#security-patterns","title":"Security Patterns","text":"<p>The Task Manager reads and displays files from the local filesystem, making input validation and path safety critical. This page documents every security boundary in the application \u2014 from path traversal guards to defensive data parsing \u2014 and explains the rationale behind each pattern.</p>"},{"location":"task-manager/security/#threat-model","title":"Threat Model","text":"<p>The Task Manager operates as a localhost development tool that reads task data from <code>~/.claude/tasks/</code> and execution artifacts from project-local <code>.claude/sessions/</code> directories. The primary attack surface is malicious or malformed file content \u2014 particularly <code>execution_pointer.md</code>, which contains a user-controlled file path that the server resolves and reads from.</p> <pre><code>graph LR\n    A[\"execution_pointer.md&lt;br/&gt;(user-controlled path)\"] --&gt;|resolveExecutionDir| B{Path Traversal Guard}\n    B --&gt;|valid| C[Read Session Files]\n    B --&gt;|\"starts with ..&lt;br/&gt;or mismatch\"| D[Reject \u2014 return null]\n    E[\"API route params&lt;br/&gt;(listId)\"] --&gt;|validate| F{\"Contains .. or /?\"}\n    F --&gt;|no| G[Filesystem Access]\n    F --&gt;|yes| H[\"Reject \u2014 400 Bad Request\"]\n    I[\"task JSON files\"] --&gt;|parseTask| J{Defensive Parser}\n    J --&gt;|valid| K[Normalized Task Object]\n    J --&gt;|malformed| L[\"Return null (skip task)\"]</code></pre>"},{"location":"task-manager/security/#path-traversal-guard","title":"Path Traversal Guard","text":"<p>The most critical security boundary in the application. The <code>resolveExecutionDir()</code> function in <code>taskService.ts</code> prevents <code>execution_pointer.md</code> from directing the server to read arbitrary files outside the user's home directory.</p>"},{"location":"task-manager/security/#how-it-works","title":"How It Works","text":"<p>The pointer file contains an absolute path to a session directory (e.g., <code>/Users/sequenzia/dev/repos/my-project/.claude/sessions/__live_session__/</code>). The guard validates this path in two steps:</p> <ol> <li>Resolve the path \u2014 handles both absolute and relative paths via <code>path.resolve()</code></li> <li>Verify containment \u2014 uses <code>path.relative(home, resolved)</code> and checks that the relative path does not start with <code>..</code> and that round-tripping through <code>resolve(home, rel)</code> produces the same absolute path</li> </ol> apps/task-manager/src/lib/taskService.ts<pre><code>function resolveExecutionDir(pointerContent: string): string | null {\n  const raw = pointerContent.trim()\n  if (!raw) return null\n\n  const home = homedir()\n  const resolved = raw.startsWith('/') ? resolve(raw) : resolve(home, raw)\n\n  // Guard against path traversal \u2014 execution dir must be under home\n  const rel = relative(home, resolved)\n  if (rel.startsWith('..') || resolve(home, rel) !== resolved) {\n    console.warn(`Execution pointer path escapes home directory: ${raw}`)\n    return null\n  }\n\n  return resolved\n}\n</code></pre>"},{"location":"task-manager/security/#why-two-checks","title":"Why Two Checks","text":"<p>Defense in Depth</p> <p>The <code>rel.startsWith('..')</code> check catches the obvious case where the resolved path is outside <code>$HOME</code>. The round-trip check (<code>resolve(home, rel) !== resolved</code>) catches edge cases involving symlinks or path normalization inconsistencies where the relative path might not start with <code>..</code> but still resolves to an unexpected location.</p>"},{"location":"task-manager/security/#attack-scenarios-blocked","title":"Attack Scenarios Blocked","text":"Pointer Content <code>resolved</code> <code>rel</code> Result <code>/etc/passwd</code> <code>/etc/passwd</code> <code>../../etc/passwd</code> Rejected \u2014 starts with <code>..</code> <code>../../../etc/shadow</code> <code>/etc/shadow</code> <code>../../etc/shadow</code> Rejected \u2014 starts with <code>..</code> <code>/Users/sequenzia/project/.claude/sessions/</code> <code>/Users/sequenzia/project/.claude/sessions/</code> <code>project/.claude/sessions/</code> Allowed \u2014 under <code>$HOME</code> <code></code> (empty/whitespace) \u2014 \u2014 Rejected \u2014 empty after trim <p>Scope Limitation</p> <p>The guard ensures paths stay under <code>$HOME</code>, not under a specific project directory. A malicious pointer could still read session files from a different project under the same home directory. This is an acceptable trade-off for a local development tool where all projects belong to the same user.</p>"},{"location":"task-manager/security/#api-route-input-validation","title":"API Route Input Validation","text":"<p>Both API routes that accept a <code>listId</code> parameter validate it before any filesystem access occurs. This prevents path traversal through the URL itself.</p>"},{"location":"task-manager/security/#tasks-route","title":"Tasks Route","text":"apps/task-manager/src/app/api/tasks/[listId]/route.ts<pre><code>export async function GET(request: Request, { params }: RouteParams) {\n  try {\n    const { listId } = await params\n\n    // Validate listId to prevent path traversal\n    if (!listId || listId.includes('..') || listId.includes('/')) {\n      return NextResponse.json(\n        { error: 'Invalid task list ID' },\n        { status: 400 }\n      )\n    }\n\n    const tasks = await getTasks(listId)\n    return NextResponse.json({ tasks })\n  } catch (error) {\n    console.error('Error fetching tasks:', error)\n    return NextResponse.json(\n      { error: 'Failed to fetch tasks' },\n      { status: 500 }\n    )\n  }\n}\n</code></pre>"},{"location":"task-manager/security/#execution-context-route","title":"Execution Context Route","text":"apps/task-manager/src/app/api/execution-context/[listId]/route.ts<pre><code>export async function GET(request: Request, { params }: RouteParams) {\n  try {\n    const { listId } = await params\n\n    if (!listId || listId.includes('..') || listId.includes('/')) {\n      return NextResponse.json(\n        { error: 'Invalid task list ID' },\n        { status: 400 }\n      )\n    }\n\n    const executionContext = await getExecutionContext(listId)\n    return NextResponse.json({ executionContext })\n  } catch (error) {\n    console.error('Error fetching execution context:', error)\n    return NextResponse.json(\n      { error: 'Failed to fetch execution context' },\n      { status: 500 }\n    )\n  }\n}\n</code></pre>"},{"location":"task-manager/security/#validation-logic","title":"Validation Logic","text":"<p>Both routes apply identical checks:</p> <ul> <li>Empty check \u2014 <code>!listId</code> rejects missing or empty parameters</li> <li><code>..</code> check \u2014 <code>listId.includes('..')</code> blocks directory traversal sequences</li> <li><code>/</code> check \u2014 <code>listId.includes('/')</code> blocks subdirectory access attempts</li> </ul> <p>Since <code>listId</code> is joined directly to <code>TASKS_DIR</code> (<code>~/.claude/tasks/</code>) via <code>path.join()</code>, a value like <code>../../etc</code> would resolve outside the tasks directory without this guard.</p> <p>Consistent Pattern</p> <p>Every route that accepts filesystem-derived parameters uses the same validation pattern. When adding new API routes that accept path-like parameters, replicate this check.</p>"},{"location":"task-manager/security/#defensive-task-parsing","title":"Defensive Task Parsing","text":"<p>The <code>parseTask()</code> function in <code>taskService.ts</code> handles malformed, incomplete, or unexpected JSON without crashing. Since task files are written by external processes (Claude Code plugins), the parser cannot assume well-formed input.</p> apps/task-manager/src/lib/taskService.ts<pre><code>function parseTask(content: string, filename: string): Task | null {\n  try {\n    const data = JSON.parse(content)\n\n    // Validate required fields\n    if (typeof data.id !== 'string' &amp;&amp; typeof data.id !== 'number') {\n      data.id = basename(filename, '.json')\n    } else {\n      data.id = String(data.id)\n    }\n\n    if (typeof data.subject !== 'string') {\n      console.warn(`Task ${data.id}: missing subject`)\n      return null\n    }\n\n    // Normalize status\n    if (!isValidTaskStatus(data.status)) {\n      data.status = 'pending'\n    }\n\n    // Ensure arrays exist\n    data.blocks = Array.isArray(data.blocks) ? data.blocks.map(String) : []\n    data.blockedBy = Array.isArray(data.blockedBy) ? data.blockedBy.map(String) : []\n\n    // Optional fields\n    data.description = typeof data.description === 'string' ? data.description : ''\n    if (data.activeForm !== undefined &amp;&amp; typeof data.activeForm !== 'string') {\n      delete data.activeForm\n    }\n\n    return data as Task\n  } catch (error) {\n    console.error(`Error parsing task file ${filename}:`, error)\n    return null\n  }\n}\n</code></pre>"},{"location":"task-manager/security/#normalization-rules","title":"Normalization Rules","text":"Field Problem Recovery <code>id</code> Missing or wrong type Falls back to filename (without <code>.json</code> extension) <code>id</code> Number instead of string Coerced to string via <code>String()</code> <code>subject</code> Missing or non-string Returns <code>null</code> \u2014 task is skipped entirely <code>status</code> Missing, null, or invalid value Defaults to <code>'pending'</code> <code>blocks</code> Missing or non-array Defaults to empty array <code>[]</code> <code>blockedBy</code> Missing or non-array Defaults to empty array <code>[]</code> <code>blocks</code>/<code>blockedBy</code> items Numbers instead of strings Each element coerced to string via <code>.map(String)</code> <code>description</code> Missing or non-string Defaults to empty string <code>''</code> <code>activeForm</code> Non-string value Deleted from the object Entire file Unparseable JSON Returns <code>null</code> \u2014 task is skipped <p>Fail-Safe Design</p> <p>All <code>taskService</code> functions that read from the filesystem return empty arrays or <code>null</code> rather than throwing exceptions. Functions like <code>getTasks()</code> wrap each file read in try/catch and skip individual failures, ensuring one corrupt task file does not prevent the rest from loading.</p>"},{"location":"task-manager/security/#hook-scoping-sdd-plugin","title":"Hook Scoping (SDD Plugin)","text":"<p>The SDD plugin's <code>auto-approve-session.sh</code> PreToolUse hook automatically approves file operations needed during task execution \u2014 but only for a tightly scoped set of paths and commands. All other operations fall through to the normal Claude Code permission flow.</p> plugins/sdd/hooks/auto-approve-session.sh<pre><code>case \"$tool_name\" in\n  Write|Edit)\n    file_path=$(echo \"$input\" | jq -r '.tool_input.file_path // empty')\n    [ -z \"$file_path\" ] &amp;&amp; exit 0\n\n    # Match execution_pointer.md in ~/.claude/tasks/*/\n    if [[ \"$file_path\" == \"$HOME/.claude/tasks/\"*/execution_pointer.md ]]; then\n      approve\n    fi\n\n    # Match any file inside .claude/sessions/\n    if [[ \"$file_path\" == */.claude/sessions/* ]]; then\n      approve\n    fi\n    ;;\n\n  Bash)\n    command=$(echo \"$input\" | jq -r '.tool_input.command // empty')\n    [ -z \"$command\" ] &amp;&amp; exit 0\n\n    # Match mkdir or mv targeting .claude/sessions/\n    if [[ \"$command\" == *\".claude/sessions/\"* ]]; then\n      if [[ \"$command\" == *mkdir* ]] || [[ \"$command\" == *mv* ]]; then\n        approve\n      fi\n    fi\n    ;;\nesac\n\n# No opinion \u2014 let normal permission flow handle it\nexit 0\n</code></pre>"},{"location":"task-manager/security/#approved-operations","title":"Approved Operations","text":"Tool Path Pattern Purpose <code>Write</code> / <code>Edit</code> <code>$HOME/.claude/tasks/*/execution_pointer.md</code> Create/update execution pointer <code>Write</code> / <code>Edit</code> <code>*/.claude/sessions/*</code> Write session artifacts (context, logs, progress) <code>Bash</code> (<code>mkdir</code>) Commands containing <code>.claude/sessions/</code> Create session directories <code>Bash</code> (<code>mv</code>) Commands containing <code>.claude/sessions/</code> Archive sessions (move <code>__live_session__/</code> contents) <p>Everything Else Is Denied by Default</p> <p>The hook exits with no output (<code>exit 0</code> without JSON) for any operation that does not match the patterns above. This means the normal permission flow applies \u2014 the user will be prompted to approve or deny the operation. The hook never explicitly denies; it either approves or abstains.</p>"},{"location":"task-manager/security/#why-this-matters","title":"Why This Matters","text":"<p>Without this hook, every file write during autonomous task execution would prompt the user for approval, breaking the unattended execution flow. The hook's narrow scope ensures that only session-management operations are auto-approved while all other file operations (source code edits, configuration changes) still require explicit user consent.</p>"},{"location":"task-manager/security/#session-isolation","title":"Session Isolation","text":"<p>The <code>execute-tasks</code> skill enforces strict session isolation to prevent concurrent execution conflicts and ensure clean recovery from interruptions.</p>"},{"location":"task-manager/security/#concurrency-guard-lock-file","title":"Concurrency Guard (<code>.lock</code> File)","text":"<p>Only one execution session can run at a time per project. A <code>.lock</code> file in <code>__live_session__/</code> prevents concurrent invocations.</p> <pre><code>&lt;!-- .claude/sessions/__live_session__/.lock --&gt;\ntask_execution_id: user-auth-20260208-143022\ntimestamp: 2026-02-08T14:30:22Z\npid: orchestrator\n</code></pre> <p>Lock lifecycle:</p> <ol> <li>Created at session start (Step 5.5 of orchestration)</li> <li>Checked before every new execution \u2014 if the lock exists and is less than 4 hours old, the user is prompted to force-start or cancel</li> <li>Stale locks older than 4 hours are automatically deleted (the previous session is assumed to have crashed)</li> <li>Released when the session completes \u2014 the lock file is moved to the archive directory along with all other session files</li> </ol>"},{"location":"task-manager/security/#interrupted-session-recovery","title":"Interrupted Session Recovery","text":"<p>When a new execution starts and finds leftover files in <code>__live_session__/</code>, the orchestrator:</p> <ol> <li>Archives the stale session to <code>.claude/sessions/interrupted-{YYYYMMDD}-{HHMMSS}/</code></li> <li>Cross-references <code>task_log.md</code> (if present) to identify which tasks were part of the interrupted session</li> <li>Resets those <code>in_progress</code> tasks back to <code>pending</code> via <code>TaskUpdate</code></li> <li>Logs each recovered task for auditability</li> </ol> <p>Conservative Recovery</p> <p>If no <code>task_log.md</code> is found in the archive (e.g., the session crashed before any tasks started), all <code>in_progress</code> tasks are reset to <code>pending</code>. This errs on the side of re-executing work rather than leaving tasks in a stuck state.</p>"},{"location":"task-manager/security/#agent-isolation","title":"Agent Isolation","text":"<p>Each task is executed by a fresh <code>task-executor</code> agent invocation with its own context window. Agents within the same wave:</p> <ul> <li>Read from a snapshot of <code>execution_context.md</code> taken before the wave launched</li> <li>Write to isolated per-task files (<code>context-task-{id}.md</code>) to prevent write contention</li> <li>Cannot see each other's in-progress changes</li> <li>Cannot modify each other's task status</li> </ul> <p>The orchestrator merges per-task context files into the shared <code>execution_context.md</code> only after all agents in a wave have completed.</p>"},{"location":"task-manager/security/#no-authentication-on-api-routes","title":"No Authentication on API Routes","text":"<p>Localhost-Only Assumption</p> <p>The Task Manager exposes task data and execution artifacts via HTTP API routes (<code>/api/tasks/:listId</code>, <code>/api/execution-context/:listId</code>, <code>/api/events</code>) without any authentication or authorization. This is acceptable for a local development tool running on <code>localhost</code>, but would require authentication if the application were ever deployed to a network-accessible host.</p> <p>Current API surface exposed without auth:</p> Endpoint Data Exposed <code>GET /api/task-lists</code> List of task list names <code>GET /api/tasks/:listId</code> All task data (subjects, descriptions, status, metadata) <code>GET /api/execution-context/:listId</code> Session artifacts (execution context, logs, progress) <code>GET /api/events?taskListId=:id</code> Real-time SSE stream of file change events <code>GET /api/health</code> Server health status <p>The SSE endpoint at <code>/api/events</code> additionally resolves the execution directory path via <code>getExecutionDir()</code>, which applies the path traversal guard documented above \u2014 so even unauthenticated access cannot escape the home directory.</p>"},{"location":"task-manager/security/#security-checklist","title":"Security Checklist","text":"<p>When modifying the Task Manager or adding new API routes, verify these invariants:</p> <ul> <li>[ ] Any new route parameter derived from user input is validated against <code>..</code> and <code>/</code> before filesystem access</li> <li>[ ] Any new file path resolved from external content passes through <code>resolveExecutionDir()</code> or an equivalent containment check</li> <li>[ ] Parser functions return <code>null</code> or empty collections on malformed input rather than throwing</li> <li>[ ] Error responses do not leak filesystem paths or internal state to the client</li> <li>[ ] The <code>auto-approve-session.sh</code> hook is updated if new session file paths are introduced</li> <li>[ ] No secrets, credentials, or <code>.env</code> files are read or served by any route</li> </ul>"}]}